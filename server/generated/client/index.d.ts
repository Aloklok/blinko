
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model accounts
 * 
 */
export type accounts = $Result.DefaultSelection<Prisma.$accountsPayload>
/**
 * Model attachments
 * 
 */
export type attachments = $Result.DefaultSelection<Prisma.$attachmentsPayload>
/**
 * Model config
 * 
 */
export type config = $Result.DefaultSelection<Prisma.$configPayload>
/**
 * Model notes
 * 
 */
export type notes = $Result.DefaultSelection<Prisma.$notesPayload>
/**
 * Model comments
 * 
 */
export type comments = $Result.DefaultSelection<Prisma.$commentsPayload>
/**
 * Model tag
 * 
 */
export type tag = $Result.DefaultSelection<Prisma.$tagPayload>
/**
 * Model tagsToNote
 * 
 */
export type tagsToNote = $Result.DefaultSelection<Prisma.$tagsToNotePayload>
/**
 * Model noteReference
 * 
 */
export type noteReference = $Result.DefaultSelection<Prisma.$noteReferencePayload>
/**
 * Model follows
 * 
 */
export type follows = $Result.DefaultSelection<Prisma.$followsPayload>
/**
 * Model notifications
 * 
 */
export type notifications = $Result.DefaultSelection<Prisma.$notificationsPayload>
/**
 * Model cache
 * 
 */
export type cache = $Result.DefaultSelection<Prisma.$cachePayload>
/**
 * Model plugin
 * 
 */
export type plugin = $Result.DefaultSelection<Prisma.$pluginPayload>
/**
 * Model conversation
 * 
 */
export type conversation = $Result.DefaultSelection<Prisma.$conversationPayload>
/**
 * Model message
 * 
 */
export type message = $Result.DefaultSelection<Prisma.$messagePayload>
/**
 * Model noteHistory
 * 
 */
export type noteHistory = $Result.DefaultSelection<Prisma.$noteHistoryPayload>
/**
 * Model noteInternalShare
 * 
 */
export type noteInternalShare = $Result.DefaultSelection<Prisma.$noteInternalSharePayload>
/**
 * Model session
 * 
 */
export type session = $Result.DefaultSelection<Prisma.$sessionPayload>
/**
 * Model aiProviders
 * 
 */
export type aiProviders = $Result.DefaultSelection<Prisma.$aiProvidersPayload>
/**
 * Model aiModels
 * 
 */
export type aiModels = $Result.DefaultSelection<Prisma.$aiModelsPayload>
/**
 * Model aiScheduledTask
 * 
 */
export type aiScheduledTask = $Result.DefaultSelection<Prisma.$aiScheduledTaskPayload>
/**
 * Model mcpServers
 * 
 */
export type mcpServers = $Result.DefaultSelection<Prisma.$mcpServersPayload>
/**
 * Model fonts
 * 
 */
export type fonts = $Result.DefaultSelection<Prisma.$fontsPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.accounts.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.accounts.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Executes a typed SQL query and returns a typed result
   * @example
   * ```
   * import { myQuery } from '@prisma/client/sql'
   * 
   * const result = await prisma.$queryRawTyped(myQuery())
   * ```
   */
  $queryRawTyped<T>(typedSql: runtime.TypedSql<unknown[], T>): Prisma.PrismaPromise<T[]>

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.accounts`: Exposes CRUD operations for the **accounts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.accounts.findMany()
    * ```
    */
  get accounts(): Prisma.accountsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attachments`: Exposes CRUD operations for the **attachments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attachments
    * const attachments = await prisma.attachments.findMany()
    * ```
    */
  get attachments(): Prisma.attachmentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.config`: Exposes CRUD operations for the **config** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Configs
    * const configs = await prisma.config.findMany()
    * ```
    */
  get config(): Prisma.configDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notes`: Exposes CRUD operations for the **notes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notes
    * const notes = await prisma.notes.findMany()
    * ```
    */
  get notes(): Prisma.notesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comments`: Exposes CRUD operations for the **comments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comments.findMany()
    * ```
    */
  get comments(): Prisma.commentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.tagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tagsToNote`: Exposes CRUD operations for the **tagsToNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TagsToNotes
    * const tagsToNotes = await prisma.tagsToNote.findMany()
    * ```
    */
  get tagsToNote(): Prisma.tagsToNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.noteReference`: Exposes CRUD operations for the **noteReference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NoteReferences
    * const noteReferences = await prisma.noteReference.findMany()
    * ```
    */
  get noteReference(): Prisma.noteReferenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.follows`: Exposes CRUD operations for the **follows** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Follows
    * const follows = await prisma.follows.findMany()
    * ```
    */
  get follows(): Prisma.followsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.notificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cache`: Exposes CRUD operations for the **cache** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Caches
    * const caches = await prisma.cache.findMany()
    * ```
    */
  get cache(): Prisma.cacheDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plugin`: Exposes CRUD operations for the **plugin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plugins
    * const plugins = await prisma.plugin.findMany()
    * ```
    */
  get plugin(): Prisma.pluginDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.conversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.messageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.noteHistory`: Exposes CRUD operations for the **noteHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NoteHistories
    * const noteHistories = await prisma.noteHistory.findMany()
    * ```
    */
  get noteHistory(): Prisma.noteHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.noteInternalShare`: Exposes CRUD operations for the **noteInternalShare** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NoteInternalShares
    * const noteInternalShares = await prisma.noteInternalShare.findMany()
    * ```
    */
  get noteInternalShare(): Prisma.noteInternalShareDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.sessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiProviders`: Exposes CRUD operations for the **aiProviders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiProviders
    * const aiProviders = await prisma.aiProviders.findMany()
    * ```
    */
  get aiProviders(): Prisma.aiProvidersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiModels`: Exposes CRUD operations for the **aiModels** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiModels
    * const aiModels = await prisma.aiModels.findMany()
    * ```
    */
  get aiModels(): Prisma.aiModelsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiScheduledTask`: Exposes CRUD operations for the **aiScheduledTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiScheduledTasks
    * const aiScheduledTasks = await prisma.aiScheduledTask.findMany()
    * ```
    */
  get aiScheduledTask(): Prisma.aiScheduledTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mcpServers`: Exposes CRUD operations for the **mcpServers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more McpServers
    * const mcpServers = await prisma.mcpServers.findMany()
    * ```
    */
  get mcpServers(): Prisma.mcpServersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fonts`: Exposes CRUD operations for the **fonts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fonts
    * const fonts = await prisma.fonts.findMany()
    * ```
    */
  get fonts(): Prisma.fontsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.3.0
   * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    accounts: 'accounts',
    attachments: 'attachments',
    config: 'config',
    notes: 'notes',
    comments: 'comments',
    tag: 'tag',
    tagsToNote: 'tagsToNote',
    noteReference: 'noteReference',
    follows: 'follows',
    notifications: 'notifications',
    cache: 'cache',
    plugin: 'plugin',
    conversation: 'conversation',
    message: 'message',
    noteHistory: 'noteHistory',
    noteInternalShare: 'noteInternalShare',
    session: 'session',
    aiProviders: 'aiProviders',
    aiModels: 'aiModels',
    aiScheduledTask: 'aiScheduledTask',
    mcpServers: 'mcpServers',
    fonts: 'fonts'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "accounts" | "attachments" | "config" | "notes" | "comments" | "tag" | "tagsToNote" | "noteReference" | "follows" | "notifications" | "cache" | "plugin" | "conversation" | "message" | "noteHistory" | "noteInternalShare" | "session" | "aiProviders" | "aiModels" | "aiScheduledTask" | "mcpServers" | "fonts"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      accounts: {
        payload: Prisma.$accountsPayload<ExtArgs>
        fields: Prisma.accountsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.accountsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.accountsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          findFirst: {
            args: Prisma.accountsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.accountsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          findMany: {
            args: Prisma.accountsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>[]
          }
          create: {
            args: Prisma.accountsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          createMany: {
            args: Prisma.accountsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.accountsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>[]
          }
          delete: {
            args: Prisma.accountsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          update: {
            args: Prisma.accountsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          deleteMany: {
            args: Prisma.accountsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.accountsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.accountsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>[]
          }
          upsert: {
            args: Prisma.accountsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          aggregate: {
            args: Prisma.AccountsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccounts>
          }
          groupBy: {
            args: Prisma.accountsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountsGroupByOutputType>[]
          }
          count: {
            args: Prisma.accountsCountArgs<ExtArgs>
            result: $Utils.Optional<AccountsCountAggregateOutputType> | number
          }
        }
      }
      attachments: {
        payload: Prisma.$attachmentsPayload<ExtArgs>
        fields: Prisma.attachmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.attachmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attachmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.attachmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attachmentsPayload>
          }
          findFirst: {
            args: Prisma.attachmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attachmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.attachmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attachmentsPayload>
          }
          findMany: {
            args: Prisma.attachmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attachmentsPayload>[]
          }
          create: {
            args: Prisma.attachmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attachmentsPayload>
          }
          createMany: {
            args: Prisma.attachmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.attachmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attachmentsPayload>[]
          }
          delete: {
            args: Prisma.attachmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attachmentsPayload>
          }
          update: {
            args: Prisma.attachmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attachmentsPayload>
          }
          deleteMany: {
            args: Prisma.attachmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.attachmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.attachmentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attachmentsPayload>[]
          }
          upsert: {
            args: Prisma.attachmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attachmentsPayload>
          }
          aggregate: {
            args: Prisma.AttachmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttachments>
          }
          groupBy: {
            args: Prisma.attachmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttachmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.attachmentsCountArgs<ExtArgs>
            result: $Utils.Optional<AttachmentsCountAggregateOutputType> | number
          }
        }
      }
      config: {
        payload: Prisma.$configPayload<ExtArgs>
        fields: Prisma.configFieldRefs
        operations: {
          findUnique: {
            args: Prisma.configFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.configFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload>
          }
          findFirst: {
            args: Prisma.configFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.configFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload>
          }
          findMany: {
            args: Prisma.configFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload>[]
          }
          create: {
            args: Prisma.configCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload>
          }
          createMany: {
            args: Prisma.configCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.configCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload>[]
          }
          delete: {
            args: Prisma.configDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload>
          }
          update: {
            args: Prisma.configUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload>
          }
          deleteMany: {
            args: Prisma.configDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.configUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.configUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload>[]
          }
          upsert: {
            args: Prisma.configUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload>
          }
          aggregate: {
            args: Prisma.ConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfig>
          }
          groupBy: {
            args: Prisma.configGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.configCountArgs<ExtArgs>
            result: $Utils.Optional<ConfigCountAggregateOutputType> | number
          }
        }
      }
      notes: {
        payload: Prisma.$notesPayload<ExtArgs>
        fields: Prisma.notesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>
          }
          findFirst: {
            args: Prisma.notesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>
          }
          findMany: {
            args: Prisma.notesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>[]
          }
          create: {
            args: Prisma.notesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>
          }
          createMany: {
            args: Prisma.notesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>[]
          }
          delete: {
            args: Prisma.notesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>
          }
          update: {
            args: Prisma.notesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>
          }
          deleteMany: {
            args: Prisma.notesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.notesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>[]
          }
          upsert: {
            args: Prisma.notesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>
          }
          aggregate: {
            args: Prisma.NotesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotes>
          }
          groupBy: {
            args: Prisma.notesGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotesGroupByOutputType>[]
          }
          count: {
            args: Prisma.notesCountArgs<ExtArgs>
            result: $Utils.Optional<NotesCountAggregateOutputType> | number
          }
        }
      }
      comments: {
        payload: Prisma.$commentsPayload<ExtArgs>
        fields: Prisma.commentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.commentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.commentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          findFirst: {
            args: Prisma.commentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.commentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          findMany: {
            args: Prisma.commentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>[]
          }
          create: {
            args: Prisma.commentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          createMany: {
            args: Prisma.commentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.commentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>[]
          }
          delete: {
            args: Prisma.commentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          update: {
            args: Prisma.commentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          deleteMany: {
            args: Prisma.commentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.commentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.commentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>[]
          }
          upsert: {
            args: Prisma.commentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          aggregate: {
            args: Prisma.CommentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComments>
          }
          groupBy: {
            args: Prisma.commentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.commentsCountArgs<ExtArgs>
            result: $Utils.Optional<CommentsCountAggregateOutputType> | number
          }
        }
      }
      tag: {
        payload: Prisma.$tagPayload<ExtArgs>
        fields: Prisma.tagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload>
          }
          findFirst: {
            args: Prisma.tagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload>
          }
          findMany: {
            args: Prisma.tagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload>[]
          }
          create: {
            args: Prisma.tagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload>
          }
          createMany: {
            args: Prisma.tagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload>[]
          }
          delete: {
            args: Prisma.tagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload>
          }
          update: {
            args: Prisma.tagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload>
          }
          deleteMany: {
            args: Prisma.tagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload>[]
          }
          upsert: {
            args: Prisma.tagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.tagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.tagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      tagsToNote: {
        payload: Prisma.$tagsToNotePayload<ExtArgs>
        fields: Prisma.tagsToNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tagsToNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsToNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tagsToNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsToNotePayload>
          }
          findFirst: {
            args: Prisma.tagsToNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsToNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tagsToNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsToNotePayload>
          }
          findMany: {
            args: Prisma.tagsToNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsToNotePayload>[]
          }
          create: {
            args: Prisma.tagsToNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsToNotePayload>
          }
          createMany: {
            args: Prisma.tagsToNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tagsToNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsToNotePayload>[]
          }
          delete: {
            args: Prisma.tagsToNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsToNotePayload>
          }
          update: {
            args: Prisma.tagsToNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsToNotePayload>
          }
          deleteMany: {
            args: Prisma.tagsToNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tagsToNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tagsToNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsToNotePayload>[]
          }
          upsert: {
            args: Prisma.tagsToNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsToNotePayload>
          }
          aggregate: {
            args: Prisma.TagsToNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTagsToNote>
          }
          groupBy: {
            args: Prisma.tagsToNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagsToNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.tagsToNoteCountArgs<ExtArgs>
            result: $Utils.Optional<TagsToNoteCountAggregateOutputType> | number
          }
        }
      }
      noteReference: {
        payload: Prisma.$noteReferencePayload<ExtArgs>
        fields: Prisma.noteReferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.noteReferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteReferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.noteReferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteReferencePayload>
          }
          findFirst: {
            args: Prisma.noteReferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteReferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.noteReferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteReferencePayload>
          }
          findMany: {
            args: Prisma.noteReferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteReferencePayload>[]
          }
          create: {
            args: Prisma.noteReferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteReferencePayload>
          }
          createMany: {
            args: Prisma.noteReferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.noteReferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteReferencePayload>[]
          }
          delete: {
            args: Prisma.noteReferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteReferencePayload>
          }
          update: {
            args: Prisma.noteReferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteReferencePayload>
          }
          deleteMany: {
            args: Prisma.noteReferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.noteReferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.noteReferenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteReferencePayload>[]
          }
          upsert: {
            args: Prisma.noteReferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteReferencePayload>
          }
          aggregate: {
            args: Prisma.NoteReferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNoteReference>
          }
          groupBy: {
            args: Prisma.noteReferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoteReferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.noteReferenceCountArgs<ExtArgs>
            result: $Utils.Optional<NoteReferenceCountAggregateOutputType> | number
          }
        }
      }
      follows: {
        payload: Prisma.$followsPayload<ExtArgs>
        fields: Prisma.followsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.followsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.followsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followsPayload>
          }
          findFirst: {
            args: Prisma.followsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.followsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followsPayload>
          }
          findMany: {
            args: Prisma.followsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followsPayload>[]
          }
          create: {
            args: Prisma.followsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followsPayload>
          }
          createMany: {
            args: Prisma.followsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.followsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followsPayload>[]
          }
          delete: {
            args: Prisma.followsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followsPayload>
          }
          update: {
            args: Prisma.followsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followsPayload>
          }
          deleteMany: {
            args: Prisma.followsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.followsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.followsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followsPayload>[]
          }
          upsert: {
            args: Prisma.followsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followsPayload>
          }
          aggregate: {
            args: Prisma.FollowsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFollows>
          }
          groupBy: {
            args: Prisma.followsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FollowsGroupByOutputType>[]
          }
          count: {
            args: Prisma.followsCountArgs<ExtArgs>
            result: $Utils.Optional<FollowsCountAggregateOutputType> | number
          }
        }
      }
      notifications: {
        payload: Prisma.$notificationsPayload<ExtArgs>
        fields: Prisma.notificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findFirst: {
            args: Prisma.notificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findMany: {
            args: Prisma.notificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          create: {
            args: Prisma.notificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          createMany: {
            args: Prisma.notificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notificationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          delete: {
            args: Prisma.notificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          update: {
            args: Prisma.notificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          deleteMany: {
            args: Prisma.notificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.notificationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          upsert: {
            args: Prisma.notificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.notificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
      cache: {
        payload: Prisma.$cachePayload<ExtArgs>
        fields: Prisma.cacheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cacheFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cacheFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>
          }
          findFirst: {
            args: Prisma.cacheFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cacheFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>
          }
          findMany: {
            args: Prisma.cacheFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>[]
          }
          create: {
            args: Prisma.cacheCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>
          }
          createMany: {
            args: Prisma.cacheCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.cacheCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>[]
          }
          delete: {
            args: Prisma.cacheDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>
          }
          update: {
            args: Prisma.cacheUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>
          }
          deleteMany: {
            args: Prisma.cacheDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cacheUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.cacheUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>[]
          }
          upsert: {
            args: Prisma.cacheUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>
          }
          aggregate: {
            args: Prisma.CacheAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCache>
          }
          groupBy: {
            args: Prisma.cacheGroupByArgs<ExtArgs>
            result: $Utils.Optional<CacheGroupByOutputType>[]
          }
          count: {
            args: Prisma.cacheCountArgs<ExtArgs>
            result: $Utils.Optional<CacheCountAggregateOutputType> | number
          }
        }
      }
      plugin: {
        payload: Prisma.$pluginPayload<ExtArgs>
        fields: Prisma.pluginFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pluginFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pluginPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pluginFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pluginPayload>
          }
          findFirst: {
            args: Prisma.pluginFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pluginPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pluginFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pluginPayload>
          }
          findMany: {
            args: Prisma.pluginFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pluginPayload>[]
          }
          create: {
            args: Prisma.pluginCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pluginPayload>
          }
          createMany: {
            args: Prisma.pluginCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pluginCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pluginPayload>[]
          }
          delete: {
            args: Prisma.pluginDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pluginPayload>
          }
          update: {
            args: Prisma.pluginUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pluginPayload>
          }
          deleteMany: {
            args: Prisma.pluginDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pluginUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.pluginUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pluginPayload>[]
          }
          upsert: {
            args: Prisma.pluginUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pluginPayload>
          }
          aggregate: {
            args: Prisma.PluginAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlugin>
          }
          groupBy: {
            args: Prisma.pluginGroupByArgs<ExtArgs>
            result: $Utils.Optional<PluginGroupByOutputType>[]
          }
          count: {
            args: Prisma.pluginCountArgs<ExtArgs>
            result: $Utils.Optional<PluginCountAggregateOutputType> | number
          }
        }
      }
      conversation: {
        payload: Prisma.$conversationPayload<ExtArgs>
        fields: Prisma.conversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.conversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.conversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload>
          }
          findFirst: {
            args: Prisma.conversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.conversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload>
          }
          findMany: {
            args: Prisma.conversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload>[]
          }
          create: {
            args: Prisma.conversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload>
          }
          createMany: {
            args: Prisma.conversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.conversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload>[]
          }
          delete: {
            args: Prisma.conversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload>
          }
          update: {
            args: Prisma.conversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload>
          }
          deleteMany: {
            args: Prisma.conversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.conversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.conversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload>[]
          }
          upsert: {
            args: Prisma.conversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.conversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.conversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      message: {
        payload: Prisma.$messagePayload<ExtArgs>
        fields: Prisma.messageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.messageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.messageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          findFirst: {
            args: Prisma.messageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.messageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          findMany: {
            args: Prisma.messageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>[]
          }
          create: {
            args: Prisma.messageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          createMany: {
            args: Prisma.messageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.messageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>[]
          }
          delete: {
            args: Prisma.messageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          update: {
            args: Prisma.messageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          deleteMany: {
            args: Prisma.messageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.messageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.messageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>[]
          }
          upsert: {
            args: Prisma.messageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.messageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.messageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      noteHistory: {
        payload: Prisma.$noteHistoryPayload<ExtArgs>
        fields: Prisma.noteHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.noteHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.noteHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteHistoryPayload>
          }
          findFirst: {
            args: Prisma.noteHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.noteHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteHistoryPayload>
          }
          findMany: {
            args: Prisma.noteHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteHistoryPayload>[]
          }
          create: {
            args: Prisma.noteHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteHistoryPayload>
          }
          createMany: {
            args: Prisma.noteHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.noteHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteHistoryPayload>[]
          }
          delete: {
            args: Prisma.noteHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteHistoryPayload>
          }
          update: {
            args: Prisma.noteHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteHistoryPayload>
          }
          deleteMany: {
            args: Prisma.noteHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.noteHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.noteHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteHistoryPayload>[]
          }
          upsert: {
            args: Prisma.noteHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteHistoryPayload>
          }
          aggregate: {
            args: Prisma.NoteHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNoteHistory>
          }
          groupBy: {
            args: Prisma.noteHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoteHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.noteHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<NoteHistoryCountAggregateOutputType> | number
          }
        }
      }
      noteInternalShare: {
        payload: Prisma.$noteInternalSharePayload<ExtArgs>
        fields: Prisma.noteInternalShareFieldRefs
        operations: {
          findUnique: {
            args: Prisma.noteInternalShareFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteInternalSharePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.noteInternalShareFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteInternalSharePayload>
          }
          findFirst: {
            args: Prisma.noteInternalShareFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteInternalSharePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.noteInternalShareFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteInternalSharePayload>
          }
          findMany: {
            args: Prisma.noteInternalShareFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteInternalSharePayload>[]
          }
          create: {
            args: Prisma.noteInternalShareCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteInternalSharePayload>
          }
          createMany: {
            args: Prisma.noteInternalShareCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.noteInternalShareCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteInternalSharePayload>[]
          }
          delete: {
            args: Prisma.noteInternalShareDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteInternalSharePayload>
          }
          update: {
            args: Prisma.noteInternalShareUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteInternalSharePayload>
          }
          deleteMany: {
            args: Prisma.noteInternalShareDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.noteInternalShareUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.noteInternalShareUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteInternalSharePayload>[]
          }
          upsert: {
            args: Prisma.noteInternalShareUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noteInternalSharePayload>
          }
          aggregate: {
            args: Prisma.NoteInternalShareAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNoteInternalShare>
          }
          groupBy: {
            args: Prisma.noteInternalShareGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoteInternalShareGroupByOutputType>[]
          }
          count: {
            args: Prisma.noteInternalShareCountArgs<ExtArgs>
            result: $Utils.Optional<NoteInternalShareCountAggregateOutputType> | number
          }
        }
      }
      session: {
        payload: Prisma.$sessionPayload<ExtArgs>
        fields: Prisma.sessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          findFirst: {
            args: Prisma.sessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          findMany: {
            args: Prisma.sessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>[]
          }
          create: {
            args: Prisma.sessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          createMany: {
            args: Prisma.sessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.sessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>[]
          }
          delete: {
            args: Prisma.sessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          update: {
            args: Prisma.sessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          deleteMany: {
            args: Prisma.sessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.sessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>[]
          }
          upsert: {
            args: Prisma.sessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.sessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.sessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      aiProviders: {
        payload: Prisma.$aiProvidersPayload<ExtArgs>
        fields: Prisma.aiProvidersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.aiProvidersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiProvidersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.aiProvidersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiProvidersPayload>
          }
          findFirst: {
            args: Prisma.aiProvidersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiProvidersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.aiProvidersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiProvidersPayload>
          }
          findMany: {
            args: Prisma.aiProvidersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiProvidersPayload>[]
          }
          create: {
            args: Prisma.aiProvidersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiProvidersPayload>
          }
          createMany: {
            args: Prisma.aiProvidersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.aiProvidersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiProvidersPayload>[]
          }
          delete: {
            args: Prisma.aiProvidersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiProvidersPayload>
          }
          update: {
            args: Prisma.aiProvidersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiProvidersPayload>
          }
          deleteMany: {
            args: Prisma.aiProvidersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.aiProvidersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.aiProvidersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiProvidersPayload>[]
          }
          upsert: {
            args: Prisma.aiProvidersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiProvidersPayload>
          }
          aggregate: {
            args: Prisma.AiProvidersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiProviders>
          }
          groupBy: {
            args: Prisma.aiProvidersGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiProvidersGroupByOutputType>[]
          }
          count: {
            args: Prisma.aiProvidersCountArgs<ExtArgs>
            result: $Utils.Optional<AiProvidersCountAggregateOutputType> | number
          }
        }
      }
      aiModels: {
        payload: Prisma.$aiModelsPayload<ExtArgs>
        fields: Prisma.aiModelsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.aiModelsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiModelsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.aiModelsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiModelsPayload>
          }
          findFirst: {
            args: Prisma.aiModelsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiModelsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.aiModelsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiModelsPayload>
          }
          findMany: {
            args: Prisma.aiModelsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiModelsPayload>[]
          }
          create: {
            args: Prisma.aiModelsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiModelsPayload>
          }
          createMany: {
            args: Prisma.aiModelsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.aiModelsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiModelsPayload>[]
          }
          delete: {
            args: Prisma.aiModelsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiModelsPayload>
          }
          update: {
            args: Prisma.aiModelsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiModelsPayload>
          }
          deleteMany: {
            args: Prisma.aiModelsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.aiModelsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.aiModelsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiModelsPayload>[]
          }
          upsert: {
            args: Prisma.aiModelsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiModelsPayload>
          }
          aggregate: {
            args: Prisma.AiModelsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiModels>
          }
          groupBy: {
            args: Prisma.aiModelsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiModelsGroupByOutputType>[]
          }
          count: {
            args: Prisma.aiModelsCountArgs<ExtArgs>
            result: $Utils.Optional<AiModelsCountAggregateOutputType> | number
          }
        }
      }
      aiScheduledTask: {
        payload: Prisma.$aiScheduledTaskPayload<ExtArgs>
        fields: Prisma.aiScheduledTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.aiScheduledTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiScheduledTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.aiScheduledTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiScheduledTaskPayload>
          }
          findFirst: {
            args: Prisma.aiScheduledTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiScheduledTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.aiScheduledTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiScheduledTaskPayload>
          }
          findMany: {
            args: Prisma.aiScheduledTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiScheduledTaskPayload>[]
          }
          create: {
            args: Prisma.aiScheduledTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiScheduledTaskPayload>
          }
          createMany: {
            args: Prisma.aiScheduledTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.aiScheduledTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiScheduledTaskPayload>[]
          }
          delete: {
            args: Prisma.aiScheduledTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiScheduledTaskPayload>
          }
          update: {
            args: Prisma.aiScheduledTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiScheduledTaskPayload>
          }
          deleteMany: {
            args: Prisma.aiScheduledTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.aiScheduledTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.aiScheduledTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiScheduledTaskPayload>[]
          }
          upsert: {
            args: Prisma.aiScheduledTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aiScheduledTaskPayload>
          }
          aggregate: {
            args: Prisma.AiScheduledTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiScheduledTask>
          }
          groupBy: {
            args: Prisma.aiScheduledTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiScheduledTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.aiScheduledTaskCountArgs<ExtArgs>
            result: $Utils.Optional<AiScheduledTaskCountAggregateOutputType> | number
          }
        }
      }
      mcpServers: {
        payload: Prisma.$mcpServersPayload<ExtArgs>
        fields: Prisma.mcpServersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mcpServersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mcpServersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mcpServersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mcpServersPayload>
          }
          findFirst: {
            args: Prisma.mcpServersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mcpServersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mcpServersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mcpServersPayload>
          }
          findMany: {
            args: Prisma.mcpServersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mcpServersPayload>[]
          }
          create: {
            args: Prisma.mcpServersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mcpServersPayload>
          }
          createMany: {
            args: Prisma.mcpServersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.mcpServersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mcpServersPayload>[]
          }
          delete: {
            args: Prisma.mcpServersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mcpServersPayload>
          }
          update: {
            args: Prisma.mcpServersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mcpServersPayload>
          }
          deleteMany: {
            args: Prisma.mcpServersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mcpServersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.mcpServersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mcpServersPayload>[]
          }
          upsert: {
            args: Prisma.mcpServersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mcpServersPayload>
          }
          aggregate: {
            args: Prisma.McpServersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMcpServers>
          }
          groupBy: {
            args: Prisma.mcpServersGroupByArgs<ExtArgs>
            result: $Utils.Optional<McpServersGroupByOutputType>[]
          }
          count: {
            args: Prisma.mcpServersCountArgs<ExtArgs>
            result: $Utils.Optional<McpServersCountAggregateOutputType> | number
          }
        }
      }
      fonts: {
        payload: Prisma.$fontsPayload<ExtArgs>
        fields: Prisma.fontsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.fontsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fontsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.fontsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fontsPayload>
          }
          findFirst: {
            args: Prisma.fontsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fontsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.fontsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fontsPayload>
          }
          findMany: {
            args: Prisma.fontsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fontsPayload>[]
          }
          create: {
            args: Prisma.fontsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fontsPayload>
          }
          createMany: {
            args: Prisma.fontsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.fontsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fontsPayload>[]
          }
          delete: {
            args: Prisma.fontsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fontsPayload>
          }
          update: {
            args: Prisma.fontsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fontsPayload>
          }
          deleteMany: {
            args: Prisma.fontsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.fontsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.fontsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fontsPayload>[]
          }
          upsert: {
            args: Prisma.fontsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fontsPayload>
          }
          aggregate: {
            args: Prisma.FontsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFonts>
          }
          groupBy: {
            args: Prisma.fontsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FontsGroupByOutputType>[]
          }
          count: {
            args: Prisma.fontsCountArgs<ExtArgs>
            result: $Utils.Optional<FontsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRawTyped: {
          args: runtime.UnknownTypedSql,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    accounts?: accountsOmit
    attachments?: attachmentsOmit
    config?: configOmit
    notes?: notesOmit
    comments?: commentsOmit
    tag?: tagOmit
    tagsToNote?: tagsToNoteOmit
    noteReference?: noteReferenceOmit
    follows?: followsOmit
    notifications?: notificationsOmit
    cache?: cacheOmit
    plugin?: pluginOmit
    conversation?: conversationOmit
    message?: messageOmit
    noteHistory?: noteHistoryOmit
    noteInternalShare?: noteInternalShareOmit
    session?: sessionOmit
    aiProviders?: aiProvidersOmit
    aiModels?: aiModelsOmit
    aiScheduledTask?: aiScheduledTaskOmit
    mcpServers?: mcpServersOmit
    fonts?: fontsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AccountsCountOutputType
   */

  export type AccountsCountOutputType = {
    notes: number
    configs: number
    tags: number
    comments: number
    attachments: number
    follows: number
    notifications: number
    conversations: number
    sharedNotes: number
    aiScheduledTasks: number
  }

  export type AccountsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notes?: boolean | AccountsCountOutputTypeCountNotesArgs
    configs?: boolean | AccountsCountOutputTypeCountConfigsArgs
    tags?: boolean | AccountsCountOutputTypeCountTagsArgs
    comments?: boolean | AccountsCountOutputTypeCountCommentsArgs
    attachments?: boolean | AccountsCountOutputTypeCountAttachmentsArgs
    follows?: boolean | AccountsCountOutputTypeCountFollowsArgs
    notifications?: boolean | AccountsCountOutputTypeCountNotificationsArgs
    conversations?: boolean | AccountsCountOutputTypeCountConversationsArgs
    sharedNotes?: boolean | AccountsCountOutputTypeCountSharedNotesArgs
    aiScheduledTasks?: boolean | AccountsCountOutputTypeCountAiScheduledTasksArgs
  }

  // Custom InputTypes
  /**
   * AccountsCountOutputType without action
   */
  export type AccountsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountsCountOutputType
     */
    select?: AccountsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountsCountOutputType without action
   */
  export type AccountsCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notesWhereInput
  }

  /**
   * AccountsCountOutputType without action
   */
  export type AccountsCountOutputTypeCountConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: configWhereInput
  }

  /**
   * AccountsCountOutputType without action
   */
  export type AccountsCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tagWhereInput
  }

  /**
   * AccountsCountOutputType without action
   */
  export type AccountsCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentsWhereInput
  }

  /**
   * AccountsCountOutputType without action
   */
  export type AccountsCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attachmentsWhereInput
  }

  /**
   * AccountsCountOutputType without action
   */
  export type AccountsCountOutputTypeCountFollowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: followsWhereInput
  }

  /**
   * AccountsCountOutputType without action
   */
  export type AccountsCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
  }

  /**
   * AccountsCountOutputType without action
   */
  export type AccountsCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conversationWhereInput
  }

  /**
   * AccountsCountOutputType without action
   */
  export type AccountsCountOutputTypeCountSharedNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: noteInternalShareWhereInput
  }

  /**
   * AccountsCountOutputType without action
   */
  export type AccountsCountOutputTypeCountAiScheduledTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: aiScheduledTaskWhereInput
  }


  /**
   * Count Type NotesCountOutputType
   */

  export type NotesCountOutputType = {
    attachments: number
    tags: number
    referencedBy: number
    references: number
    comments: number
    histories: number
    internalShares: number
  }

  export type NotesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | NotesCountOutputTypeCountAttachmentsArgs
    tags?: boolean | NotesCountOutputTypeCountTagsArgs
    referencedBy?: boolean | NotesCountOutputTypeCountReferencedByArgs
    references?: boolean | NotesCountOutputTypeCountReferencesArgs
    comments?: boolean | NotesCountOutputTypeCountCommentsArgs
    histories?: boolean | NotesCountOutputTypeCountHistoriesArgs
    internalShares?: boolean | NotesCountOutputTypeCountInternalSharesArgs
  }

  // Custom InputTypes
  /**
   * NotesCountOutputType without action
   */
  export type NotesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotesCountOutputType
     */
    select?: NotesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NotesCountOutputType without action
   */
  export type NotesCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attachmentsWhereInput
  }

  /**
   * NotesCountOutputType without action
   */
  export type NotesCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tagsToNoteWhereInput
  }

  /**
   * NotesCountOutputType without action
   */
  export type NotesCountOutputTypeCountReferencedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: noteReferenceWhereInput
  }

  /**
   * NotesCountOutputType without action
   */
  export type NotesCountOutputTypeCountReferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: noteReferenceWhereInput
  }

  /**
   * NotesCountOutputType without action
   */
  export type NotesCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentsWhereInput
  }

  /**
   * NotesCountOutputType without action
   */
  export type NotesCountOutputTypeCountHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: noteHistoryWhereInput
  }

  /**
   * NotesCountOutputType without action
   */
  export type NotesCountOutputTypeCountInternalSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: noteInternalShareWhereInput
  }


  /**
   * Count Type CommentsCountOutputType
   */

  export type CommentsCountOutputType = {
    replies: number
  }

  export type CommentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | CommentsCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * CommentsCountOutputType without action
   */
  export type CommentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentsCountOutputType
     */
    select?: CommentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentsCountOutputType without action
   */
  export type CommentsCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentsWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    tagsToNote: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tagsToNote?: boolean | TagCountOutputTypeCountTagsToNoteArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountTagsToNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tagsToNoteWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    messages: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messageWhereInput
  }


  /**
   * Count Type AiProvidersCountOutputType
   */

  export type AiProvidersCountOutputType = {
    models: number
  }

  export type AiProvidersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    models?: boolean | AiProvidersCountOutputTypeCountModelsArgs
  }

  // Custom InputTypes
  /**
   * AiProvidersCountOutputType without action
   */
  export type AiProvidersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiProvidersCountOutputType
     */
    select?: AiProvidersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AiProvidersCountOutputType without action
   */
  export type AiProvidersCountOutputTypeCountModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: aiModelsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model accounts
   */

  export type AggregateAccounts = {
    _count: AccountsCountAggregateOutputType | null
    _avg: AccountsAvgAggregateOutputType | null
    _sum: AccountsSumAggregateOutputType | null
    _min: AccountsMinAggregateOutputType | null
    _max: AccountsMaxAggregateOutputType | null
  }

  export type AccountsAvgAggregateOutputType = {
    id: number | null
    note: number | null
    linkAccountId: number | null
  }

  export type AccountsSumAggregateOutputType = {
    id: number | null
    note: number | null
    linkAccountId: number | null
  }

  export type AccountsMinAggregateOutputType = {
    id: number | null
    name: string | null
    nickname: string | null
    password: string | null
    image: string | null
    apiToken: string | null
    description: string | null
    note: number | null
    role: string | null
    loginType: string | null
    linkAccountId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    nickname: string | null
    password: string | null
    image: string | null
    apiToken: string | null
    description: string | null
    note: number | null
    role: string | null
    loginType: string | null
    linkAccountId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountsCountAggregateOutputType = {
    id: number
    name: number
    nickname: number
    password: number
    image: number
    apiToken: number
    description: number
    note: number
    role: number
    loginType: number
    linkAccountId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountsAvgAggregateInputType = {
    id?: true
    note?: true
    linkAccountId?: true
  }

  export type AccountsSumAggregateInputType = {
    id?: true
    note?: true
    linkAccountId?: true
  }

  export type AccountsMinAggregateInputType = {
    id?: true
    name?: true
    nickname?: true
    password?: true
    image?: true
    apiToken?: true
    description?: true
    note?: true
    role?: true
    loginType?: true
    linkAccountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountsMaxAggregateInputType = {
    id?: true
    name?: true
    nickname?: true
    password?: true
    image?: true
    apiToken?: true
    description?: true
    note?: true
    role?: true
    loginType?: true
    linkAccountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountsCountAggregateInputType = {
    id?: true
    name?: true
    nickname?: true
    password?: true
    image?: true
    apiToken?: true
    description?: true
    note?: true
    role?: true
    loginType?: true
    linkAccountId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accounts to aggregate.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned accounts
    **/
    _count?: true | AccountsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountsMaxAggregateInputType
  }

  export type GetAccountsAggregateType<T extends AccountsAggregateArgs> = {
        [P in keyof T & keyof AggregateAccounts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccounts[P]>
      : GetScalarType<T[P], AggregateAccounts[P]>
  }




  export type accountsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accountsWhereInput
    orderBy?: accountsOrderByWithAggregationInput | accountsOrderByWithAggregationInput[]
    by: AccountsScalarFieldEnum[] | AccountsScalarFieldEnum
    having?: accountsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountsCountAggregateInputType | true
    _avg?: AccountsAvgAggregateInputType
    _sum?: AccountsSumAggregateInputType
    _min?: AccountsMinAggregateInputType
    _max?: AccountsMaxAggregateInputType
  }

  export type AccountsGroupByOutputType = {
    id: number
    name: string
    nickname: string
    password: string
    image: string
    apiToken: string
    description: string
    note: number
    role: string
    loginType: string
    linkAccountId: number | null
    createdAt: Date
    updatedAt: Date
    _count: AccountsCountAggregateOutputType | null
    _avg: AccountsAvgAggregateOutputType | null
    _sum: AccountsSumAggregateOutputType | null
    _min: AccountsMinAggregateOutputType | null
    _max: AccountsMaxAggregateOutputType | null
  }

  type GetAccountsGroupByPayload<T extends accountsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountsGroupByOutputType[P]>
            : GetScalarType<T[P], AccountsGroupByOutputType[P]>
        }
      >
    >


  export type accountsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nickname?: boolean
    password?: boolean
    image?: boolean
    apiToken?: boolean
    description?: boolean
    note?: boolean
    role?: boolean
    loginType?: boolean
    linkAccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notes?: boolean | accounts$notesArgs<ExtArgs>
    configs?: boolean | accounts$configsArgs<ExtArgs>
    tags?: boolean | accounts$tagsArgs<ExtArgs>
    comments?: boolean | accounts$commentsArgs<ExtArgs>
    attachments?: boolean | accounts$attachmentsArgs<ExtArgs>
    follows?: boolean | accounts$followsArgs<ExtArgs>
    notifications?: boolean | accounts$notificationsArgs<ExtArgs>
    conversations?: boolean | accounts$conversationsArgs<ExtArgs>
    sharedNotes?: boolean | accounts$sharedNotesArgs<ExtArgs>
    aiScheduledTasks?: boolean | accounts$aiScheduledTasksArgs<ExtArgs>
    _count?: boolean | AccountsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accounts"]>

  export type accountsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nickname?: boolean
    password?: boolean
    image?: boolean
    apiToken?: boolean
    description?: boolean
    note?: boolean
    role?: boolean
    loginType?: boolean
    linkAccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["accounts"]>

  export type accountsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nickname?: boolean
    password?: boolean
    image?: boolean
    apiToken?: boolean
    description?: boolean
    note?: boolean
    role?: boolean
    loginType?: boolean
    linkAccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["accounts"]>

  export type accountsSelectScalar = {
    id?: boolean
    name?: boolean
    nickname?: boolean
    password?: boolean
    image?: boolean
    apiToken?: boolean
    description?: boolean
    note?: boolean
    role?: boolean
    loginType?: boolean
    linkAccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type accountsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "nickname" | "password" | "image" | "apiToken" | "description" | "note" | "role" | "loginType" | "linkAccountId" | "createdAt" | "updatedAt", ExtArgs["result"]["accounts"]>
  export type accountsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notes?: boolean | accounts$notesArgs<ExtArgs>
    configs?: boolean | accounts$configsArgs<ExtArgs>
    tags?: boolean | accounts$tagsArgs<ExtArgs>
    comments?: boolean | accounts$commentsArgs<ExtArgs>
    attachments?: boolean | accounts$attachmentsArgs<ExtArgs>
    follows?: boolean | accounts$followsArgs<ExtArgs>
    notifications?: boolean | accounts$notificationsArgs<ExtArgs>
    conversations?: boolean | accounts$conversationsArgs<ExtArgs>
    sharedNotes?: boolean | accounts$sharedNotesArgs<ExtArgs>
    aiScheduledTasks?: boolean | accounts$aiScheduledTasksArgs<ExtArgs>
    _count?: boolean | AccountsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type accountsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type accountsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $accountsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "accounts"
    objects: {
      notes: Prisma.$notesPayload<ExtArgs>[]
      configs: Prisma.$configPayload<ExtArgs>[]
      tags: Prisma.$tagPayload<ExtArgs>[]
      comments: Prisma.$commentsPayload<ExtArgs>[]
      attachments: Prisma.$attachmentsPayload<ExtArgs>[]
      follows: Prisma.$followsPayload<ExtArgs>[]
      notifications: Prisma.$notificationsPayload<ExtArgs>[]
      conversations: Prisma.$conversationPayload<ExtArgs>[]
      sharedNotes: Prisma.$noteInternalSharePayload<ExtArgs>[]
      aiScheduledTasks: Prisma.$aiScheduledTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      nickname: string
      password: string
      image: string
      apiToken: string
      description: string
      note: number
      role: string
      loginType: string
      linkAccountId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["accounts"]>
    composites: {}
  }

  type accountsGetPayload<S extends boolean | null | undefined | accountsDefaultArgs> = $Result.GetResult<Prisma.$accountsPayload, S>

  type accountsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<accountsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountsCountAggregateInputType | true
    }

  export interface accountsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['accounts'], meta: { name: 'accounts' } }
    /**
     * Find zero or one Accounts that matches the filter.
     * @param {accountsFindUniqueArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends accountsFindUniqueArgs>(args: SelectSubset<T, accountsFindUniqueArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Accounts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {accountsFindUniqueOrThrowArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends accountsFindUniqueOrThrowArgs>(args: SelectSubset<T, accountsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsFindFirstArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends accountsFindFirstArgs>(args?: SelectSubset<T, accountsFindFirstArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Accounts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsFindFirstOrThrowArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends accountsFindFirstOrThrowArgs>(args?: SelectSubset<T, accountsFindFirstOrThrowArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.accounts.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.accounts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountsWithIdOnly = await prisma.accounts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends accountsFindManyArgs>(args?: SelectSubset<T, accountsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Accounts.
     * @param {accountsCreateArgs} args - Arguments to create a Accounts.
     * @example
     * // Create one Accounts
     * const Accounts = await prisma.accounts.create({
     *   data: {
     *     // ... data to create a Accounts
     *   }
     * })
     * 
     */
    create<T extends accountsCreateArgs>(args: SelectSubset<T, accountsCreateArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {accountsCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const accounts = await prisma.accounts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends accountsCreateManyArgs>(args?: SelectSubset<T, accountsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {accountsCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const accounts = await prisma.accounts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountsWithIdOnly = await prisma.accounts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends accountsCreateManyAndReturnArgs>(args?: SelectSubset<T, accountsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Accounts.
     * @param {accountsDeleteArgs} args - Arguments to delete one Accounts.
     * @example
     * // Delete one Accounts
     * const Accounts = await prisma.accounts.delete({
     *   where: {
     *     // ... filter to delete one Accounts
     *   }
     * })
     * 
     */
    delete<T extends accountsDeleteArgs>(args: SelectSubset<T, accountsDeleteArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Accounts.
     * @param {accountsUpdateArgs} args - Arguments to update one Accounts.
     * @example
     * // Update one Accounts
     * const accounts = await prisma.accounts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends accountsUpdateArgs>(args: SelectSubset<T, accountsUpdateArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {accountsDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.accounts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends accountsDeleteManyArgs>(args?: SelectSubset<T, accountsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const accounts = await prisma.accounts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends accountsUpdateManyArgs>(args: SelectSubset<T, accountsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {accountsUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const accounts = await prisma.accounts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountsWithIdOnly = await prisma.accounts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends accountsUpdateManyAndReturnArgs>(args: SelectSubset<T, accountsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Accounts.
     * @param {accountsUpsertArgs} args - Arguments to update or create a Accounts.
     * @example
     * // Update or create a Accounts
     * const accounts = await prisma.accounts.upsert({
     *   create: {
     *     // ... data to create a Accounts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Accounts we want to update
     *   }
     * })
     */
    upsert<T extends accountsUpsertArgs>(args: SelectSubset<T, accountsUpsertArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.accounts.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends accountsCountArgs>(
      args?: Subset<T, accountsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountsAggregateArgs>(args: Subset<T, AccountsAggregateArgs>): Prisma.PrismaPromise<GetAccountsAggregateType<T>>

    /**
     * Group by Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends accountsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: accountsGroupByArgs['orderBy'] }
        : { orderBy?: accountsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, accountsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the accounts model
   */
  readonly fields: accountsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for accounts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__accountsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notes<T extends accounts$notesArgs<ExtArgs> = {}>(args?: Subset<T, accounts$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    configs<T extends accounts$configsArgs<ExtArgs> = {}>(args?: Subset<T, accounts$configsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends accounts$tagsArgs<ExtArgs> = {}>(args?: Subset<T, accounts$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends accounts$commentsArgs<ExtArgs> = {}>(args?: Subset<T, accounts$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attachments<T extends accounts$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, accounts$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attachmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    follows<T extends accounts$followsArgs<ExtArgs> = {}>(args?: Subset<T, accounts$followsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$followsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends accounts$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, accounts$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversations<T extends accounts$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, accounts$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sharedNotes<T extends accounts$sharedNotesArgs<ExtArgs> = {}>(args?: Subset<T, accounts$sharedNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$noteInternalSharePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiScheduledTasks<T extends accounts$aiScheduledTasksArgs<ExtArgs> = {}>(args?: Subset<T, accounts$aiScheduledTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aiScheduledTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the accounts model
   */
  interface accountsFieldRefs {
    readonly id: FieldRef<"accounts", 'Int'>
    readonly name: FieldRef<"accounts", 'String'>
    readonly nickname: FieldRef<"accounts", 'String'>
    readonly password: FieldRef<"accounts", 'String'>
    readonly image: FieldRef<"accounts", 'String'>
    readonly apiToken: FieldRef<"accounts", 'String'>
    readonly description: FieldRef<"accounts", 'String'>
    readonly note: FieldRef<"accounts", 'Int'>
    readonly role: FieldRef<"accounts", 'String'>
    readonly loginType: FieldRef<"accounts", 'String'>
    readonly linkAccountId: FieldRef<"accounts", 'Int'>
    readonly createdAt: FieldRef<"accounts", 'DateTime'>
    readonly updatedAt: FieldRef<"accounts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * accounts findUnique
   */
  export type accountsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts findUniqueOrThrow
   */
  export type accountsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts findFirst
   */
  export type accountsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accounts.
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accounts.
     */
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * accounts findFirstOrThrow
   */
  export type accountsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accounts.
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accounts.
     */
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * accounts findMany
   */
  export type accountsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing accounts.
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * accounts create
   */
  export type accountsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * The data needed to create a accounts.
     */
    data: XOR<accountsCreateInput, accountsUncheckedCreateInput>
  }

  /**
   * accounts createMany
   */
  export type accountsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many accounts.
     */
    data: accountsCreateManyInput | accountsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * accounts createManyAndReturn
   */
  export type accountsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * The data used to create many accounts.
     */
    data: accountsCreateManyInput | accountsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * accounts update
   */
  export type accountsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * The data needed to update a accounts.
     */
    data: XOR<accountsUpdateInput, accountsUncheckedUpdateInput>
    /**
     * Choose, which accounts to update.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts updateMany
   */
  export type accountsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update accounts.
     */
    data: XOR<accountsUpdateManyMutationInput, accountsUncheckedUpdateManyInput>
    /**
     * Filter which accounts to update
     */
    where?: accountsWhereInput
    /**
     * Limit how many accounts to update.
     */
    limit?: number
  }

  /**
   * accounts updateManyAndReturn
   */
  export type accountsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * The data used to update accounts.
     */
    data: XOR<accountsUpdateManyMutationInput, accountsUncheckedUpdateManyInput>
    /**
     * Filter which accounts to update
     */
    where?: accountsWhereInput
    /**
     * Limit how many accounts to update.
     */
    limit?: number
  }

  /**
   * accounts upsert
   */
  export type accountsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * The filter to search for the accounts to update in case it exists.
     */
    where: accountsWhereUniqueInput
    /**
     * In case the accounts found by the `where` argument doesn't exist, create a new accounts with this data.
     */
    create: XOR<accountsCreateInput, accountsUncheckedCreateInput>
    /**
     * In case the accounts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<accountsUpdateInput, accountsUncheckedUpdateInput>
  }

  /**
   * accounts delete
   */
  export type accountsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter which accounts to delete.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts deleteMany
   */
  export type accountsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accounts to delete
     */
    where?: accountsWhereInput
    /**
     * Limit how many accounts to delete.
     */
    limit?: number
  }

  /**
   * accounts.notes
   */
  export type accounts$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notesInclude<ExtArgs> | null
    where?: notesWhereInput
    orderBy?: notesOrderByWithRelationInput | notesOrderByWithRelationInput[]
    cursor?: notesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * accounts.configs
   */
  export type accounts$configsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the config
     */
    omit?: configOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: configInclude<ExtArgs> | null
    where?: configWhereInput
    orderBy?: configOrderByWithRelationInput | configOrderByWithRelationInput[]
    cursor?: configWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConfigScalarFieldEnum | ConfigScalarFieldEnum[]
  }

  /**
   * accounts.tags
   */
  export type accounts$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tag
     */
    omit?: tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    where?: tagWhereInput
    orderBy?: tagOrderByWithRelationInput | tagOrderByWithRelationInput[]
    cursor?: tagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * accounts.comments
   */
  export type accounts$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    where?: commentsWhereInput
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    cursor?: commentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * accounts.attachments
   */
  export type accounts$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachments
     */
    select?: attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attachments
     */
    omit?: attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attachmentsInclude<ExtArgs> | null
    where?: attachmentsWhereInput
    orderBy?: attachmentsOrderByWithRelationInput | attachmentsOrderByWithRelationInput[]
    cursor?: attachmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentsScalarFieldEnum | AttachmentsScalarFieldEnum[]
  }

  /**
   * accounts.follows
   */
  export type accounts$followsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follows
     */
    select?: followsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the follows
     */
    omit?: followsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followsInclude<ExtArgs> | null
    where?: followsWhereInput
    orderBy?: followsOrderByWithRelationInput | followsOrderByWithRelationInput[]
    cursor?: followsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowsScalarFieldEnum | FollowsScalarFieldEnum[]
  }

  /**
   * accounts.notifications
   */
  export type accounts$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    cursor?: notificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * accounts.conversations
   */
  export type accounts$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    where?: conversationWhereInput
    orderBy?: conversationOrderByWithRelationInput | conversationOrderByWithRelationInput[]
    cursor?: conversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * accounts.sharedNotes
   */
  export type accounts$sharedNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteInternalShare
     */
    select?: noteInternalShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteInternalShare
     */
    omit?: noteInternalShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteInternalShareInclude<ExtArgs> | null
    where?: noteInternalShareWhereInput
    orderBy?: noteInternalShareOrderByWithRelationInput | noteInternalShareOrderByWithRelationInput[]
    cursor?: noteInternalShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteInternalShareScalarFieldEnum | NoteInternalShareScalarFieldEnum[]
  }

  /**
   * accounts.aiScheduledTasks
   */
  export type accounts$aiScheduledTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiScheduledTask
     */
    select?: aiScheduledTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiScheduledTask
     */
    omit?: aiScheduledTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiScheduledTaskInclude<ExtArgs> | null
    where?: aiScheduledTaskWhereInput
    orderBy?: aiScheduledTaskOrderByWithRelationInput | aiScheduledTaskOrderByWithRelationInput[]
    cursor?: aiScheduledTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiScheduledTaskScalarFieldEnum | AiScheduledTaskScalarFieldEnum[]
  }

  /**
   * accounts without action
   */
  export type accountsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
  }


  /**
   * Model attachments
   */

  export type AggregateAttachments = {
    _count: AttachmentsCountAggregateOutputType | null
    _avg: AttachmentsAvgAggregateOutputType | null
    _sum: AttachmentsSumAggregateOutputType | null
    _min: AttachmentsMinAggregateOutputType | null
    _max: AttachmentsMaxAggregateOutputType | null
  }

  export type AttachmentsAvgAggregateOutputType = {
    id: number | null
    size: Decimal | null
    noteId: number | null
    accountId: number | null
    sortOrder: number | null
    depth: number | null
  }

  export type AttachmentsSumAggregateOutputType = {
    id: number | null
    size: Decimal | null
    noteId: number | null
    accountId: number | null
    sortOrder: number | null
    depth: number | null
  }

  export type AttachmentsMinAggregateOutputType = {
    id: number | null
    isShare: boolean | null
    sharePassword: string | null
    name: string | null
    path: string | null
    size: Decimal | null
    type: string | null
    noteId: number | null
    accountId: number | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
    perfixPath: string | null
    depth: number | null
  }

  export type AttachmentsMaxAggregateOutputType = {
    id: number | null
    isShare: boolean | null
    sharePassword: string | null
    name: string | null
    path: string | null
    size: Decimal | null
    type: string | null
    noteId: number | null
    accountId: number | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
    perfixPath: string | null
    depth: number | null
  }

  export type AttachmentsCountAggregateOutputType = {
    id: number
    isShare: number
    sharePassword: number
    name: number
    path: number
    size: number
    type: number
    noteId: number
    accountId: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    perfixPath: number
    depth: number
    metadata: number
    _all: number
  }


  export type AttachmentsAvgAggregateInputType = {
    id?: true
    size?: true
    noteId?: true
    accountId?: true
    sortOrder?: true
    depth?: true
  }

  export type AttachmentsSumAggregateInputType = {
    id?: true
    size?: true
    noteId?: true
    accountId?: true
    sortOrder?: true
    depth?: true
  }

  export type AttachmentsMinAggregateInputType = {
    id?: true
    isShare?: true
    sharePassword?: true
    name?: true
    path?: true
    size?: true
    type?: true
    noteId?: true
    accountId?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    perfixPath?: true
    depth?: true
  }

  export type AttachmentsMaxAggregateInputType = {
    id?: true
    isShare?: true
    sharePassword?: true
    name?: true
    path?: true
    size?: true
    type?: true
    noteId?: true
    accountId?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    perfixPath?: true
    depth?: true
  }

  export type AttachmentsCountAggregateInputType = {
    id?: true
    isShare?: true
    sharePassword?: true
    name?: true
    path?: true
    size?: true
    type?: true
    noteId?: true
    accountId?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    perfixPath?: true
    depth?: true
    metadata?: true
    _all?: true
  }

  export type AttachmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attachments to aggregate.
     */
    where?: attachmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attachments to fetch.
     */
    orderBy?: attachmentsOrderByWithRelationInput | attachmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: attachmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned attachments
    **/
    _count?: true | AttachmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttachmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttachmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttachmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttachmentsMaxAggregateInputType
  }

  export type GetAttachmentsAggregateType<T extends AttachmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateAttachments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttachments[P]>
      : GetScalarType<T[P], AggregateAttachments[P]>
  }




  export type attachmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attachmentsWhereInput
    orderBy?: attachmentsOrderByWithAggregationInput | attachmentsOrderByWithAggregationInput[]
    by: AttachmentsScalarFieldEnum[] | AttachmentsScalarFieldEnum
    having?: attachmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttachmentsCountAggregateInputType | true
    _avg?: AttachmentsAvgAggregateInputType
    _sum?: AttachmentsSumAggregateInputType
    _min?: AttachmentsMinAggregateInputType
    _max?: AttachmentsMaxAggregateInputType
  }

  export type AttachmentsGroupByOutputType = {
    id: number
    isShare: boolean
    sharePassword: string
    name: string
    path: string
    size: Decimal
    type: string
    noteId: number | null
    accountId: number | null
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    perfixPath: string | null
    depth: number | null
    metadata: JsonValue | null
    _count: AttachmentsCountAggregateOutputType | null
    _avg: AttachmentsAvgAggregateOutputType | null
    _sum: AttachmentsSumAggregateOutputType | null
    _min: AttachmentsMinAggregateOutputType | null
    _max: AttachmentsMaxAggregateOutputType | null
  }

  type GetAttachmentsGroupByPayload<T extends attachmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttachmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttachmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttachmentsGroupByOutputType[P]>
            : GetScalarType<T[P], AttachmentsGroupByOutputType[P]>
        }
      >
    >


  export type attachmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isShare?: boolean
    sharePassword?: boolean
    name?: boolean
    path?: boolean
    size?: boolean
    type?: boolean
    noteId?: boolean
    accountId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    perfixPath?: boolean
    depth?: boolean
    metadata?: boolean
    note?: boolean | attachments$noteArgs<ExtArgs>
    account?: boolean | attachments$accountArgs<ExtArgs>
  }, ExtArgs["result"]["attachments"]>

  export type attachmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isShare?: boolean
    sharePassword?: boolean
    name?: boolean
    path?: boolean
    size?: boolean
    type?: boolean
    noteId?: boolean
    accountId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    perfixPath?: boolean
    depth?: boolean
    metadata?: boolean
    note?: boolean | attachments$noteArgs<ExtArgs>
    account?: boolean | attachments$accountArgs<ExtArgs>
  }, ExtArgs["result"]["attachments"]>

  export type attachmentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isShare?: boolean
    sharePassword?: boolean
    name?: boolean
    path?: boolean
    size?: boolean
    type?: boolean
    noteId?: boolean
    accountId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    perfixPath?: boolean
    depth?: boolean
    metadata?: boolean
    note?: boolean | attachments$noteArgs<ExtArgs>
    account?: boolean | attachments$accountArgs<ExtArgs>
  }, ExtArgs["result"]["attachments"]>

  export type attachmentsSelectScalar = {
    id?: boolean
    isShare?: boolean
    sharePassword?: boolean
    name?: boolean
    path?: boolean
    size?: boolean
    type?: boolean
    noteId?: boolean
    accountId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    perfixPath?: boolean
    depth?: boolean
    metadata?: boolean
  }

  export type attachmentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isShare" | "sharePassword" | "name" | "path" | "size" | "type" | "noteId" | "accountId" | "sortOrder" | "createdAt" | "updatedAt" | "perfixPath" | "depth" | "metadata", ExtArgs["result"]["attachments"]>
  export type attachmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note?: boolean | attachments$noteArgs<ExtArgs>
    account?: boolean | attachments$accountArgs<ExtArgs>
  }
  export type attachmentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note?: boolean | attachments$noteArgs<ExtArgs>
    account?: boolean | attachments$accountArgs<ExtArgs>
  }
  export type attachmentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note?: boolean | attachments$noteArgs<ExtArgs>
    account?: boolean | attachments$accountArgs<ExtArgs>
  }

  export type $attachmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "attachments"
    objects: {
      note: Prisma.$notesPayload<ExtArgs> | null
      account: Prisma.$accountsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      isShare: boolean
      sharePassword: string
      name: string
      path: string
      size: Prisma.Decimal
      type: string
      noteId: number | null
      accountId: number | null
      sortOrder: number
      createdAt: Date
      updatedAt: Date
      perfixPath: string | null
      depth: number | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["attachments"]>
    composites: {}
  }

  type attachmentsGetPayload<S extends boolean | null | undefined | attachmentsDefaultArgs> = $Result.GetResult<Prisma.$attachmentsPayload, S>

  type attachmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<attachmentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttachmentsCountAggregateInputType | true
    }

  export interface attachmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['attachments'], meta: { name: 'attachments' } }
    /**
     * Find zero or one Attachments that matches the filter.
     * @param {attachmentsFindUniqueArgs} args - Arguments to find a Attachments
     * @example
     * // Get one Attachments
     * const attachments = await prisma.attachments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends attachmentsFindUniqueArgs>(args: SelectSubset<T, attachmentsFindUniqueArgs<ExtArgs>>): Prisma__attachmentsClient<$Result.GetResult<Prisma.$attachmentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attachments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {attachmentsFindUniqueOrThrowArgs} args - Arguments to find a Attachments
     * @example
     * // Get one Attachments
     * const attachments = await prisma.attachments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends attachmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, attachmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__attachmentsClient<$Result.GetResult<Prisma.$attachmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachmentsFindFirstArgs} args - Arguments to find a Attachments
     * @example
     * // Get one Attachments
     * const attachments = await prisma.attachments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends attachmentsFindFirstArgs>(args?: SelectSubset<T, attachmentsFindFirstArgs<ExtArgs>>): Prisma__attachmentsClient<$Result.GetResult<Prisma.$attachmentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attachments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachmentsFindFirstOrThrowArgs} args - Arguments to find a Attachments
     * @example
     * // Get one Attachments
     * const attachments = await prisma.attachments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends attachmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, attachmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__attachmentsClient<$Result.GetResult<Prisma.$attachmentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attachments
     * const attachments = await prisma.attachments.findMany()
     * 
     * // Get first 10 Attachments
     * const attachments = await prisma.attachments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attachmentsWithIdOnly = await prisma.attachments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends attachmentsFindManyArgs>(args?: SelectSubset<T, attachmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attachmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attachments.
     * @param {attachmentsCreateArgs} args - Arguments to create a Attachments.
     * @example
     * // Create one Attachments
     * const Attachments = await prisma.attachments.create({
     *   data: {
     *     // ... data to create a Attachments
     *   }
     * })
     * 
     */
    create<T extends attachmentsCreateArgs>(args: SelectSubset<T, attachmentsCreateArgs<ExtArgs>>): Prisma__attachmentsClient<$Result.GetResult<Prisma.$attachmentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attachments.
     * @param {attachmentsCreateManyArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachments = await prisma.attachments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends attachmentsCreateManyArgs>(args?: SelectSubset<T, attachmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attachments and returns the data saved in the database.
     * @param {attachmentsCreateManyAndReturnArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachments = await prisma.attachments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attachments and only return the `id`
     * const attachmentsWithIdOnly = await prisma.attachments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends attachmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, attachmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attachmentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attachments.
     * @param {attachmentsDeleteArgs} args - Arguments to delete one Attachments.
     * @example
     * // Delete one Attachments
     * const Attachments = await prisma.attachments.delete({
     *   where: {
     *     // ... filter to delete one Attachments
     *   }
     * })
     * 
     */
    delete<T extends attachmentsDeleteArgs>(args: SelectSubset<T, attachmentsDeleteArgs<ExtArgs>>): Prisma__attachmentsClient<$Result.GetResult<Prisma.$attachmentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attachments.
     * @param {attachmentsUpdateArgs} args - Arguments to update one Attachments.
     * @example
     * // Update one Attachments
     * const attachments = await prisma.attachments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends attachmentsUpdateArgs>(args: SelectSubset<T, attachmentsUpdateArgs<ExtArgs>>): Prisma__attachmentsClient<$Result.GetResult<Prisma.$attachmentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attachments.
     * @param {attachmentsDeleteManyArgs} args - Arguments to filter Attachments to delete.
     * @example
     * // Delete a few Attachments
     * const { count } = await prisma.attachments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends attachmentsDeleteManyArgs>(args?: SelectSubset<T, attachmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attachments
     * const attachments = await prisma.attachments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends attachmentsUpdateManyArgs>(args: SelectSubset<T, attachmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments and returns the data updated in the database.
     * @param {attachmentsUpdateManyAndReturnArgs} args - Arguments to update many Attachments.
     * @example
     * // Update many Attachments
     * const attachments = await prisma.attachments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attachments and only return the `id`
     * const attachmentsWithIdOnly = await prisma.attachments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends attachmentsUpdateManyAndReturnArgs>(args: SelectSubset<T, attachmentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attachmentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attachments.
     * @param {attachmentsUpsertArgs} args - Arguments to update or create a Attachments.
     * @example
     * // Update or create a Attachments
     * const attachments = await prisma.attachments.upsert({
     *   create: {
     *     // ... data to create a Attachments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attachments we want to update
     *   }
     * })
     */
    upsert<T extends attachmentsUpsertArgs>(args: SelectSubset<T, attachmentsUpsertArgs<ExtArgs>>): Prisma__attachmentsClient<$Result.GetResult<Prisma.$attachmentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachmentsCountArgs} args - Arguments to filter Attachments to count.
     * @example
     * // Count the number of Attachments
     * const count = await prisma.attachments.count({
     *   where: {
     *     // ... the filter for the Attachments we want to count
     *   }
     * })
    **/
    count<T extends attachmentsCountArgs>(
      args?: Subset<T, attachmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttachmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttachmentsAggregateArgs>(args: Subset<T, AttachmentsAggregateArgs>): Prisma.PrismaPromise<GetAttachmentsAggregateType<T>>

    /**
     * Group by Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attachmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends attachmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: attachmentsGroupByArgs['orderBy'] }
        : { orderBy?: attachmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, attachmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttachmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the attachments model
   */
  readonly fields: attachmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for attachments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__attachmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    note<T extends attachments$noteArgs<ExtArgs> = {}>(args?: Subset<T, attachments$noteArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    account<T extends attachments$accountArgs<ExtArgs> = {}>(args?: Subset<T, attachments$accountArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the attachments model
   */
  interface attachmentsFieldRefs {
    readonly id: FieldRef<"attachments", 'Int'>
    readonly isShare: FieldRef<"attachments", 'Boolean'>
    readonly sharePassword: FieldRef<"attachments", 'String'>
    readonly name: FieldRef<"attachments", 'String'>
    readonly path: FieldRef<"attachments", 'String'>
    readonly size: FieldRef<"attachments", 'Decimal'>
    readonly type: FieldRef<"attachments", 'String'>
    readonly noteId: FieldRef<"attachments", 'Int'>
    readonly accountId: FieldRef<"attachments", 'Int'>
    readonly sortOrder: FieldRef<"attachments", 'Int'>
    readonly createdAt: FieldRef<"attachments", 'DateTime'>
    readonly updatedAt: FieldRef<"attachments", 'DateTime'>
    readonly perfixPath: FieldRef<"attachments", 'String'>
    readonly depth: FieldRef<"attachments", 'Int'>
    readonly metadata: FieldRef<"attachments", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * attachments findUnique
   */
  export type attachmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachments
     */
    select?: attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attachments
     */
    omit?: attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attachmentsInclude<ExtArgs> | null
    /**
     * Filter, which attachments to fetch.
     */
    where: attachmentsWhereUniqueInput
  }

  /**
   * attachments findUniqueOrThrow
   */
  export type attachmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachments
     */
    select?: attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attachments
     */
    omit?: attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attachmentsInclude<ExtArgs> | null
    /**
     * Filter, which attachments to fetch.
     */
    where: attachmentsWhereUniqueInput
  }

  /**
   * attachments findFirst
   */
  export type attachmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachments
     */
    select?: attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attachments
     */
    omit?: attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attachmentsInclude<ExtArgs> | null
    /**
     * Filter, which attachments to fetch.
     */
    where?: attachmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attachments to fetch.
     */
    orderBy?: attachmentsOrderByWithRelationInput | attachmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attachments.
     */
    cursor?: attachmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attachments.
     */
    distinct?: AttachmentsScalarFieldEnum | AttachmentsScalarFieldEnum[]
  }

  /**
   * attachments findFirstOrThrow
   */
  export type attachmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachments
     */
    select?: attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attachments
     */
    omit?: attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attachmentsInclude<ExtArgs> | null
    /**
     * Filter, which attachments to fetch.
     */
    where?: attachmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attachments to fetch.
     */
    orderBy?: attachmentsOrderByWithRelationInput | attachmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attachments.
     */
    cursor?: attachmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attachments.
     */
    distinct?: AttachmentsScalarFieldEnum | AttachmentsScalarFieldEnum[]
  }

  /**
   * attachments findMany
   */
  export type attachmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachments
     */
    select?: attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attachments
     */
    omit?: attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attachmentsInclude<ExtArgs> | null
    /**
     * Filter, which attachments to fetch.
     */
    where?: attachmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attachments to fetch.
     */
    orderBy?: attachmentsOrderByWithRelationInput | attachmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing attachments.
     */
    cursor?: attachmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attachments.
     */
    skip?: number
    distinct?: AttachmentsScalarFieldEnum | AttachmentsScalarFieldEnum[]
  }

  /**
   * attachments create
   */
  export type attachmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachments
     */
    select?: attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attachments
     */
    omit?: attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attachmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a attachments.
     */
    data: XOR<attachmentsCreateInput, attachmentsUncheckedCreateInput>
  }

  /**
   * attachments createMany
   */
  export type attachmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many attachments.
     */
    data: attachmentsCreateManyInput | attachmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * attachments createManyAndReturn
   */
  export type attachmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachments
     */
    select?: attachmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the attachments
     */
    omit?: attachmentsOmit<ExtArgs> | null
    /**
     * The data used to create many attachments.
     */
    data: attachmentsCreateManyInput | attachmentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attachmentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * attachments update
   */
  export type attachmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachments
     */
    select?: attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attachments
     */
    omit?: attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attachmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a attachments.
     */
    data: XOR<attachmentsUpdateInput, attachmentsUncheckedUpdateInput>
    /**
     * Choose, which attachments to update.
     */
    where: attachmentsWhereUniqueInput
  }

  /**
   * attachments updateMany
   */
  export type attachmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update attachments.
     */
    data: XOR<attachmentsUpdateManyMutationInput, attachmentsUncheckedUpdateManyInput>
    /**
     * Filter which attachments to update
     */
    where?: attachmentsWhereInput
    /**
     * Limit how many attachments to update.
     */
    limit?: number
  }

  /**
   * attachments updateManyAndReturn
   */
  export type attachmentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachments
     */
    select?: attachmentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the attachments
     */
    omit?: attachmentsOmit<ExtArgs> | null
    /**
     * The data used to update attachments.
     */
    data: XOR<attachmentsUpdateManyMutationInput, attachmentsUncheckedUpdateManyInput>
    /**
     * Filter which attachments to update
     */
    where?: attachmentsWhereInput
    /**
     * Limit how many attachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attachmentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * attachments upsert
   */
  export type attachmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachments
     */
    select?: attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attachments
     */
    omit?: attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attachmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the attachments to update in case it exists.
     */
    where: attachmentsWhereUniqueInput
    /**
     * In case the attachments found by the `where` argument doesn't exist, create a new attachments with this data.
     */
    create: XOR<attachmentsCreateInput, attachmentsUncheckedCreateInput>
    /**
     * In case the attachments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<attachmentsUpdateInput, attachmentsUncheckedUpdateInput>
  }

  /**
   * attachments delete
   */
  export type attachmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachments
     */
    select?: attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attachments
     */
    omit?: attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attachmentsInclude<ExtArgs> | null
    /**
     * Filter which attachments to delete.
     */
    where: attachmentsWhereUniqueInput
  }

  /**
   * attachments deleteMany
   */
  export type attachmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attachments to delete
     */
    where?: attachmentsWhereInput
    /**
     * Limit how many attachments to delete.
     */
    limit?: number
  }

  /**
   * attachments.note
   */
  export type attachments$noteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notesInclude<ExtArgs> | null
    where?: notesWhereInput
  }

  /**
   * attachments.account
   */
  export type attachments$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    where?: accountsWhereInput
  }

  /**
   * attachments without action
   */
  export type attachmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachments
     */
    select?: attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attachments
     */
    omit?: attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attachmentsInclude<ExtArgs> | null
  }


  /**
   * Model config
   */

  export type AggregateConfig = {
    _count: ConfigCountAggregateOutputType | null
    _avg: ConfigAvgAggregateOutputType | null
    _sum: ConfigSumAggregateOutputType | null
    _min: ConfigMinAggregateOutputType | null
    _max: ConfigMaxAggregateOutputType | null
  }

  export type ConfigAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ConfigSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ConfigMinAggregateOutputType = {
    id: number | null
    key: string | null
    userId: number | null
  }

  export type ConfigMaxAggregateOutputType = {
    id: number | null
    key: string | null
    userId: number | null
  }

  export type ConfigCountAggregateOutputType = {
    id: number
    key: number
    config: number
    userId: number
    _all: number
  }


  export type ConfigAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ConfigSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ConfigMinAggregateInputType = {
    id?: true
    key?: true
    userId?: true
  }

  export type ConfigMaxAggregateInputType = {
    id?: true
    key?: true
    userId?: true
  }

  export type ConfigCountAggregateInputType = {
    id?: true
    key?: true
    config?: true
    userId?: true
    _all?: true
  }

  export type ConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which config to aggregate.
     */
    where?: configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs to fetch.
     */
    orderBy?: configOrderByWithRelationInput | configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned configs
    **/
    _count?: true | ConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfigMaxAggregateInputType
  }

  export type GetConfigAggregateType<T extends ConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfig[P]>
      : GetScalarType<T[P], AggregateConfig[P]>
  }




  export type configGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: configWhereInput
    orderBy?: configOrderByWithAggregationInput | configOrderByWithAggregationInput[]
    by: ConfigScalarFieldEnum[] | ConfigScalarFieldEnum
    having?: configScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfigCountAggregateInputType | true
    _avg?: ConfigAvgAggregateInputType
    _sum?: ConfigSumAggregateInputType
    _min?: ConfigMinAggregateInputType
    _max?: ConfigMaxAggregateInputType
  }

  export type ConfigGroupByOutputType = {
    id: number
    key: string
    config: JsonValue | null
    userId: number | null
    _count: ConfigCountAggregateOutputType | null
    _avg: ConfigAvgAggregateOutputType | null
    _sum: ConfigSumAggregateOutputType | null
    _min: ConfigMinAggregateOutputType | null
    _max: ConfigMaxAggregateOutputType | null
  }

  type GetConfigGroupByPayload<T extends configGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfigGroupByOutputType[P]>
            : GetScalarType<T[P], ConfigGroupByOutputType[P]>
        }
      >
    >


  export type configSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    config?: boolean
    userId?: boolean
    user?: boolean | config$userArgs<ExtArgs>
  }, ExtArgs["result"]["config"]>

  export type configSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    config?: boolean
    userId?: boolean
    user?: boolean | config$userArgs<ExtArgs>
  }, ExtArgs["result"]["config"]>

  export type configSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    config?: boolean
    userId?: boolean
    user?: boolean | config$userArgs<ExtArgs>
  }, ExtArgs["result"]["config"]>

  export type configSelectScalar = {
    id?: boolean
    key?: boolean
    config?: boolean
    userId?: boolean
  }

  export type configOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "config" | "userId", ExtArgs["result"]["config"]>
  export type configInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | config$userArgs<ExtArgs>
  }
  export type configIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | config$userArgs<ExtArgs>
  }
  export type configIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | config$userArgs<ExtArgs>
  }

  export type $configPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "config"
    objects: {
      user: Prisma.$accountsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      key: string
      config: Prisma.JsonValue | null
      userId: number | null
    }, ExtArgs["result"]["config"]>
    composites: {}
  }

  type configGetPayload<S extends boolean | null | undefined | configDefaultArgs> = $Result.GetResult<Prisma.$configPayload, S>

  type configCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<configFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConfigCountAggregateInputType | true
    }

  export interface configDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['config'], meta: { name: 'config' } }
    /**
     * Find zero or one Config that matches the filter.
     * @param {configFindUniqueArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends configFindUniqueArgs>(args: SelectSubset<T, configFindUniqueArgs<ExtArgs>>): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Config that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {configFindUniqueOrThrowArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends configFindUniqueOrThrowArgs>(args: SelectSubset<T, configFindUniqueOrThrowArgs<ExtArgs>>): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Config that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configFindFirstArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends configFindFirstArgs>(args?: SelectSubset<T, configFindFirstArgs<ExtArgs>>): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Config that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configFindFirstOrThrowArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends configFindFirstOrThrowArgs>(args?: SelectSubset<T, configFindFirstOrThrowArgs<ExtArgs>>): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Configs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Configs
     * const configs = await prisma.config.findMany()
     * 
     * // Get first 10 Configs
     * const configs = await prisma.config.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configWithIdOnly = await prisma.config.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends configFindManyArgs>(args?: SelectSubset<T, configFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Config.
     * @param {configCreateArgs} args - Arguments to create a Config.
     * @example
     * // Create one Config
     * const Config = await prisma.config.create({
     *   data: {
     *     // ... data to create a Config
     *   }
     * })
     * 
     */
    create<T extends configCreateArgs>(args: SelectSubset<T, configCreateArgs<ExtArgs>>): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Configs.
     * @param {configCreateManyArgs} args - Arguments to create many Configs.
     * @example
     * // Create many Configs
     * const config = await prisma.config.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends configCreateManyArgs>(args?: SelectSubset<T, configCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Configs and returns the data saved in the database.
     * @param {configCreateManyAndReturnArgs} args - Arguments to create many Configs.
     * @example
     * // Create many Configs
     * const config = await prisma.config.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Configs and only return the `id`
     * const configWithIdOnly = await prisma.config.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends configCreateManyAndReturnArgs>(args?: SelectSubset<T, configCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Config.
     * @param {configDeleteArgs} args - Arguments to delete one Config.
     * @example
     * // Delete one Config
     * const Config = await prisma.config.delete({
     *   where: {
     *     // ... filter to delete one Config
     *   }
     * })
     * 
     */
    delete<T extends configDeleteArgs>(args: SelectSubset<T, configDeleteArgs<ExtArgs>>): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Config.
     * @param {configUpdateArgs} args - Arguments to update one Config.
     * @example
     * // Update one Config
     * const config = await prisma.config.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends configUpdateArgs>(args: SelectSubset<T, configUpdateArgs<ExtArgs>>): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Configs.
     * @param {configDeleteManyArgs} args - Arguments to filter Configs to delete.
     * @example
     * // Delete a few Configs
     * const { count } = await prisma.config.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends configDeleteManyArgs>(args?: SelectSubset<T, configDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Configs
     * const config = await prisma.config.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends configUpdateManyArgs>(args: SelectSubset<T, configUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Configs and returns the data updated in the database.
     * @param {configUpdateManyAndReturnArgs} args - Arguments to update many Configs.
     * @example
     * // Update many Configs
     * const config = await prisma.config.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Configs and only return the `id`
     * const configWithIdOnly = await prisma.config.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends configUpdateManyAndReturnArgs>(args: SelectSubset<T, configUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Config.
     * @param {configUpsertArgs} args - Arguments to update or create a Config.
     * @example
     * // Update or create a Config
     * const config = await prisma.config.upsert({
     *   create: {
     *     // ... data to create a Config
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Config we want to update
     *   }
     * })
     */
    upsert<T extends configUpsertArgs>(args: SelectSubset<T, configUpsertArgs<ExtArgs>>): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configCountArgs} args - Arguments to filter Configs to count.
     * @example
     * // Count the number of Configs
     * const count = await prisma.config.count({
     *   where: {
     *     // ... the filter for the Configs we want to count
     *   }
     * })
    **/
    count<T extends configCountArgs>(
      args?: Subset<T, configCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfigAggregateArgs>(args: Subset<T, ConfigAggregateArgs>): Prisma.PrismaPromise<GetConfigAggregateType<T>>

    /**
     * Group by Config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends configGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: configGroupByArgs['orderBy'] }
        : { orderBy?: configGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, configGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the config model
   */
  readonly fields: configFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for config.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__configClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends config$userArgs<ExtArgs> = {}>(args?: Subset<T, config$userArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the config model
   */
  interface configFieldRefs {
    readonly id: FieldRef<"config", 'Int'>
    readonly key: FieldRef<"config", 'String'>
    readonly config: FieldRef<"config", 'Json'>
    readonly userId: FieldRef<"config", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * config findUnique
   */
  export type configFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the config
     */
    omit?: configOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: configInclude<ExtArgs> | null
    /**
     * Filter, which config to fetch.
     */
    where: configWhereUniqueInput
  }

  /**
   * config findUniqueOrThrow
   */
  export type configFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the config
     */
    omit?: configOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: configInclude<ExtArgs> | null
    /**
     * Filter, which config to fetch.
     */
    where: configWhereUniqueInput
  }

  /**
   * config findFirst
   */
  export type configFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the config
     */
    omit?: configOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: configInclude<ExtArgs> | null
    /**
     * Filter, which config to fetch.
     */
    where?: configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs to fetch.
     */
    orderBy?: configOrderByWithRelationInput | configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for configs.
     */
    cursor?: configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of configs.
     */
    distinct?: ConfigScalarFieldEnum | ConfigScalarFieldEnum[]
  }

  /**
   * config findFirstOrThrow
   */
  export type configFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the config
     */
    omit?: configOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: configInclude<ExtArgs> | null
    /**
     * Filter, which config to fetch.
     */
    where?: configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs to fetch.
     */
    orderBy?: configOrderByWithRelationInput | configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for configs.
     */
    cursor?: configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of configs.
     */
    distinct?: ConfigScalarFieldEnum | ConfigScalarFieldEnum[]
  }

  /**
   * config findMany
   */
  export type configFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the config
     */
    omit?: configOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: configInclude<ExtArgs> | null
    /**
     * Filter, which configs to fetch.
     */
    where?: configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs to fetch.
     */
    orderBy?: configOrderByWithRelationInput | configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing configs.
     */
    cursor?: configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs.
     */
    skip?: number
    distinct?: ConfigScalarFieldEnum | ConfigScalarFieldEnum[]
  }

  /**
   * config create
   */
  export type configCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the config
     */
    omit?: configOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: configInclude<ExtArgs> | null
    /**
     * The data needed to create a config.
     */
    data?: XOR<configCreateInput, configUncheckedCreateInput>
  }

  /**
   * config createMany
   */
  export type configCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many configs.
     */
    data: configCreateManyInput | configCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * config createManyAndReturn
   */
  export type configCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the config
     */
    omit?: configOmit<ExtArgs> | null
    /**
     * The data used to create many configs.
     */
    data: configCreateManyInput | configCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: configIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * config update
   */
  export type configUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the config
     */
    omit?: configOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: configInclude<ExtArgs> | null
    /**
     * The data needed to update a config.
     */
    data: XOR<configUpdateInput, configUncheckedUpdateInput>
    /**
     * Choose, which config to update.
     */
    where: configWhereUniqueInput
  }

  /**
   * config updateMany
   */
  export type configUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update configs.
     */
    data: XOR<configUpdateManyMutationInput, configUncheckedUpdateManyInput>
    /**
     * Filter which configs to update
     */
    where?: configWhereInput
    /**
     * Limit how many configs to update.
     */
    limit?: number
  }

  /**
   * config updateManyAndReturn
   */
  export type configUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the config
     */
    omit?: configOmit<ExtArgs> | null
    /**
     * The data used to update configs.
     */
    data: XOR<configUpdateManyMutationInput, configUncheckedUpdateManyInput>
    /**
     * Filter which configs to update
     */
    where?: configWhereInput
    /**
     * Limit how many configs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: configIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * config upsert
   */
  export type configUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the config
     */
    omit?: configOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: configInclude<ExtArgs> | null
    /**
     * The filter to search for the config to update in case it exists.
     */
    where: configWhereUniqueInput
    /**
     * In case the config found by the `where` argument doesn't exist, create a new config with this data.
     */
    create: XOR<configCreateInput, configUncheckedCreateInput>
    /**
     * In case the config was found with the provided `where` argument, update it with this data.
     */
    update: XOR<configUpdateInput, configUncheckedUpdateInput>
  }

  /**
   * config delete
   */
  export type configDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the config
     */
    omit?: configOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: configInclude<ExtArgs> | null
    /**
     * Filter which config to delete.
     */
    where: configWhereUniqueInput
  }

  /**
   * config deleteMany
   */
  export type configDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which configs to delete
     */
    where?: configWhereInput
    /**
     * Limit how many configs to delete.
     */
    limit?: number
  }

  /**
   * config.user
   */
  export type config$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    where?: accountsWhereInput
  }

  /**
   * config without action
   */
  export type configDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the config
     */
    omit?: configOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: configInclude<ExtArgs> | null
  }


  /**
   * Model notes
   */

  export type AggregateNotes = {
    _count: NotesCountAggregateOutputType | null
    _avg: NotesAvgAggregateOutputType | null
    _sum: NotesSumAggregateOutputType | null
    _min: NotesMinAggregateOutputType | null
    _max: NotesMaxAggregateOutputType | null
  }

  export type NotesAvgAggregateOutputType = {
    id: number | null
    type: number | null
    shareMaxView: number | null
    shareViewCount: number | null
    accountId: number | null
    sortOrder: number | null
  }

  export type NotesSumAggregateOutputType = {
    id: number | null
    type: number | null
    shareMaxView: number | null
    shareViewCount: number | null
    accountId: number | null
    sortOrder: number | null
  }

  export type NotesMinAggregateOutputType = {
    id: number | null
    type: number | null
    content: string | null
    isArchived: boolean | null
    isRecycle: boolean | null
    isShare: boolean | null
    isTop: boolean | null
    isReviewed: boolean | null
    sharePassword: string | null
    shareEncryptedUrl: string | null
    shareExpiryDate: Date | null
    shareMaxView: number | null
    shareViewCount: number | null
    accountId: number | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotesMaxAggregateOutputType = {
    id: number | null
    type: number | null
    content: string | null
    isArchived: boolean | null
    isRecycle: boolean | null
    isShare: boolean | null
    isTop: boolean | null
    isReviewed: boolean | null
    sharePassword: string | null
    shareEncryptedUrl: string | null
    shareExpiryDate: Date | null
    shareMaxView: number | null
    shareViewCount: number | null
    accountId: number | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotesCountAggregateOutputType = {
    id: number
    type: number
    content: number
    isArchived: number
    isRecycle: number
    isShare: number
    isTop: number
    isReviewed: number
    sharePassword: number
    shareEncryptedUrl: number
    shareExpiryDate: number
    shareMaxView: number
    shareViewCount: number
    metadata: number
    accountId: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotesAvgAggregateInputType = {
    id?: true
    type?: true
    shareMaxView?: true
    shareViewCount?: true
    accountId?: true
    sortOrder?: true
  }

  export type NotesSumAggregateInputType = {
    id?: true
    type?: true
    shareMaxView?: true
    shareViewCount?: true
    accountId?: true
    sortOrder?: true
  }

  export type NotesMinAggregateInputType = {
    id?: true
    type?: true
    content?: true
    isArchived?: true
    isRecycle?: true
    isShare?: true
    isTop?: true
    isReviewed?: true
    sharePassword?: true
    shareEncryptedUrl?: true
    shareExpiryDate?: true
    shareMaxView?: true
    shareViewCount?: true
    accountId?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotesMaxAggregateInputType = {
    id?: true
    type?: true
    content?: true
    isArchived?: true
    isRecycle?: true
    isShare?: true
    isTop?: true
    isReviewed?: true
    sharePassword?: true
    shareEncryptedUrl?: true
    shareExpiryDate?: true
    shareMaxView?: true
    shareViewCount?: true
    accountId?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotesCountAggregateInputType = {
    id?: true
    type?: true
    content?: true
    isArchived?: true
    isRecycle?: true
    isShare?: true
    isTop?: true
    isReviewed?: true
    sharePassword?: true
    shareEncryptedUrl?: true
    shareExpiryDate?: true
    shareMaxView?: true
    shareViewCount?: true
    metadata?: true
    accountId?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notes to aggregate.
     */
    where?: notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notes to fetch.
     */
    orderBy?: notesOrderByWithRelationInput | notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notes
    **/
    _count?: true | NotesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotesMaxAggregateInputType
  }

  export type GetNotesAggregateType<T extends NotesAggregateArgs> = {
        [P in keyof T & keyof AggregateNotes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotes[P]>
      : GetScalarType<T[P], AggregateNotes[P]>
  }




  export type notesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notesWhereInput
    orderBy?: notesOrderByWithAggregationInput | notesOrderByWithAggregationInput[]
    by: NotesScalarFieldEnum[] | NotesScalarFieldEnum
    having?: notesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotesCountAggregateInputType | true
    _avg?: NotesAvgAggregateInputType
    _sum?: NotesSumAggregateInputType
    _min?: NotesMinAggregateInputType
    _max?: NotesMaxAggregateInputType
  }

  export type NotesGroupByOutputType = {
    id: number
    type: number
    content: string
    isArchived: boolean
    isRecycle: boolean
    isShare: boolean
    isTop: boolean
    isReviewed: boolean
    sharePassword: string
    shareEncryptedUrl: string | null
    shareExpiryDate: Date | null
    shareMaxView: number | null
    shareViewCount: number | null
    metadata: JsonValue | null
    accountId: number | null
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: NotesCountAggregateOutputType | null
    _avg: NotesAvgAggregateOutputType | null
    _sum: NotesSumAggregateOutputType | null
    _min: NotesMinAggregateOutputType | null
    _max: NotesMaxAggregateOutputType | null
  }

  type GetNotesGroupByPayload<T extends notesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotesGroupByOutputType[P]>
            : GetScalarType<T[P], NotesGroupByOutputType[P]>
        }
      >
    >


  export type notesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    content?: boolean
    isArchived?: boolean
    isRecycle?: boolean
    isShare?: boolean
    isTop?: boolean
    isReviewed?: boolean
    sharePassword?: boolean
    shareEncryptedUrl?: boolean
    shareExpiryDate?: boolean
    shareMaxView?: boolean
    shareViewCount?: boolean
    metadata?: boolean
    accountId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    attachments?: boolean | notes$attachmentsArgs<ExtArgs>
    tags?: boolean | notes$tagsArgs<ExtArgs>
    account?: boolean | notes$accountArgs<ExtArgs>
    referencedBy?: boolean | notes$referencedByArgs<ExtArgs>
    references?: boolean | notes$referencesArgs<ExtArgs>
    comments?: boolean | notes$commentsArgs<ExtArgs>
    histories?: boolean | notes$historiesArgs<ExtArgs>
    internalShares?: boolean | notes$internalSharesArgs<ExtArgs>
    _count?: boolean | NotesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notes"]>

  export type notesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    content?: boolean
    isArchived?: boolean
    isRecycle?: boolean
    isShare?: boolean
    isTop?: boolean
    isReviewed?: boolean
    sharePassword?: boolean
    shareEncryptedUrl?: boolean
    shareExpiryDate?: boolean
    shareMaxView?: boolean
    shareViewCount?: boolean
    metadata?: boolean
    accountId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | notes$accountArgs<ExtArgs>
  }, ExtArgs["result"]["notes"]>

  export type notesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    content?: boolean
    isArchived?: boolean
    isRecycle?: boolean
    isShare?: boolean
    isTop?: boolean
    isReviewed?: boolean
    sharePassword?: boolean
    shareEncryptedUrl?: boolean
    shareExpiryDate?: boolean
    shareMaxView?: boolean
    shareViewCount?: boolean
    metadata?: boolean
    accountId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | notes$accountArgs<ExtArgs>
  }, ExtArgs["result"]["notes"]>

  export type notesSelectScalar = {
    id?: boolean
    type?: boolean
    content?: boolean
    isArchived?: boolean
    isRecycle?: boolean
    isShare?: boolean
    isTop?: boolean
    isReviewed?: boolean
    sharePassword?: boolean
    shareEncryptedUrl?: boolean
    shareExpiryDate?: boolean
    shareMaxView?: boolean
    shareViewCount?: boolean
    metadata?: boolean
    accountId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type notesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "content" | "isArchived" | "isRecycle" | "isShare" | "isTop" | "isReviewed" | "sharePassword" | "shareEncryptedUrl" | "shareExpiryDate" | "shareMaxView" | "shareViewCount" | "metadata" | "accountId" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["notes"]>
  export type notesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | notes$attachmentsArgs<ExtArgs>
    tags?: boolean | notes$tagsArgs<ExtArgs>
    account?: boolean | notes$accountArgs<ExtArgs>
    referencedBy?: boolean | notes$referencedByArgs<ExtArgs>
    references?: boolean | notes$referencesArgs<ExtArgs>
    comments?: boolean | notes$commentsArgs<ExtArgs>
    histories?: boolean | notes$historiesArgs<ExtArgs>
    internalShares?: boolean | notes$internalSharesArgs<ExtArgs>
    _count?: boolean | NotesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type notesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | notes$accountArgs<ExtArgs>
  }
  export type notesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | notes$accountArgs<ExtArgs>
  }

  export type $notesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notes"
    objects: {
      attachments: Prisma.$attachmentsPayload<ExtArgs>[]
      tags: Prisma.$tagsToNotePayload<ExtArgs>[]
      account: Prisma.$accountsPayload<ExtArgs> | null
      referencedBy: Prisma.$noteReferencePayload<ExtArgs>[]
      references: Prisma.$noteReferencePayload<ExtArgs>[]
      comments: Prisma.$commentsPayload<ExtArgs>[]
      histories: Prisma.$noteHistoryPayload<ExtArgs>[]
      internalShares: Prisma.$noteInternalSharePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: number
      content: string
      isArchived: boolean
      isRecycle: boolean
      isShare: boolean
      isTop: boolean
      isReviewed: boolean
      sharePassword: string
      shareEncryptedUrl: string | null
      shareExpiryDate: Date | null
      shareMaxView: number | null
      shareViewCount: number | null
      metadata: Prisma.JsonValue | null
      accountId: number | null
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notes"]>
    composites: {}
  }

  type notesGetPayload<S extends boolean | null | undefined | notesDefaultArgs> = $Result.GetResult<Prisma.$notesPayload, S>

  type notesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotesCountAggregateInputType | true
    }

  export interface notesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notes'], meta: { name: 'notes' } }
    /**
     * Find zero or one Notes that matches the filter.
     * @param {notesFindUniqueArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notesFindUniqueArgs>(args: SelectSubset<T, notesFindUniqueArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notesFindUniqueOrThrowArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notesFindUniqueOrThrowArgs>(args: SelectSubset<T, notesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesFindFirstArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notesFindFirstArgs>(args?: SelectSubset<T, notesFindFirstArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesFindFirstOrThrowArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notesFindFirstOrThrowArgs>(args?: SelectSubset<T, notesFindFirstOrThrowArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notes
     * const notes = await prisma.notes.findMany()
     * 
     * // Get first 10 Notes
     * const notes = await prisma.notes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notesWithIdOnly = await prisma.notes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notesFindManyArgs>(args?: SelectSubset<T, notesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notes.
     * @param {notesCreateArgs} args - Arguments to create a Notes.
     * @example
     * // Create one Notes
     * const Notes = await prisma.notes.create({
     *   data: {
     *     // ... data to create a Notes
     *   }
     * })
     * 
     */
    create<T extends notesCreateArgs>(args: SelectSubset<T, notesCreateArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notes.
     * @param {notesCreateManyArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const notes = await prisma.notes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notesCreateManyArgs>(args?: SelectSubset<T, notesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notes and returns the data saved in the database.
     * @param {notesCreateManyAndReturnArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const notes = await prisma.notes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notes and only return the `id`
     * const notesWithIdOnly = await prisma.notes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notesCreateManyAndReturnArgs>(args?: SelectSubset<T, notesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notes.
     * @param {notesDeleteArgs} args - Arguments to delete one Notes.
     * @example
     * // Delete one Notes
     * const Notes = await prisma.notes.delete({
     *   where: {
     *     // ... filter to delete one Notes
     *   }
     * })
     * 
     */
    delete<T extends notesDeleteArgs>(args: SelectSubset<T, notesDeleteArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notes.
     * @param {notesUpdateArgs} args - Arguments to update one Notes.
     * @example
     * // Update one Notes
     * const notes = await prisma.notes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notesUpdateArgs>(args: SelectSubset<T, notesUpdateArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notes.
     * @param {notesDeleteManyArgs} args - Arguments to filter Notes to delete.
     * @example
     * // Delete a few Notes
     * const { count } = await prisma.notes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notesDeleteManyArgs>(args?: SelectSubset<T, notesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notes
     * const notes = await prisma.notes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notesUpdateManyArgs>(args: SelectSubset<T, notesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes and returns the data updated in the database.
     * @param {notesUpdateManyAndReturnArgs} args - Arguments to update many Notes.
     * @example
     * // Update many Notes
     * const notes = await prisma.notes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notes and only return the `id`
     * const notesWithIdOnly = await prisma.notes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends notesUpdateManyAndReturnArgs>(args: SelectSubset<T, notesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notes.
     * @param {notesUpsertArgs} args - Arguments to update or create a Notes.
     * @example
     * // Update or create a Notes
     * const notes = await prisma.notes.upsert({
     *   create: {
     *     // ... data to create a Notes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notes we want to update
     *   }
     * })
     */
    upsert<T extends notesUpsertArgs>(args: SelectSubset<T, notesUpsertArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesCountArgs} args - Arguments to filter Notes to count.
     * @example
     * // Count the number of Notes
     * const count = await prisma.notes.count({
     *   where: {
     *     // ... the filter for the Notes we want to count
     *   }
     * })
    **/
    count<T extends notesCountArgs>(
      args?: Subset<T, notesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotesAggregateArgs>(args: Subset<T, NotesAggregateArgs>): Prisma.PrismaPromise<GetNotesAggregateType<T>>

    /**
     * Group by Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notesGroupByArgs['orderBy'] }
        : { orderBy?: notesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notes model
   */
  readonly fields: notesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attachments<T extends notes$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, notes$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attachmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends notes$tagsArgs<ExtArgs> = {}>(args?: Subset<T, notes$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagsToNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    account<T extends notes$accountArgs<ExtArgs> = {}>(args?: Subset<T, notes$accountArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    referencedBy<T extends notes$referencedByArgs<ExtArgs> = {}>(args?: Subset<T, notes$referencedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$noteReferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    references<T extends notes$referencesArgs<ExtArgs> = {}>(args?: Subset<T, notes$referencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$noteReferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends notes$commentsArgs<ExtArgs> = {}>(args?: Subset<T, notes$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    histories<T extends notes$historiesArgs<ExtArgs> = {}>(args?: Subset<T, notes$historiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$noteHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    internalShares<T extends notes$internalSharesArgs<ExtArgs> = {}>(args?: Subset<T, notes$internalSharesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$noteInternalSharePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notes model
   */
  interface notesFieldRefs {
    readonly id: FieldRef<"notes", 'Int'>
    readonly type: FieldRef<"notes", 'Int'>
    readonly content: FieldRef<"notes", 'String'>
    readonly isArchived: FieldRef<"notes", 'Boolean'>
    readonly isRecycle: FieldRef<"notes", 'Boolean'>
    readonly isShare: FieldRef<"notes", 'Boolean'>
    readonly isTop: FieldRef<"notes", 'Boolean'>
    readonly isReviewed: FieldRef<"notes", 'Boolean'>
    readonly sharePassword: FieldRef<"notes", 'String'>
    readonly shareEncryptedUrl: FieldRef<"notes", 'String'>
    readonly shareExpiryDate: FieldRef<"notes", 'DateTime'>
    readonly shareMaxView: FieldRef<"notes", 'Int'>
    readonly shareViewCount: FieldRef<"notes", 'Int'>
    readonly metadata: FieldRef<"notes", 'Json'>
    readonly accountId: FieldRef<"notes", 'Int'>
    readonly sortOrder: FieldRef<"notes", 'Int'>
    readonly createdAt: FieldRef<"notes", 'DateTime'>
    readonly updatedAt: FieldRef<"notes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * notes findUnique
   */
  export type notesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notesInclude<ExtArgs> | null
    /**
     * Filter, which notes to fetch.
     */
    where: notesWhereUniqueInput
  }

  /**
   * notes findUniqueOrThrow
   */
  export type notesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notesInclude<ExtArgs> | null
    /**
     * Filter, which notes to fetch.
     */
    where: notesWhereUniqueInput
  }

  /**
   * notes findFirst
   */
  export type notesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notesInclude<ExtArgs> | null
    /**
     * Filter, which notes to fetch.
     */
    where?: notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notes to fetch.
     */
    orderBy?: notesOrderByWithRelationInput | notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notes.
     */
    cursor?: notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notes.
     */
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * notes findFirstOrThrow
   */
  export type notesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notesInclude<ExtArgs> | null
    /**
     * Filter, which notes to fetch.
     */
    where?: notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notes to fetch.
     */
    orderBy?: notesOrderByWithRelationInput | notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notes.
     */
    cursor?: notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notes.
     */
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * notes findMany
   */
  export type notesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notesInclude<ExtArgs> | null
    /**
     * Filter, which notes to fetch.
     */
    where?: notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notes to fetch.
     */
    orderBy?: notesOrderByWithRelationInput | notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notes.
     */
    cursor?: notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notes.
     */
    skip?: number
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * notes create
   */
  export type notesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notesInclude<ExtArgs> | null
    /**
     * The data needed to create a notes.
     */
    data: XOR<notesCreateInput, notesUncheckedCreateInput>
  }

  /**
   * notes createMany
   */
  export type notesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notes.
     */
    data: notesCreateManyInput | notesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notes createManyAndReturn
   */
  export type notesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * The data used to create many notes.
     */
    data: notesCreateManyInput | notesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * notes update
   */
  export type notesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notesInclude<ExtArgs> | null
    /**
     * The data needed to update a notes.
     */
    data: XOR<notesUpdateInput, notesUncheckedUpdateInput>
    /**
     * Choose, which notes to update.
     */
    where: notesWhereUniqueInput
  }

  /**
   * notes updateMany
   */
  export type notesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notes.
     */
    data: XOR<notesUpdateManyMutationInput, notesUncheckedUpdateManyInput>
    /**
     * Filter which notes to update
     */
    where?: notesWhereInput
    /**
     * Limit how many notes to update.
     */
    limit?: number
  }

  /**
   * notes updateManyAndReturn
   */
  export type notesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * The data used to update notes.
     */
    data: XOR<notesUpdateManyMutationInput, notesUncheckedUpdateManyInput>
    /**
     * Filter which notes to update
     */
    where?: notesWhereInput
    /**
     * Limit how many notes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * notes upsert
   */
  export type notesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notesInclude<ExtArgs> | null
    /**
     * The filter to search for the notes to update in case it exists.
     */
    where: notesWhereUniqueInput
    /**
     * In case the notes found by the `where` argument doesn't exist, create a new notes with this data.
     */
    create: XOR<notesCreateInput, notesUncheckedCreateInput>
    /**
     * In case the notes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notesUpdateInput, notesUncheckedUpdateInput>
  }

  /**
   * notes delete
   */
  export type notesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notesInclude<ExtArgs> | null
    /**
     * Filter which notes to delete.
     */
    where: notesWhereUniqueInput
  }

  /**
   * notes deleteMany
   */
  export type notesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notes to delete
     */
    where?: notesWhereInput
    /**
     * Limit how many notes to delete.
     */
    limit?: number
  }

  /**
   * notes.attachments
   */
  export type notes$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attachments
     */
    select?: attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attachments
     */
    omit?: attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attachmentsInclude<ExtArgs> | null
    where?: attachmentsWhereInput
    orderBy?: attachmentsOrderByWithRelationInput | attachmentsOrderByWithRelationInput[]
    cursor?: attachmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentsScalarFieldEnum | AttachmentsScalarFieldEnum[]
  }

  /**
   * notes.tags
   */
  export type notes$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tagsToNote
     */
    select?: tagsToNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tagsToNote
     */
    omit?: tagsToNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsToNoteInclude<ExtArgs> | null
    where?: tagsToNoteWhereInput
    orderBy?: tagsToNoteOrderByWithRelationInput | tagsToNoteOrderByWithRelationInput[]
    cursor?: tagsToNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagsToNoteScalarFieldEnum | TagsToNoteScalarFieldEnum[]
  }

  /**
   * notes.account
   */
  export type notes$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    where?: accountsWhereInput
  }

  /**
   * notes.referencedBy
   */
  export type notes$referencedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteReference
     */
    select?: noteReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteReference
     */
    omit?: noteReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteReferenceInclude<ExtArgs> | null
    where?: noteReferenceWhereInput
    orderBy?: noteReferenceOrderByWithRelationInput | noteReferenceOrderByWithRelationInput[]
    cursor?: noteReferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteReferenceScalarFieldEnum | NoteReferenceScalarFieldEnum[]
  }

  /**
   * notes.references
   */
  export type notes$referencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteReference
     */
    select?: noteReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteReference
     */
    omit?: noteReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteReferenceInclude<ExtArgs> | null
    where?: noteReferenceWhereInput
    orderBy?: noteReferenceOrderByWithRelationInput | noteReferenceOrderByWithRelationInput[]
    cursor?: noteReferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteReferenceScalarFieldEnum | NoteReferenceScalarFieldEnum[]
  }

  /**
   * notes.comments
   */
  export type notes$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    where?: commentsWhereInput
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    cursor?: commentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * notes.histories
   */
  export type notes$historiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteHistory
     */
    select?: noteHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteHistory
     */
    omit?: noteHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteHistoryInclude<ExtArgs> | null
    where?: noteHistoryWhereInput
    orderBy?: noteHistoryOrderByWithRelationInput | noteHistoryOrderByWithRelationInput[]
    cursor?: noteHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteHistoryScalarFieldEnum | NoteHistoryScalarFieldEnum[]
  }

  /**
   * notes.internalShares
   */
  export type notes$internalSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteInternalShare
     */
    select?: noteInternalShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteInternalShare
     */
    omit?: noteInternalShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteInternalShareInclude<ExtArgs> | null
    where?: noteInternalShareWhereInput
    orderBy?: noteInternalShareOrderByWithRelationInput | noteInternalShareOrderByWithRelationInput[]
    cursor?: noteInternalShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteInternalShareScalarFieldEnum | NoteInternalShareScalarFieldEnum[]
  }

  /**
   * notes without action
   */
  export type notesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notesInclude<ExtArgs> | null
  }


  /**
   * Model comments
   */

  export type AggregateComments = {
    _count: CommentsCountAggregateOutputType | null
    _avg: CommentsAvgAggregateOutputType | null
    _sum: CommentsSumAggregateOutputType | null
    _min: CommentsMinAggregateOutputType | null
    _max: CommentsMaxAggregateOutputType | null
  }

  export type CommentsAvgAggregateOutputType = {
    id: number | null
    accountId: number | null
    noteId: number | null
    parentId: number | null
  }

  export type CommentsSumAggregateOutputType = {
    id: number | null
    accountId: number | null
    noteId: number | null
    parentId: number | null
  }

  export type CommentsMinAggregateOutputType = {
    id: number | null
    content: string | null
    accountId: number | null
    guestName: string | null
    guestIP: string | null
    guestUA: string | null
    noteId: number | null
    parentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentsMaxAggregateOutputType = {
    id: number | null
    content: string | null
    accountId: number | null
    guestName: string | null
    guestIP: string | null
    guestUA: string | null
    noteId: number | null
    parentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentsCountAggregateOutputType = {
    id: number
    content: number
    accountId: number
    guestName: number
    guestIP: number
    guestUA: number
    noteId: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentsAvgAggregateInputType = {
    id?: true
    accountId?: true
    noteId?: true
    parentId?: true
  }

  export type CommentsSumAggregateInputType = {
    id?: true
    accountId?: true
    noteId?: true
    parentId?: true
  }

  export type CommentsMinAggregateInputType = {
    id?: true
    content?: true
    accountId?: true
    guestName?: true
    guestIP?: true
    guestUA?: true
    noteId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentsMaxAggregateInputType = {
    id?: true
    content?: true
    accountId?: true
    guestName?: true
    guestIP?: true
    guestUA?: true
    noteId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentsCountAggregateInputType = {
    id?: true
    content?: true
    accountId?: true
    guestName?: true
    guestIP?: true
    guestUA?: true
    noteId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comments to aggregate.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned comments
    **/
    _count?: true | CommentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentsMaxAggregateInputType
  }

  export type GetCommentsAggregateType<T extends CommentsAggregateArgs> = {
        [P in keyof T & keyof AggregateComments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComments[P]>
      : GetScalarType<T[P], AggregateComments[P]>
  }




  export type commentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentsWhereInput
    orderBy?: commentsOrderByWithAggregationInput | commentsOrderByWithAggregationInput[]
    by: CommentsScalarFieldEnum[] | CommentsScalarFieldEnum
    having?: commentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentsCountAggregateInputType | true
    _avg?: CommentsAvgAggregateInputType
    _sum?: CommentsSumAggregateInputType
    _min?: CommentsMinAggregateInputType
    _max?: CommentsMaxAggregateInputType
  }

  export type CommentsGroupByOutputType = {
    id: number
    content: string
    accountId: number | null
    guestName: string | null
    guestIP: string | null
    guestUA: string | null
    noteId: number
    parentId: number | null
    createdAt: Date
    updatedAt: Date
    _count: CommentsCountAggregateOutputType | null
    _avg: CommentsAvgAggregateOutputType | null
    _sum: CommentsSumAggregateOutputType | null
    _min: CommentsMinAggregateOutputType | null
    _max: CommentsMaxAggregateOutputType | null
  }

  type GetCommentsGroupByPayload<T extends commentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentsGroupByOutputType[P]>
            : GetScalarType<T[P], CommentsGroupByOutputType[P]>
        }
      >
    >


  export type commentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    accountId?: boolean
    guestName?: boolean
    guestIP?: boolean
    guestUA?: boolean
    noteId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    note?: boolean | notesDefaultArgs<ExtArgs>
    account?: boolean | comments$accountArgs<ExtArgs>
    parent?: boolean | comments$parentArgs<ExtArgs>
    replies?: boolean | comments$repliesArgs<ExtArgs>
    _count?: boolean | CommentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comments"]>

  export type commentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    accountId?: boolean
    guestName?: boolean
    guestIP?: boolean
    guestUA?: boolean
    noteId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    note?: boolean | notesDefaultArgs<ExtArgs>
    account?: boolean | comments$accountArgs<ExtArgs>
    parent?: boolean | comments$parentArgs<ExtArgs>
  }, ExtArgs["result"]["comments"]>

  export type commentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    accountId?: boolean
    guestName?: boolean
    guestIP?: boolean
    guestUA?: boolean
    noteId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    note?: boolean | notesDefaultArgs<ExtArgs>
    account?: boolean | comments$accountArgs<ExtArgs>
    parent?: boolean | comments$parentArgs<ExtArgs>
  }, ExtArgs["result"]["comments"]>

  export type commentsSelectScalar = {
    id?: boolean
    content?: boolean
    accountId?: boolean
    guestName?: boolean
    guestIP?: boolean
    guestUA?: boolean
    noteId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type commentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "accountId" | "guestName" | "guestIP" | "guestUA" | "noteId" | "parentId" | "createdAt" | "updatedAt", ExtArgs["result"]["comments"]>
  export type commentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note?: boolean | notesDefaultArgs<ExtArgs>
    account?: boolean | comments$accountArgs<ExtArgs>
    parent?: boolean | comments$parentArgs<ExtArgs>
    replies?: boolean | comments$repliesArgs<ExtArgs>
    _count?: boolean | CommentsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type commentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note?: boolean | notesDefaultArgs<ExtArgs>
    account?: boolean | comments$accountArgs<ExtArgs>
    parent?: boolean | comments$parentArgs<ExtArgs>
  }
  export type commentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note?: boolean | notesDefaultArgs<ExtArgs>
    account?: boolean | comments$accountArgs<ExtArgs>
    parent?: boolean | comments$parentArgs<ExtArgs>
  }

  export type $commentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "comments"
    objects: {
      note: Prisma.$notesPayload<ExtArgs>
      account: Prisma.$accountsPayload<ExtArgs> | null
      parent: Prisma.$commentsPayload<ExtArgs> | null
      replies: Prisma.$commentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      content: string
      accountId: number | null
      guestName: string | null
      guestIP: string | null
      guestUA: string | null
      noteId: number
      parentId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comments"]>
    composites: {}
  }

  type commentsGetPayload<S extends boolean | null | undefined | commentsDefaultArgs> = $Result.GetResult<Prisma.$commentsPayload, S>

  type commentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<commentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentsCountAggregateInputType | true
    }

  export interface commentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['comments'], meta: { name: 'comments' } }
    /**
     * Find zero or one Comments that matches the filter.
     * @param {commentsFindUniqueArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends commentsFindUniqueArgs>(args: SelectSubset<T, commentsFindUniqueArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {commentsFindUniqueOrThrowArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends commentsFindUniqueOrThrowArgs>(args: SelectSubset<T, commentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsFindFirstArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends commentsFindFirstArgs>(args?: SelectSubset<T, commentsFindFirstArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsFindFirstOrThrowArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends commentsFindFirstOrThrowArgs>(args?: SelectSubset<T, commentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comments.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentsWithIdOnly = await prisma.comments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends commentsFindManyArgs>(args?: SelectSubset<T, commentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comments.
     * @param {commentsCreateArgs} args - Arguments to create a Comments.
     * @example
     * // Create one Comments
     * const Comments = await prisma.comments.create({
     *   data: {
     *     // ... data to create a Comments
     *   }
     * })
     * 
     */
    create<T extends commentsCreateArgs>(args: SelectSubset<T, commentsCreateArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {commentsCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comments = await prisma.comments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends commentsCreateManyArgs>(args?: SelectSubset<T, commentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {commentsCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comments = await prisma.comments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentsWithIdOnly = await prisma.comments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends commentsCreateManyAndReturnArgs>(args?: SelectSubset<T, commentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comments.
     * @param {commentsDeleteArgs} args - Arguments to delete one Comments.
     * @example
     * // Delete one Comments
     * const Comments = await prisma.comments.delete({
     *   where: {
     *     // ... filter to delete one Comments
     *   }
     * })
     * 
     */
    delete<T extends commentsDeleteArgs>(args: SelectSubset<T, commentsDeleteArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comments.
     * @param {commentsUpdateArgs} args - Arguments to update one Comments.
     * @example
     * // Update one Comments
     * const comments = await prisma.comments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends commentsUpdateArgs>(args: SelectSubset<T, commentsUpdateArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {commentsDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends commentsDeleteManyArgs>(args?: SelectSubset<T, commentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comments = await prisma.comments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends commentsUpdateManyArgs>(args: SelectSubset<T, commentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {commentsUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comments = await prisma.comments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentsWithIdOnly = await prisma.comments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends commentsUpdateManyAndReturnArgs>(args: SelectSubset<T, commentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comments.
     * @param {commentsUpsertArgs} args - Arguments to update or create a Comments.
     * @example
     * // Update or create a Comments
     * const comments = await prisma.comments.upsert({
     *   create: {
     *     // ... data to create a Comments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comments we want to update
     *   }
     * })
     */
    upsert<T extends commentsUpsertArgs>(args: SelectSubset<T, commentsUpsertArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comments.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends commentsCountArgs>(
      args?: Subset<T, commentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentsAggregateArgs>(args: Subset<T, CommentsAggregateArgs>): Prisma.PrismaPromise<GetCommentsAggregateType<T>>

    /**
     * Group by Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends commentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: commentsGroupByArgs['orderBy'] }
        : { orderBy?: commentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, commentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the comments model
   */
  readonly fields: commentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for comments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__commentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    note<T extends notesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, notesDefaultArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    account<T extends comments$accountArgs<ExtArgs> = {}>(args?: Subset<T, comments$accountArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    parent<T extends comments$parentArgs<ExtArgs> = {}>(args?: Subset<T, comments$parentArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    replies<T extends comments$repliesArgs<ExtArgs> = {}>(args?: Subset<T, comments$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the comments model
   */
  interface commentsFieldRefs {
    readonly id: FieldRef<"comments", 'Int'>
    readonly content: FieldRef<"comments", 'String'>
    readonly accountId: FieldRef<"comments", 'Int'>
    readonly guestName: FieldRef<"comments", 'String'>
    readonly guestIP: FieldRef<"comments", 'String'>
    readonly guestUA: FieldRef<"comments", 'String'>
    readonly noteId: FieldRef<"comments", 'Int'>
    readonly parentId: FieldRef<"comments", 'Int'>
    readonly createdAt: FieldRef<"comments", 'DateTime'>
    readonly updatedAt: FieldRef<"comments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * comments findUnique
   */
  export type commentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where: commentsWhereUniqueInput
  }

  /**
   * comments findUniqueOrThrow
   */
  export type commentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where: commentsWhereUniqueInput
  }

  /**
   * comments findFirst
   */
  export type commentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comments.
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comments.
     */
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * comments findFirstOrThrow
   */
  export type commentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comments.
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comments.
     */
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * comments findMany
   */
  export type commentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing comments.
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * comments create
   */
  export type commentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * The data needed to create a comments.
     */
    data: XOR<commentsCreateInput, commentsUncheckedCreateInput>
  }

  /**
   * comments createMany
   */
  export type commentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many comments.
     */
    data: commentsCreateManyInput | commentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * comments createManyAndReturn
   */
  export type commentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * The data used to create many comments.
     */
    data: commentsCreateManyInput | commentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * comments update
   */
  export type commentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * The data needed to update a comments.
     */
    data: XOR<commentsUpdateInput, commentsUncheckedUpdateInput>
    /**
     * Choose, which comments to update.
     */
    where: commentsWhereUniqueInput
  }

  /**
   * comments updateMany
   */
  export type commentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update comments.
     */
    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyInput>
    /**
     * Filter which comments to update
     */
    where?: commentsWhereInput
    /**
     * Limit how many comments to update.
     */
    limit?: number
  }

  /**
   * comments updateManyAndReturn
   */
  export type commentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * The data used to update comments.
     */
    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyInput>
    /**
     * Filter which comments to update
     */
    where?: commentsWhereInput
    /**
     * Limit how many comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * comments upsert
   */
  export type commentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * The filter to search for the comments to update in case it exists.
     */
    where: commentsWhereUniqueInput
    /**
     * In case the comments found by the `where` argument doesn't exist, create a new comments with this data.
     */
    create: XOR<commentsCreateInput, commentsUncheckedCreateInput>
    /**
     * In case the comments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<commentsUpdateInput, commentsUncheckedUpdateInput>
  }

  /**
   * comments delete
   */
  export type commentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter which comments to delete.
     */
    where: commentsWhereUniqueInput
  }

  /**
   * comments deleteMany
   */
  export type commentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comments to delete
     */
    where?: commentsWhereInput
    /**
     * Limit how many comments to delete.
     */
    limit?: number
  }

  /**
   * comments.account
   */
  export type comments$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    where?: accountsWhereInput
  }

  /**
   * comments.parent
   */
  export type comments$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    where?: commentsWhereInput
  }

  /**
   * comments.replies
   */
  export type comments$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    where?: commentsWhereInput
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    cursor?: commentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * comments without action
   */
  export type commentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
  }


  /**
   * Model tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagAvgAggregateOutputType = {
    id: number | null
    parent: number | null
    accountId: number | null
    sortOrder: number | null
  }

  export type TagSumAggregateOutputType = {
    id: number | null
    parent: number | null
    accountId: number | null
    sortOrder: number | null
  }

  export type TagMinAggregateOutputType = {
    id: number | null
    name: string | null
    icon: string | null
    parent: number | null
    accountId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    sortOrder: number | null
  }

  export type TagMaxAggregateOutputType = {
    id: number | null
    name: string | null
    icon: string | null
    parent: number | null
    accountId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    sortOrder: number | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    icon: number
    parent: number
    accountId: number
    createdAt: number
    updatedAt: number
    sortOrder: number
    _all: number
  }


  export type TagAvgAggregateInputType = {
    id?: true
    parent?: true
    accountId?: true
    sortOrder?: true
  }

  export type TagSumAggregateInputType = {
    id?: true
    parent?: true
    accountId?: true
    sortOrder?: true
  }

  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    parent?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
    sortOrder?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    parent?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
    sortOrder?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    parent?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
    sortOrder?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tag to aggregate.
     */
    where?: tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagOrderByWithRelationInput | tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type tagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tagWhereInput
    orderBy?: tagOrderByWithAggregationInput | tagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: tagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _avg?: TagAvgAggregateInputType
    _sum?: TagSumAggregateInputType
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: number
    name: string
    icon: string
    parent: number
    accountId: number | null
    createdAt: Date
    updatedAt: Date
    sortOrder: number
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends tagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type tagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    parent?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sortOrder?: boolean
    tagsToNote?: boolean | tag$tagsToNoteArgs<ExtArgs>
    account?: boolean | tag$accountArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type tagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    parent?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sortOrder?: boolean
    account?: boolean | tag$accountArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type tagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    parent?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sortOrder?: boolean
    account?: boolean | tag$accountArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type tagSelectScalar = {
    id?: boolean
    name?: boolean
    icon?: boolean
    parent?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sortOrder?: boolean
  }

  export type tagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "icon" | "parent" | "accountId" | "createdAt" | "updatedAt" | "sortOrder", ExtArgs["result"]["tag"]>
  export type tagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tagsToNote?: boolean | tag$tagsToNoteArgs<ExtArgs>
    account?: boolean | tag$accountArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | tag$accountArgs<ExtArgs>
  }
  export type tagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | tag$accountArgs<ExtArgs>
  }

  export type $tagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tag"
    objects: {
      tagsToNote: Prisma.$tagsToNotePayload<ExtArgs>[]
      account: Prisma.$accountsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      icon: string
      parent: number
      accountId: number | null
      createdAt: Date
      updatedAt: Date
      sortOrder: number
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type tagGetPayload<S extends boolean | null | undefined | tagDefaultArgs> = $Result.GetResult<Prisma.$tagPayload, S>

  type tagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface tagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tag'], meta: { name: 'tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {tagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tagFindUniqueArgs>(args: SelectSubset<T, tagFindUniqueArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tagFindUniqueOrThrowArgs>(args: SelectSubset<T, tagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tagFindFirstArgs>(args?: SelectSubset<T, tagFindFirstArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tagFindFirstOrThrowArgs>(args?: SelectSubset<T, tagFindFirstOrThrowArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tagFindManyArgs>(args?: SelectSubset<T, tagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {tagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends tagCreateArgs>(args: SelectSubset<T, tagCreateArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {tagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tagCreateManyArgs>(args?: SelectSubset<T, tagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {tagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tagCreateManyAndReturnArgs>(args?: SelectSubset<T, tagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {tagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends tagDeleteArgs>(args: SelectSubset<T, tagDeleteArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {tagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tagUpdateArgs>(args: SelectSubset<T, tagUpdateArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {tagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tagDeleteManyArgs>(args?: SelectSubset<T, tagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tagUpdateManyArgs>(args: SelectSubset<T, tagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {tagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tagUpdateManyAndReturnArgs>(args: SelectSubset<T, tagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {tagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends tagUpsertArgs>(args: SelectSubset<T, tagUpsertArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends tagCountArgs>(
      args?: Subset<T, tagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tagGroupByArgs['orderBy'] }
        : { orderBy?: tagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tag model
   */
  readonly fields: tagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tagsToNote<T extends tag$tagsToNoteArgs<ExtArgs> = {}>(args?: Subset<T, tag$tagsToNoteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagsToNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    account<T extends tag$accountArgs<ExtArgs> = {}>(args?: Subset<T, tag$accountArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tag model
   */
  interface tagFieldRefs {
    readonly id: FieldRef<"tag", 'Int'>
    readonly name: FieldRef<"tag", 'String'>
    readonly icon: FieldRef<"tag", 'String'>
    readonly parent: FieldRef<"tag", 'Int'>
    readonly accountId: FieldRef<"tag", 'Int'>
    readonly createdAt: FieldRef<"tag", 'DateTime'>
    readonly updatedAt: FieldRef<"tag", 'DateTime'>
    readonly sortOrder: FieldRef<"tag", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tag findUnique
   */
  export type tagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tag
     */
    omit?: tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * Filter, which tag to fetch.
     */
    where: tagWhereUniqueInput
  }

  /**
   * tag findUniqueOrThrow
   */
  export type tagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tag
     */
    omit?: tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * Filter, which tag to fetch.
     */
    where: tagWhereUniqueInput
  }

  /**
   * tag findFirst
   */
  export type tagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tag
     */
    omit?: tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * Filter, which tag to fetch.
     */
    where?: tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagOrderByWithRelationInput | tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tags.
     */
    cursor?: tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * tag findFirstOrThrow
   */
  export type tagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tag
     */
    omit?: tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * Filter, which tag to fetch.
     */
    where?: tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagOrderByWithRelationInput | tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tags.
     */
    cursor?: tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * tag findMany
   */
  export type tagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tag
     */
    omit?: tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where?: tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagOrderByWithRelationInput | tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tags.
     */
    cursor?: tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * tag create
   */
  export type tagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tag
     */
    omit?: tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * The data needed to create a tag.
     */
    data: XOR<tagCreateInput, tagUncheckedCreateInput>
  }

  /**
   * tag createMany
   */
  export type tagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tags.
     */
    data: tagCreateManyInput | tagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tag createManyAndReturn
   */
  export type tagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tag
     */
    omit?: tagOmit<ExtArgs> | null
    /**
     * The data used to create many tags.
     */
    data: tagCreateManyInput | tagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tag update
   */
  export type tagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tag
     */
    omit?: tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * The data needed to update a tag.
     */
    data: XOR<tagUpdateInput, tagUncheckedUpdateInput>
    /**
     * Choose, which tag to update.
     */
    where: tagWhereUniqueInput
  }

  /**
   * tag updateMany
   */
  export type tagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tags.
     */
    data: XOR<tagUpdateManyMutationInput, tagUncheckedUpdateManyInput>
    /**
     * Filter which tags to update
     */
    where?: tagWhereInput
    /**
     * Limit how many tags to update.
     */
    limit?: number
  }

  /**
   * tag updateManyAndReturn
   */
  export type tagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tag
     */
    omit?: tagOmit<ExtArgs> | null
    /**
     * The data used to update tags.
     */
    data: XOR<tagUpdateManyMutationInput, tagUncheckedUpdateManyInput>
    /**
     * Filter which tags to update
     */
    where?: tagWhereInput
    /**
     * Limit how many tags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * tag upsert
   */
  export type tagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tag
     */
    omit?: tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * The filter to search for the tag to update in case it exists.
     */
    where: tagWhereUniqueInput
    /**
     * In case the tag found by the `where` argument doesn't exist, create a new tag with this data.
     */
    create: XOR<tagCreateInput, tagUncheckedCreateInput>
    /**
     * In case the tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tagUpdateInput, tagUncheckedUpdateInput>
  }

  /**
   * tag delete
   */
  export type tagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tag
     */
    omit?: tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * Filter which tag to delete.
     */
    where: tagWhereUniqueInput
  }

  /**
   * tag deleteMany
   */
  export type tagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tags to delete
     */
    where?: tagWhereInput
    /**
     * Limit how many tags to delete.
     */
    limit?: number
  }

  /**
   * tag.tagsToNote
   */
  export type tag$tagsToNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tagsToNote
     */
    select?: tagsToNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tagsToNote
     */
    omit?: tagsToNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsToNoteInclude<ExtArgs> | null
    where?: tagsToNoteWhereInput
    orderBy?: tagsToNoteOrderByWithRelationInput | tagsToNoteOrderByWithRelationInput[]
    cursor?: tagsToNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagsToNoteScalarFieldEnum | TagsToNoteScalarFieldEnum[]
  }

  /**
   * tag.account
   */
  export type tag$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    where?: accountsWhereInput
  }

  /**
   * tag without action
   */
  export type tagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tag
     */
    omit?: tagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
  }


  /**
   * Model tagsToNote
   */

  export type AggregateTagsToNote = {
    _count: TagsToNoteCountAggregateOutputType | null
    _avg: TagsToNoteAvgAggregateOutputType | null
    _sum: TagsToNoteSumAggregateOutputType | null
    _min: TagsToNoteMinAggregateOutputType | null
    _max: TagsToNoteMaxAggregateOutputType | null
  }

  export type TagsToNoteAvgAggregateOutputType = {
    id: number | null
    noteId: number | null
    tagId: number | null
  }

  export type TagsToNoteSumAggregateOutputType = {
    id: number | null
    noteId: number | null
    tagId: number | null
  }

  export type TagsToNoteMinAggregateOutputType = {
    id: number | null
    noteId: number | null
    tagId: number | null
  }

  export type TagsToNoteMaxAggregateOutputType = {
    id: number | null
    noteId: number | null
    tagId: number | null
  }

  export type TagsToNoteCountAggregateOutputType = {
    id: number
    noteId: number
    tagId: number
    _all: number
  }


  export type TagsToNoteAvgAggregateInputType = {
    id?: true
    noteId?: true
    tagId?: true
  }

  export type TagsToNoteSumAggregateInputType = {
    id?: true
    noteId?: true
    tagId?: true
  }

  export type TagsToNoteMinAggregateInputType = {
    id?: true
    noteId?: true
    tagId?: true
  }

  export type TagsToNoteMaxAggregateInputType = {
    id?: true
    noteId?: true
    tagId?: true
  }

  export type TagsToNoteCountAggregateInputType = {
    id?: true
    noteId?: true
    tagId?: true
    _all?: true
  }

  export type TagsToNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tagsToNote to aggregate.
     */
    where?: tagsToNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tagsToNotes to fetch.
     */
    orderBy?: tagsToNoteOrderByWithRelationInput | tagsToNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tagsToNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tagsToNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tagsToNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tagsToNotes
    **/
    _count?: true | TagsToNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagsToNoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagsToNoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagsToNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagsToNoteMaxAggregateInputType
  }

  export type GetTagsToNoteAggregateType<T extends TagsToNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateTagsToNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTagsToNote[P]>
      : GetScalarType<T[P], AggregateTagsToNote[P]>
  }




  export type tagsToNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tagsToNoteWhereInput
    orderBy?: tagsToNoteOrderByWithAggregationInput | tagsToNoteOrderByWithAggregationInput[]
    by: TagsToNoteScalarFieldEnum[] | TagsToNoteScalarFieldEnum
    having?: tagsToNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagsToNoteCountAggregateInputType | true
    _avg?: TagsToNoteAvgAggregateInputType
    _sum?: TagsToNoteSumAggregateInputType
    _min?: TagsToNoteMinAggregateInputType
    _max?: TagsToNoteMaxAggregateInputType
  }

  export type TagsToNoteGroupByOutputType = {
    id: number
    noteId: number
    tagId: number
    _count: TagsToNoteCountAggregateOutputType | null
    _avg: TagsToNoteAvgAggregateOutputType | null
    _sum: TagsToNoteSumAggregateOutputType | null
    _min: TagsToNoteMinAggregateOutputType | null
    _max: TagsToNoteMaxAggregateOutputType | null
  }

  type GetTagsToNoteGroupByPayload<T extends tagsToNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagsToNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagsToNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagsToNoteGroupByOutputType[P]>
            : GetScalarType<T[P], TagsToNoteGroupByOutputType[P]>
        }
      >
    >


  export type tagsToNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    noteId?: boolean
    tagId?: boolean
    note?: boolean | notesDefaultArgs<ExtArgs>
    tag?: boolean | tagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tagsToNote"]>

  export type tagsToNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    noteId?: boolean
    tagId?: boolean
    note?: boolean | notesDefaultArgs<ExtArgs>
    tag?: boolean | tagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tagsToNote"]>

  export type tagsToNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    noteId?: boolean
    tagId?: boolean
    note?: boolean | notesDefaultArgs<ExtArgs>
    tag?: boolean | tagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tagsToNote"]>

  export type tagsToNoteSelectScalar = {
    id?: boolean
    noteId?: boolean
    tagId?: boolean
  }

  export type tagsToNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "noteId" | "tagId", ExtArgs["result"]["tagsToNote"]>
  export type tagsToNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note?: boolean | notesDefaultArgs<ExtArgs>
    tag?: boolean | tagDefaultArgs<ExtArgs>
  }
  export type tagsToNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note?: boolean | notesDefaultArgs<ExtArgs>
    tag?: boolean | tagDefaultArgs<ExtArgs>
  }
  export type tagsToNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note?: boolean | notesDefaultArgs<ExtArgs>
    tag?: boolean | tagDefaultArgs<ExtArgs>
  }

  export type $tagsToNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tagsToNote"
    objects: {
      note: Prisma.$notesPayload<ExtArgs>
      tag: Prisma.$tagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      noteId: number
      tagId: number
    }, ExtArgs["result"]["tagsToNote"]>
    composites: {}
  }

  type tagsToNoteGetPayload<S extends boolean | null | undefined | tagsToNoteDefaultArgs> = $Result.GetResult<Prisma.$tagsToNotePayload, S>

  type tagsToNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tagsToNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagsToNoteCountAggregateInputType | true
    }

  export interface tagsToNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tagsToNote'], meta: { name: 'tagsToNote' } }
    /**
     * Find zero or one TagsToNote that matches the filter.
     * @param {tagsToNoteFindUniqueArgs} args - Arguments to find a TagsToNote
     * @example
     * // Get one TagsToNote
     * const tagsToNote = await prisma.tagsToNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tagsToNoteFindUniqueArgs>(args: SelectSubset<T, tagsToNoteFindUniqueArgs<ExtArgs>>): Prisma__tagsToNoteClient<$Result.GetResult<Prisma.$tagsToNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TagsToNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tagsToNoteFindUniqueOrThrowArgs} args - Arguments to find a TagsToNote
     * @example
     * // Get one TagsToNote
     * const tagsToNote = await prisma.tagsToNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tagsToNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, tagsToNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tagsToNoteClient<$Result.GetResult<Prisma.$tagsToNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TagsToNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsToNoteFindFirstArgs} args - Arguments to find a TagsToNote
     * @example
     * // Get one TagsToNote
     * const tagsToNote = await prisma.tagsToNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tagsToNoteFindFirstArgs>(args?: SelectSubset<T, tagsToNoteFindFirstArgs<ExtArgs>>): Prisma__tagsToNoteClient<$Result.GetResult<Prisma.$tagsToNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TagsToNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsToNoteFindFirstOrThrowArgs} args - Arguments to find a TagsToNote
     * @example
     * // Get one TagsToNote
     * const tagsToNote = await prisma.tagsToNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tagsToNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, tagsToNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__tagsToNoteClient<$Result.GetResult<Prisma.$tagsToNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TagsToNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsToNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TagsToNotes
     * const tagsToNotes = await prisma.tagsToNote.findMany()
     * 
     * // Get first 10 TagsToNotes
     * const tagsToNotes = await prisma.tagsToNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagsToNoteWithIdOnly = await prisma.tagsToNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tagsToNoteFindManyArgs>(args?: SelectSubset<T, tagsToNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagsToNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TagsToNote.
     * @param {tagsToNoteCreateArgs} args - Arguments to create a TagsToNote.
     * @example
     * // Create one TagsToNote
     * const TagsToNote = await prisma.tagsToNote.create({
     *   data: {
     *     // ... data to create a TagsToNote
     *   }
     * })
     * 
     */
    create<T extends tagsToNoteCreateArgs>(args: SelectSubset<T, tagsToNoteCreateArgs<ExtArgs>>): Prisma__tagsToNoteClient<$Result.GetResult<Prisma.$tagsToNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TagsToNotes.
     * @param {tagsToNoteCreateManyArgs} args - Arguments to create many TagsToNotes.
     * @example
     * // Create many TagsToNotes
     * const tagsToNote = await prisma.tagsToNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tagsToNoteCreateManyArgs>(args?: SelectSubset<T, tagsToNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TagsToNotes and returns the data saved in the database.
     * @param {tagsToNoteCreateManyAndReturnArgs} args - Arguments to create many TagsToNotes.
     * @example
     * // Create many TagsToNotes
     * const tagsToNote = await prisma.tagsToNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TagsToNotes and only return the `id`
     * const tagsToNoteWithIdOnly = await prisma.tagsToNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tagsToNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, tagsToNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagsToNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TagsToNote.
     * @param {tagsToNoteDeleteArgs} args - Arguments to delete one TagsToNote.
     * @example
     * // Delete one TagsToNote
     * const TagsToNote = await prisma.tagsToNote.delete({
     *   where: {
     *     // ... filter to delete one TagsToNote
     *   }
     * })
     * 
     */
    delete<T extends tagsToNoteDeleteArgs>(args: SelectSubset<T, tagsToNoteDeleteArgs<ExtArgs>>): Prisma__tagsToNoteClient<$Result.GetResult<Prisma.$tagsToNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TagsToNote.
     * @param {tagsToNoteUpdateArgs} args - Arguments to update one TagsToNote.
     * @example
     * // Update one TagsToNote
     * const tagsToNote = await prisma.tagsToNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tagsToNoteUpdateArgs>(args: SelectSubset<T, tagsToNoteUpdateArgs<ExtArgs>>): Prisma__tagsToNoteClient<$Result.GetResult<Prisma.$tagsToNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TagsToNotes.
     * @param {tagsToNoteDeleteManyArgs} args - Arguments to filter TagsToNotes to delete.
     * @example
     * // Delete a few TagsToNotes
     * const { count } = await prisma.tagsToNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tagsToNoteDeleteManyArgs>(args?: SelectSubset<T, tagsToNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TagsToNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsToNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TagsToNotes
     * const tagsToNote = await prisma.tagsToNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tagsToNoteUpdateManyArgs>(args: SelectSubset<T, tagsToNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TagsToNotes and returns the data updated in the database.
     * @param {tagsToNoteUpdateManyAndReturnArgs} args - Arguments to update many TagsToNotes.
     * @example
     * // Update many TagsToNotes
     * const tagsToNote = await prisma.tagsToNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TagsToNotes and only return the `id`
     * const tagsToNoteWithIdOnly = await prisma.tagsToNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tagsToNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, tagsToNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagsToNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TagsToNote.
     * @param {tagsToNoteUpsertArgs} args - Arguments to update or create a TagsToNote.
     * @example
     * // Update or create a TagsToNote
     * const tagsToNote = await prisma.tagsToNote.upsert({
     *   create: {
     *     // ... data to create a TagsToNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TagsToNote we want to update
     *   }
     * })
     */
    upsert<T extends tagsToNoteUpsertArgs>(args: SelectSubset<T, tagsToNoteUpsertArgs<ExtArgs>>): Prisma__tagsToNoteClient<$Result.GetResult<Prisma.$tagsToNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TagsToNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsToNoteCountArgs} args - Arguments to filter TagsToNotes to count.
     * @example
     * // Count the number of TagsToNotes
     * const count = await prisma.tagsToNote.count({
     *   where: {
     *     // ... the filter for the TagsToNotes we want to count
     *   }
     * })
    **/
    count<T extends tagsToNoteCountArgs>(
      args?: Subset<T, tagsToNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagsToNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TagsToNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsToNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagsToNoteAggregateArgs>(args: Subset<T, TagsToNoteAggregateArgs>): Prisma.PrismaPromise<GetTagsToNoteAggregateType<T>>

    /**
     * Group by TagsToNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsToNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tagsToNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tagsToNoteGroupByArgs['orderBy'] }
        : { orderBy?: tagsToNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tagsToNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagsToNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tagsToNote model
   */
  readonly fields: tagsToNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tagsToNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tagsToNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    note<T extends notesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, notesDefaultArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends tagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tagDefaultArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tagsToNote model
   */
  interface tagsToNoteFieldRefs {
    readonly id: FieldRef<"tagsToNote", 'Int'>
    readonly noteId: FieldRef<"tagsToNote", 'Int'>
    readonly tagId: FieldRef<"tagsToNote", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tagsToNote findUnique
   */
  export type tagsToNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tagsToNote
     */
    select?: tagsToNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tagsToNote
     */
    omit?: tagsToNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsToNoteInclude<ExtArgs> | null
    /**
     * Filter, which tagsToNote to fetch.
     */
    where: tagsToNoteWhereUniqueInput
  }

  /**
   * tagsToNote findUniqueOrThrow
   */
  export type tagsToNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tagsToNote
     */
    select?: tagsToNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tagsToNote
     */
    omit?: tagsToNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsToNoteInclude<ExtArgs> | null
    /**
     * Filter, which tagsToNote to fetch.
     */
    where: tagsToNoteWhereUniqueInput
  }

  /**
   * tagsToNote findFirst
   */
  export type tagsToNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tagsToNote
     */
    select?: tagsToNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tagsToNote
     */
    omit?: tagsToNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsToNoteInclude<ExtArgs> | null
    /**
     * Filter, which tagsToNote to fetch.
     */
    where?: tagsToNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tagsToNotes to fetch.
     */
    orderBy?: tagsToNoteOrderByWithRelationInput | tagsToNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tagsToNotes.
     */
    cursor?: tagsToNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tagsToNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tagsToNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tagsToNotes.
     */
    distinct?: TagsToNoteScalarFieldEnum | TagsToNoteScalarFieldEnum[]
  }

  /**
   * tagsToNote findFirstOrThrow
   */
  export type tagsToNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tagsToNote
     */
    select?: tagsToNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tagsToNote
     */
    omit?: tagsToNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsToNoteInclude<ExtArgs> | null
    /**
     * Filter, which tagsToNote to fetch.
     */
    where?: tagsToNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tagsToNotes to fetch.
     */
    orderBy?: tagsToNoteOrderByWithRelationInput | tagsToNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tagsToNotes.
     */
    cursor?: tagsToNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tagsToNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tagsToNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tagsToNotes.
     */
    distinct?: TagsToNoteScalarFieldEnum | TagsToNoteScalarFieldEnum[]
  }

  /**
   * tagsToNote findMany
   */
  export type tagsToNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tagsToNote
     */
    select?: tagsToNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tagsToNote
     */
    omit?: tagsToNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsToNoteInclude<ExtArgs> | null
    /**
     * Filter, which tagsToNotes to fetch.
     */
    where?: tagsToNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tagsToNotes to fetch.
     */
    orderBy?: tagsToNoteOrderByWithRelationInput | tagsToNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tagsToNotes.
     */
    cursor?: tagsToNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tagsToNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tagsToNotes.
     */
    skip?: number
    distinct?: TagsToNoteScalarFieldEnum | TagsToNoteScalarFieldEnum[]
  }

  /**
   * tagsToNote create
   */
  export type tagsToNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tagsToNote
     */
    select?: tagsToNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tagsToNote
     */
    omit?: tagsToNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsToNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a tagsToNote.
     */
    data: XOR<tagsToNoteCreateInput, tagsToNoteUncheckedCreateInput>
  }

  /**
   * tagsToNote createMany
   */
  export type tagsToNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tagsToNotes.
     */
    data: tagsToNoteCreateManyInput | tagsToNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tagsToNote createManyAndReturn
   */
  export type tagsToNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tagsToNote
     */
    select?: tagsToNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tagsToNote
     */
    omit?: tagsToNoteOmit<ExtArgs> | null
    /**
     * The data used to create many tagsToNotes.
     */
    data: tagsToNoteCreateManyInput | tagsToNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsToNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tagsToNote update
   */
  export type tagsToNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tagsToNote
     */
    select?: tagsToNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tagsToNote
     */
    omit?: tagsToNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsToNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a tagsToNote.
     */
    data: XOR<tagsToNoteUpdateInput, tagsToNoteUncheckedUpdateInput>
    /**
     * Choose, which tagsToNote to update.
     */
    where: tagsToNoteWhereUniqueInput
  }

  /**
   * tagsToNote updateMany
   */
  export type tagsToNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tagsToNotes.
     */
    data: XOR<tagsToNoteUpdateManyMutationInput, tagsToNoteUncheckedUpdateManyInput>
    /**
     * Filter which tagsToNotes to update
     */
    where?: tagsToNoteWhereInput
    /**
     * Limit how many tagsToNotes to update.
     */
    limit?: number
  }

  /**
   * tagsToNote updateManyAndReturn
   */
  export type tagsToNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tagsToNote
     */
    select?: tagsToNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tagsToNote
     */
    omit?: tagsToNoteOmit<ExtArgs> | null
    /**
     * The data used to update tagsToNotes.
     */
    data: XOR<tagsToNoteUpdateManyMutationInput, tagsToNoteUncheckedUpdateManyInput>
    /**
     * Filter which tagsToNotes to update
     */
    where?: tagsToNoteWhereInput
    /**
     * Limit how many tagsToNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsToNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * tagsToNote upsert
   */
  export type tagsToNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tagsToNote
     */
    select?: tagsToNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tagsToNote
     */
    omit?: tagsToNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsToNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the tagsToNote to update in case it exists.
     */
    where: tagsToNoteWhereUniqueInput
    /**
     * In case the tagsToNote found by the `where` argument doesn't exist, create a new tagsToNote with this data.
     */
    create: XOR<tagsToNoteCreateInput, tagsToNoteUncheckedCreateInput>
    /**
     * In case the tagsToNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tagsToNoteUpdateInput, tagsToNoteUncheckedUpdateInput>
  }

  /**
   * tagsToNote delete
   */
  export type tagsToNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tagsToNote
     */
    select?: tagsToNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tagsToNote
     */
    omit?: tagsToNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsToNoteInclude<ExtArgs> | null
    /**
     * Filter which tagsToNote to delete.
     */
    where: tagsToNoteWhereUniqueInput
  }

  /**
   * tagsToNote deleteMany
   */
  export type tagsToNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tagsToNotes to delete
     */
    where?: tagsToNoteWhereInput
    /**
     * Limit how many tagsToNotes to delete.
     */
    limit?: number
  }

  /**
   * tagsToNote without action
   */
  export type tagsToNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tagsToNote
     */
    select?: tagsToNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tagsToNote
     */
    omit?: tagsToNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsToNoteInclude<ExtArgs> | null
  }


  /**
   * Model noteReference
   */

  export type AggregateNoteReference = {
    _count: NoteReferenceCountAggregateOutputType | null
    _avg: NoteReferenceAvgAggregateOutputType | null
    _sum: NoteReferenceSumAggregateOutputType | null
    _min: NoteReferenceMinAggregateOutputType | null
    _max: NoteReferenceMaxAggregateOutputType | null
  }

  export type NoteReferenceAvgAggregateOutputType = {
    id: number | null
    fromNoteId: number | null
    toNoteId: number | null
  }

  export type NoteReferenceSumAggregateOutputType = {
    id: number | null
    fromNoteId: number | null
    toNoteId: number | null
  }

  export type NoteReferenceMinAggregateOutputType = {
    id: number | null
    fromNoteId: number | null
    toNoteId: number | null
    createdAt: Date | null
  }

  export type NoteReferenceMaxAggregateOutputType = {
    id: number | null
    fromNoteId: number | null
    toNoteId: number | null
    createdAt: Date | null
  }

  export type NoteReferenceCountAggregateOutputType = {
    id: number
    fromNoteId: number
    toNoteId: number
    createdAt: number
    _all: number
  }


  export type NoteReferenceAvgAggregateInputType = {
    id?: true
    fromNoteId?: true
    toNoteId?: true
  }

  export type NoteReferenceSumAggregateInputType = {
    id?: true
    fromNoteId?: true
    toNoteId?: true
  }

  export type NoteReferenceMinAggregateInputType = {
    id?: true
    fromNoteId?: true
    toNoteId?: true
    createdAt?: true
  }

  export type NoteReferenceMaxAggregateInputType = {
    id?: true
    fromNoteId?: true
    toNoteId?: true
    createdAt?: true
  }

  export type NoteReferenceCountAggregateInputType = {
    id?: true
    fromNoteId?: true
    toNoteId?: true
    createdAt?: true
    _all?: true
  }

  export type NoteReferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which noteReference to aggregate.
     */
    where?: noteReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of noteReferences to fetch.
     */
    orderBy?: noteReferenceOrderByWithRelationInput | noteReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: noteReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` noteReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` noteReferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned noteReferences
    **/
    _count?: true | NoteReferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoteReferenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoteReferenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoteReferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoteReferenceMaxAggregateInputType
  }

  export type GetNoteReferenceAggregateType<T extends NoteReferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateNoteReference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNoteReference[P]>
      : GetScalarType<T[P], AggregateNoteReference[P]>
  }




  export type noteReferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: noteReferenceWhereInput
    orderBy?: noteReferenceOrderByWithAggregationInput | noteReferenceOrderByWithAggregationInput[]
    by: NoteReferenceScalarFieldEnum[] | NoteReferenceScalarFieldEnum
    having?: noteReferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoteReferenceCountAggregateInputType | true
    _avg?: NoteReferenceAvgAggregateInputType
    _sum?: NoteReferenceSumAggregateInputType
    _min?: NoteReferenceMinAggregateInputType
    _max?: NoteReferenceMaxAggregateInputType
  }

  export type NoteReferenceGroupByOutputType = {
    id: number
    fromNoteId: number
    toNoteId: number
    createdAt: Date
    _count: NoteReferenceCountAggregateOutputType | null
    _avg: NoteReferenceAvgAggregateOutputType | null
    _sum: NoteReferenceSumAggregateOutputType | null
    _min: NoteReferenceMinAggregateOutputType | null
    _max: NoteReferenceMaxAggregateOutputType | null
  }

  type GetNoteReferenceGroupByPayload<T extends noteReferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoteReferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoteReferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoteReferenceGroupByOutputType[P]>
            : GetScalarType<T[P], NoteReferenceGroupByOutputType[P]>
        }
      >
    >


  export type noteReferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromNoteId?: boolean
    toNoteId?: boolean
    createdAt?: boolean
    fromNote?: boolean | notesDefaultArgs<ExtArgs>
    toNote?: boolean | notesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["noteReference"]>

  export type noteReferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromNoteId?: boolean
    toNoteId?: boolean
    createdAt?: boolean
    fromNote?: boolean | notesDefaultArgs<ExtArgs>
    toNote?: boolean | notesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["noteReference"]>

  export type noteReferenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromNoteId?: boolean
    toNoteId?: boolean
    createdAt?: boolean
    fromNote?: boolean | notesDefaultArgs<ExtArgs>
    toNote?: boolean | notesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["noteReference"]>

  export type noteReferenceSelectScalar = {
    id?: boolean
    fromNoteId?: boolean
    toNoteId?: boolean
    createdAt?: boolean
  }

  export type noteReferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fromNoteId" | "toNoteId" | "createdAt", ExtArgs["result"]["noteReference"]>
  export type noteReferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromNote?: boolean | notesDefaultArgs<ExtArgs>
    toNote?: boolean | notesDefaultArgs<ExtArgs>
  }
  export type noteReferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromNote?: boolean | notesDefaultArgs<ExtArgs>
    toNote?: boolean | notesDefaultArgs<ExtArgs>
  }
  export type noteReferenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromNote?: boolean | notesDefaultArgs<ExtArgs>
    toNote?: boolean | notesDefaultArgs<ExtArgs>
  }

  export type $noteReferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "noteReference"
    objects: {
      fromNote: Prisma.$notesPayload<ExtArgs>
      toNote: Prisma.$notesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fromNoteId: number
      toNoteId: number
      createdAt: Date
    }, ExtArgs["result"]["noteReference"]>
    composites: {}
  }

  type noteReferenceGetPayload<S extends boolean | null | undefined | noteReferenceDefaultArgs> = $Result.GetResult<Prisma.$noteReferencePayload, S>

  type noteReferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<noteReferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NoteReferenceCountAggregateInputType | true
    }

  export interface noteReferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['noteReference'], meta: { name: 'noteReference' } }
    /**
     * Find zero or one NoteReference that matches the filter.
     * @param {noteReferenceFindUniqueArgs} args - Arguments to find a NoteReference
     * @example
     * // Get one NoteReference
     * const noteReference = await prisma.noteReference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends noteReferenceFindUniqueArgs>(args: SelectSubset<T, noteReferenceFindUniqueArgs<ExtArgs>>): Prisma__noteReferenceClient<$Result.GetResult<Prisma.$noteReferencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NoteReference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {noteReferenceFindUniqueOrThrowArgs} args - Arguments to find a NoteReference
     * @example
     * // Get one NoteReference
     * const noteReference = await prisma.noteReference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends noteReferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, noteReferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__noteReferenceClient<$Result.GetResult<Prisma.$noteReferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NoteReference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteReferenceFindFirstArgs} args - Arguments to find a NoteReference
     * @example
     * // Get one NoteReference
     * const noteReference = await prisma.noteReference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends noteReferenceFindFirstArgs>(args?: SelectSubset<T, noteReferenceFindFirstArgs<ExtArgs>>): Prisma__noteReferenceClient<$Result.GetResult<Prisma.$noteReferencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NoteReference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteReferenceFindFirstOrThrowArgs} args - Arguments to find a NoteReference
     * @example
     * // Get one NoteReference
     * const noteReference = await prisma.noteReference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends noteReferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, noteReferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__noteReferenceClient<$Result.GetResult<Prisma.$noteReferencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NoteReferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteReferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NoteReferences
     * const noteReferences = await prisma.noteReference.findMany()
     * 
     * // Get first 10 NoteReferences
     * const noteReferences = await prisma.noteReference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noteReferenceWithIdOnly = await prisma.noteReference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends noteReferenceFindManyArgs>(args?: SelectSubset<T, noteReferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$noteReferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NoteReference.
     * @param {noteReferenceCreateArgs} args - Arguments to create a NoteReference.
     * @example
     * // Create one NoteReference
     * const NoteReference = await prisma.noteReference.create({
     *   data: {
     *     // ... data to create a NoteReference
     *   }
     * })
     * 
     */
    create<T extends noteReferenceCreateArgs>(args: SelectSubset<T, noteReferenceCreateArgs<ExtArgs>>): Prisma__noteReferenceClient<$Result.GetResult<Prisma.$noteReferencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NoteReferences.
     * @param {noteReferenceCreateManyArgs} args - Arguments to create many NoteReferences.
     * @example
     * // Create many NoteReferences
     * const noteReference = await prisma.noteReference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends noteReferenceCreateManyArgs>(args?: SelectSubset<T, noteReferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NoteReferences and returns the data saved in the database.
     * @param {noteReferenceCreateManyAndReturnArgs} args - Arguments to create many NoteReferences.
     * @example
     * // Create many NoteReferences
     * const noteReference = await prisma.noteReference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NoteReferences and only return the `id`
     * const noteReferenceWithIdOnly = await prisma.noteReference.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends noteReferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, noteReferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$noteReferencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NoteReference.
     * @param {noteReferenceDeleteArgs} args - Arguments to delete one NoteReference.
     * @example
     * // Delete one NoteReference
     * const NoteReference = await prisma.noteReference.delete({
     *   where: {
     *     // ... filter to delete one NoteReference
     *   }
     * })
     * 
     */
    delete<T extends noteReferenceDeleteArgs>(args: SelectSubset<T, noteReferenceDeleteArgs<ExtArgs>>): Prisma__noteReferenceClient<$Result.GetResult<Prisma.$noteReferencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NoteReference.
     * @param {noteReferenceUpdateArgs} args - Arguments to update one NoteReference.
     * @example
     * // Update one NoteReference
     * const noteReference = await prisma.noteReference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends noteReferenceUpdateArgs>(args: SelectSubset<T, noteReferenceUpdateArgs<ExtArgs>>): Prisma__noteReferenceClient<$Result.GetResult<Prisma.$noteReferencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NoteReferences.
     * @param {noteReferenceDeleteManyArgs} args - Arguments to filter NoteReferences to delete.
     * @example
     * // Delete a few NoteReferences
     * const { count } = await prisma.noteReference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends noteReferenceDeleteManyArgs>(args?: SelectSubset<T, noteReferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NoteReferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteReferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NoteReferences
     * const noteReference = await prisma.noteReference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends noteReferenceUpdateManyArgs>(args: SelectSubset<T, noteReferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NoteReferences and returns the data updated in the database.
     * @param {noteReferenceUpdateManyAndReturnArgs} args - Arguments to update many NoteReferences.
     * @example
     * // Update many NoteReferences
     * const noteReference = await prisma.noteReference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NoteReferences and only return the `id`
     * const noteReferenceWithIdOnly = await prisma.noteReference.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends noteReferenceUpdateManyAndReturnArgs>(args: SelectSubset<T, noteReferenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$noteReferencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NoteReference.
     * @param {noteReferenceUpsertArgs} args - Arguments to update or create a NoteReference.
     * @example
     * // Update or create a NoteReference
     * const noteReference = await prisma.noteReference.upsert({
     *   create: {
     *     // ... data to create a NoteReference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NoteReference we want to update
     *   }
     * })
     */
    upsert<T extends noteReferenceUpsertArgs>(args: SelectSubset<T, noteReferenceUpsertArgs<ExtArgs>>): Prisma__noteReferenceClient<$Result.GetResult<Prisma.$noteReferencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NoteReferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteReferenceCountArgs} args - Arguments to filter NoteReferences to count.
     * @example
     * // Count the number of NoteReferences
     * const count = await prisma.noteReference.count({
     *   where: {
     *     // ... the filter for the NoteReferences we want to count
     *   }
     * })
    **/
    count<T extends noteReferenceCountArgs>(
      args?: Subset<T, noteReferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoteReferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NoteReference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteReferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoteReferenceAggregateArgs>(args: Subset<T, NoteReferenceAggregateArgs>): Prisma.PrismaPromise<GetNoteReferenceAggregateType<T>>

    /**
     * Group by NoteReference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteReferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends noteReferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: noteReferenceGroupByArgs['orderBy'] }
        : { orderBy?: noteReferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, noteReferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoteReferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the noteReference model
   */
  readonly fields: noteReferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for noteReference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__noteReferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fromNote<T extends notesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, notesDefaultArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    toNote<T extends notesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, notesDefaultArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the noteReference model
   */
  interface noteReferenceFieldRefs {
    readonly id: FieldRef<"noteReference", 'Int'>
    readonly fromNoteId: FieldRef<"noteReference", 'Int'>
    readonly toNoteId: FieldRef<"noteReference", 'Int'>
    readonly createdAt: FieldRef<"noteReference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * noteReference findUnique
   */
  export type noteReferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteReference
     */
    select?: noteReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteReference
     */
    omit?: noteReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteReferenceInclude<ExtArgs> | null
    /**
     * Filter, which noteReference to fetch.
     */
    where: noteReferenceWhereUniqueInput
  }

  /**
   * noteReference findUniqueOrThrow
   */
  export type noteReferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteReference
     */
    select?: noteReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteReference
     */
    omit?: noteReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteReferenceInclude<ExtArgs> | null
    /**
     * Filter, which noteReference to fetch.
     */
    where: noteReferenceWhereUniqueInput
  }

  /**
   * noteReference findFirst
   */
  export type noteReferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteReference
     */
    select?: noteReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteReference
     */
    omit?: noteReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteReferenceInclude<ExtArgs> | null
    /**
     * Filter, which noteReference to fetch.
     */
    where?: noteReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of noteReferences to fetch.
     */
    orderBy?: noteReferenceOrderByWithRelationInput | noteReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for noteReferences.
     */
    cursor?: noteReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` noteReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` noteReferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of noteReferences.
     */
    distinct?: NoteReferenceScalarFieldEnum | NoteReferenceScalarFieldEnum[]
  }

  /**
   * noteReference findFirstOrThrow
   */
  export type noteReferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteReference
     */
    select?: noteReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteReference
     */
    omit?: noteReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteReferenceInclude<ExtArgs> | null
    /**
     * Filter, which noteReference to fetch.
     */
    where?: noteReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of noteReferences to fetch.
     */
    orderBy?: noteReferenceOrderByWithRelationInput | noteReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for noteReferences.
     */
    cursor?: noteReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` noteReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` noteReferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of noteReferences.
     */
    distinct?: NoteReferenceScalarFieldEnum | NoteReferenceScalarFieldEnum[]
  }

  /**
   * noteReference findMany
   */
  export type noteReferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteReference
     */
    select?: noteReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteReference
     */
    omit?: noteReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteReferenceInclude<ExtArgs> | null
    /**
     * Filter, which noteReferences to fetch.
     */
    where?: noteReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of noteReferences to fetch.
     */
    orderBy?: noteReferenceOrderByWithRelationInput | noteReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing noteReferences.
     */
    cursor?: noteReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` noteReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` noteReferences.
     */
    skip?: number
    distinct?: NoteReferenceScalarFieldEnum | NoteReferenceScalarFieldEnum[]
  }

  /**
   * noteReference create
   */
  export type noteReferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteReference
     */
    select?: noteReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteReference
     */
    omit?: noteReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteReferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a noteReference.
     */
    data: XOR<noteReferenceCreateInput, noteReferenceUncheckedCreateInput>
  }

  /**
   * noteReference createMany
   */
  export type noteReferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many noteReferences.
     */
    data: noteReferenceCreateManyInput | noteReferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * noteReference createManyAndReturn
   */
  export type noteReferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteReference
     */
    select?: noteReferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the noteReference
     */
    omit?: noteReferenceOmit<ExtArgs> | null
    /**
     * The data used to create many noteReferences.
     */
    data: noteReferenceCreateManyInput | noteReferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteReferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * noteReference update
   */
  export type noteReferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteReference
     */
    select?: noteReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteReference
     */
    omit?: noteReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteReferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a noteReference.
     */
    data: XOR<noteReferenceUpdateInput, noteReferenceUncheckedUpdateInput>
    /**
     * Choose, which noteReference to update.
     */
    where: noteReferenceWhereUniqueInput
  }

  /**
   * noteReference updateMany
   */
  export type noteReferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update noteReferences.
     */
    data: XOR<noteReferenceUpdateManyMutationInput, noteReferenceUncheckedUpdateManyInput>
    /**
     * Filter which noteReferences to update
     */
    where?: noteReferenceWhereInput
    /**
     * Limit how many noteReferences to update.
     */
    limit?: number
  }

  /**
   * noteReference updateManyAndReturn
   */
  export type noteReferenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteReference
     */
    select?: noteReferenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the noteReference
     */
    omit?: noteReferenceOmit<ExtArgs> | null
    /**
     * The data used to update noteReferences.
     */
    data: XOR<noteReferenceUpdateManyMutationInput, noteReferenceUncheckedUpdateManyInput>
    /**
     * Filter which noteReferences to update
     */
    where?: noteReferenceWhereInput
    /**
     * Limit how many noteReferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteReferenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * noteReference upsert
   */
  export type noteReferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteReference
     */
    select?: noteReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteReference
     */
    omit?: noteReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteReferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the noteReference to update in case it exists.
     */
    where: noteReferenceWhereUniqueInput
    /**
     * In case the noteReference found by the `where` argument doesn't exist, create a new noteReference with this data.
     */
    create: XOR<noteReferenceCreateInput, noteReferenceUncheckedCreateInput>
    /**
     * In case the noteReference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<noteReferenceUpdateInput, noteReferenceUncheckedUpdateInput>
  }

  /**
   * noteReference delete
   */
  export type noteReferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteReference
     */
    select?: noteReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteReference
     */
    omit?: noteReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteReferenceInclude<ExtArgs> | null
    /**
     * Filter which noteReference to delete.
     */
    where: noteReferenceWhereUniqueInput
  }

  /**
   * noteReference deleteMany
   */
  export type noteReferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which noteReferences to delete
     */
    where?: noteReferenceWhereInput
    /**
     * Limit how many noteReferences to delete.
     */
    limit?: number
  }

  /**
   * noteReference without action
   */
  export type noteReferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteReference
     */
    select?: noteReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteReference
     */
    omit?: noteReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteReferenceInclude<ExtArgs> | null
  }


  /**
   * Model follows
   */

  export type AggregateFollows = {
    _count: FollowsCountAggregateOutputType | null
    _avg: FollowsAvgAggregateOutputType | null
    _sum: FollowsSumAggregateOutputType | null
    _min: FollowsMinAggregateOutputType | null
    _max: FollowsMaxAggregateOutputType | null
  }

  export type FollowsAvgAggregateOutputType = {
    id: number | null
    accountId: number | null
  }

  export type FollowsSumAggregateOutputType = {
    id: number | null
    accountId: number | null
  }

  export type FollowsMinAggregateOutputType = {
    id: number | null
    siteName: string | null
    siteUrl: string | null
    siteAvatar: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    followType: string | null
    accountId: number | null
  }

  export type FollowsMaxAggregateOutputType = {
    id: number | null
    siteName: string | null
    siteUrl: string | null
    siteAvatar: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    followType: string | null
    accountId: number | null
  }

  export type FollowsCountAggregateOutputType = {
    id: number
    siteName: number
    siteUrl: number
    siteAvatar: number
    description: number
    createdAt: number
    updatedAt: number
    followType: number
    accountId: number
    _all: number
  }


  export type FollowsAvgAggregateInputType = {
    id?: true
    accountId?: true
  }

  export type FollowsSumAggregateInputType = {
    id?: true
    accountId?: true
  }

  export type FollowsMinAggregateInputType = {
    id?: true
    siteName?: true
    siteUrl?: true
    siteAvatar?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    followType?: true
    accountId?: true
  }

  export type FollowsMaxAggregateInputType = {
    id?: true
    siteName?: true
    siteUrl?: true
    siteAvatar?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    followType?: true
    accountId?: true
  }

  export type FollowsCountAggregateInputType = {
    id?: true
    siteName?: true
    siteUrl?: true
    siteAvatar?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    followType?: true
    accountId?: true
    _all?: true
  }

  export type FollowsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which follows to aggregate.
     */
    where?: followsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of follows to fetch.
     */
    orderBy?: followsOrderByWithRelationInput | followsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: followsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned follows
    **/
    _count?: true | FollowsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FollowsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FollowsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowsMaxAggregateInputType
  }

  export type GetFollowsAggregateType<T extends FollowsAggregateArgs> = {
        [P in keyof T & keyof AggregateFollows]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollows[P]>
      : GetScalarType<T[P], AggregateFollows[P]>
  }




  export type followsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: followsWhereInput
    orderBy?: followsOrderByWithAggregationInput | followsOrderByWithAggregationInput[]
    by: FollowsScalarFieldEnum[] | FollowsScalarFieldEnum
    having?: followsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowsCountAggregateInputType | true
    _avg?: FollowsAvgAggregateInputType
    _sum?: FollowsSumAggregateInputType
    _min?: FollowsMinAggregateInputType
    _max?: FollowsMaxAggregateInputType
  }

  export type FollowsGroupByOutputType = {
    id: number
    siteName: string | null
    siteUrl: string
    siteAvatar: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    followType: string
    accountId: number
    _count: FollowsCountAggregateOutputType | null
    _avg: FollowsAvgAggregateOutputType | null
    _sum: FollowsSumAggregateOutputType | null
    _min: FollowsMinAggregateOutputType | null
    _max: FollowsMaxAggregateOutputType | null
  }

  type GetFollowsGroupByPayload<T extends followsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowsGroupByOutputType[P]>
            : GetScalarType<T[P], FollowsGroupByOutputType[P]>
        }
      >
    >


  export type followsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteName?: boolean
    siteUrl?: boolean
    siteAvatar?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    followType?: boolean
    accountId?: boolean
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follows"]>

  export type followsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteName?: boolean
    siteUrl?: boolean
    siteAvatar?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    followType?: boolean
    accountId?: boolean
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follows"]>

  export type followsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    siteName?: boolean
    siteUrl?: boolean
    siteAvatar?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    followType?: boolean
    accountId?: boolean
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follows"]>

  export type followsSelectScalar = {
    id?: boolean
    siteName?: boolean
    siteUrl?: boolean
    siteAvatar?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    followType?: boolean
    accountId?: boolean
  }

  export type followsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "siteName" | "siteUrl" | "siteAvatar" | "description" | "createdAt" | "updatedAt" | "followType" | "accountId", ExtArgs["result"]["follows"]>
  export type followsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }
  export type followsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }
  export type followsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }

  export type $followsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "follows"
    objects: {
      account: Prisma.$accountsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      siteName: string | null
      siteUrl: string
      siteAvatar: string | null
      description: string | null
      createdAt: Date
      updatedAt: Date
      followType: string
      accountId: number
    }, ExtArgs["result"]["follows"]>
    composites: {}
  }

  type followsGetPayload<S extends boolean | null | undefined | followsDefaultArgs> = $Result.GetResult<Prisma.$followsPayload, S>

  type followsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<followsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FollowsCountAggregateInputType | true
    }

  export interface followsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['follows'], meta: { name: 'follows' } }
    /**
     * Find zero or one Follows that matches the filter.
     * @param {followsFindUniqueArgs} args - Arguments to find a Follows
     * @example
     * // Get one Follows
     * const follows = await prisma.follows.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends followsFindUniqueArgs>(args: SelectSubset<T, followsFindUniqueArgs<ExtArgs>>): Prisma__followsClient<$Result.GetResult<Prisma.$followsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Follows that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {followsFindUniqueOrThrowArgs} args - Arguments to find a Follows
     * @example
     * // Get one Follows
     * const follows = await prisma.follows.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends followsFindUniqueOrThrowArgs>(args: SelectSubset<T, followsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__followsClient<$Result.GetResult<Prisma.$followsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Follows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followsFindFirstArgs} args - Arguments to find a Follows
     * @example
     * // Get one Follows
     * const follows = await prisma.follows.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends followsFindFirstArgs>(args?: SelectSubset<T, followsFindFirstArgs<ExtArgs>>): Prisma__followsClient<$Result.GetResult<Prisma.$followsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Follows that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followsFindFirstOrThrowArgs} args - Arguments to find a Follows
     * @example
     * // Get one Follows
     * const follows = await prisma.follows.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends followsFindFirstOrThrowArgs>(args?: SelectSubset<T, followsFindFirstOrThrowArgs<ExtArgs>>): Prisma__followsClient<$Result.GetResult<Prisma.$followsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Follows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Follows
     * const follows = await prisma.follows.findMany()
     * 
     * // Get first 10 Follows
     * const follows = await prisma.follows.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const followsWithIdOnly = await prisma.follows.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends followsFindManyArgs>(args?: SelectSubset<T, followsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$followsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Follows.
     * @param {followsCreateArgs} args - Arguments to create a Follows.
     * @example
     * // Create one Follows
     * const Follows = await prisma.follows.create({
     *   data: {
     *     // ... data to create a Follows
     *   }
     * })
     * 
     */
    create<T extends followsCreateArgs>(args: SelectSubset<T, followsCreateArgs<ExtArgs>>): Prisma__followsClient<$Result.GetResult<Prisma.$followsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Follows.
     * @param {followsCreateManyArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follows = await prisma.follows.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends followsCreateManyArgs>(args?: SelectSubset<T, followsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Follows and returns the data saved in the database.
     * @param {followsCreateManyAndReturnArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follows = await prisma.follows.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Follows and only return the `id`
     * const followsWithIdOnly = await prisma.follows.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends followsCreateManyAndReturnArgs>(args?: SelectSubset<T, followsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$followsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Follows.
     * @param {followsDeleteArgs} args - Arguments to delete one Follows.
     * @example
     * // Delete one Follows
     * const Follows = await prisma.follows.delete({
     *   where: {
     *     // ... filter to delete one Follows
     *   }
     * })
     * 
     */
    delete<T extends followsDeleteArgs>(args: SelectSubset<T, followsDeleteArgs<ExtArgs>>): Prisma__followsClient<$Result.GetResult<Prisma.$followsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Follows.
     * @param {followsUpdateArgs} args - Arguments to update one Follows.
     * @example
     * // Update one Follows
     * const follows = await prisma.follows.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends followsUpdateArgs>(args: SelectSubset<T, followsUpdateArgs<ExtArgs>>): Prisma__followsClient<$Result.GetResult<Prisma.$followsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Follows.
     * @param {followsDeleteManyArgs} args - Arguments to filter Follows to delete.
     * @example
     * // Delete a few Follows
     * const { count } = await prisma.follows.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends followsDeleteManyArgs>(args?: SelectSubset<T, followsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Follows
     * const follows = await prisma.follows.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends followsUpdateManyArgs>(args: SelectSubset<T, followsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Follows and returns the data updated in the database.
     * @param {followsUpdateManyAndReturnArgs} args - Arguments to update many Follows.
     * @example
     * // Update many Follows
     * const follows = await prisma.follows.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Follows and only return the `id`
     * const followsWithIdOnly = await prisma.follows.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends followsUpdateManyAndReturnArgs>(args: SelectSubset<T, followsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$followsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Follows.
     * @param {followsUpsertArgs} args - Arguments to update or create a Follows.
     * @example
     * // Update or create a Follows
     * const follows = await prisma.follows.upsert({
     *   create: {
     *     // ... data to create a Follows
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Follows we want to update
     *   }
     * })
     */
    upsert<T extends followsUpsertArgs>(args: SelectSubset<T, followsUpsertArgs<ExtArgs>>): Prisma__followsClient<$Result.GetResult<Prisma.$followsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followsCountArgs} args - Arguments to filter Follows to count.
     * @example
     * // Count the number of Follows
     * const count = await prisma.follows.count({
     *   where: {
     *     // ... the filter for the Follows we want to count
     *   }
     * })
    **/
    count<T extends followsCountArgs>(
      args?: Subset<T, followsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowsAggregateArgs>(args: Subset<T, FollowsAggregateArgs>): Prisma.PrismaPromise<GetFollowsAggregateType<T>>

    /**
     * Group by Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends followsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: followsGroupByArgs['orderBy'] }
        : { orderBy?: followsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, followsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the follows model
   */
  readonly fields: followsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for follows.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__followsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends accountsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, accountsDefaultArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the follows model
   */
  interface followsFieldRefs {
    readonly id: FieldRef<"follows", 'Int'>
    readonly siteName: FieldRef<"follows", 'String'>
    readonly siteUrl: FieldRef<"follows", 'String'>
    readonly siteAvatar: FieldRef<"follows", 'String'>
    readonly description: FieldRef<"follows", 'String'>
    readonly createdAt: FieldRef<"follows", 'DateTime'>
    readonly updatedAt: FieldRef<"follows", 'DateTime'>
    readonly followType: FieldRef<"follows", 'String'>
    readonly accountId: FieldRef<"follows", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * follows findUnique
   */
  export type followsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follows
     */
    select?: followsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the follows
     */
    omit?: followsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followsInclude<ExtArgs> | null
    /**
     * Filter, which follows to fetch.
     */
    where: followsWhereUniqueInput
  }

  /**
   * follows findUniqueOrThrow
   */
  export type followsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follows
     */
    select?: followsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the follows
     */
    omit?: followsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followsInclude<ExtArgs> | null
    /**
     * Filter, which follows to fetch.
     */
    where: followsWhereUniqueInput
  }

  /**
   * follows findFirst
   */
  export type followsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follows
     */
    select?: followsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the follows
     */
    omit?: followsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followsInclude<ExtArgs> | null
    /**
     * Filter, which follows to fetch.
     */
    where?: followsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of follows to fetch.
     */
    orderBy?: followsOrderByWithRelationInput | followsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for follows.
     */
    cursor?: followsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of follows.
     */
    distinct?: FollowsScalarFieldEnum | FollowsScalarFieldEnum[]
  }

  /**
   * follows findFirstOrThrow
   */
  export type followsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follows
     */
    select?: followsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the follows
     */
    omit?: followsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followsInclude<ExtArgs> | null
    /**
     * Filter, which follows to fetch.
     */
    where?: followsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of follows to fetch.
     */
    orderBy?: followsOrderByWithRelationInput | followsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for follows.
     */
    cursor?: followsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of follows.
     */
    distinct?: FollowsScalarFieldEnum | FollowsScalarFieldEnum[]
  }

  /**
   * follows findMany
   */
  export type followsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follows
     */
    select?: followsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the follows
     */
    omit?: followsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followsInclude<ExtArgs> | null
    /**
     * Filter, which follows to fetch.
     */
    where?: followsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of follows to fetch.
     */
    orderBy?: followsOrderByWithRelationInput | followsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing follows.
     */
    cursor?: followsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` follows.
     */
    skip?: number
    distinct?: FollowsScalarFieldEnum | FollowsScalarFieldEnum[]
  }

  /**
   * follows create
   */
  export type followsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follows
     */
    select?: followsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the follows
     */
    omit?: followsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followsInclude<ExtArgs> | null
    /**
     * The data needed to create a follows.
     */
    data: XOR<followsCreateInput, followsUncheckedCreateInput>
  }

  /**
   * follows createMany
   */
  export type followsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many follows.
     */
    data: followsCreateManyInput | followsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * follows createManyAndReturn
   */
  export type followsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follows
     */
    select?: followsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the follows
     */
    omit?: followsOmit<ExtArgs> | null
    /**
     * The data used to create many follows.
     */
    data: followsCreateManyInput | followsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * follows update
   */
  export type followsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follows
     */
    select?: followsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the follows
     */
    omit?: followsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followsInclude<ExtArgs> | null
    /**
     * The data needed to update a follows.
     */
    data: XOR<followsUpdateInput, followsUncheckedUpdateInput>
    /**
     * Choose, which follows to update.
     */
    where: followsWhereUniqueInput
  }

  /**
   * follows updateMany
   */
  export type followsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update follows.
     */
    data: XOR<followsUpdateManyMutationInput, followsUncheckedUpdateManyInput>
    /**
     * Filter which follows to update
     */
    where?: followsWhereInput
    /**
     * Limit how many follows to update.
     */
    limit?: number
  }

  /**
   * follows updateManyAndReturn
   */
  export type followsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follows
     */
    select?: followsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the follows
     */
    omit?: followsOmit<ExtArgs> | null
    /**
     * The data used to update follows.
     */
    data: XOR<followsUpdateManyMutationInput, followsUncheckedUpdateManyInput>
    /**
     * Filter which follows to update
     */
    where?: followsWhereInput
    /**
     * Limit how many follows to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * follows upsert
   */
  export type followsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follows
     */
    select?: followsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the follows
     */
    omit?: followsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followsInclude<ExtArgs> | null
    /**
     * The filter to search for the follows to update in case it exists.
     */
    where: followsWhereUniqueInput
    /**
     * In case the follows found by the `where` argument doesn't exist, create a new follows with this data.
     */
    create: XOR<followsCreateInput, followsUncheckedCreateInput>
    /**
     * In case the follows was found with the provided `where` argument, update it with this data.
     */
    update: XOR<followsUpdateInput, followsUncheckedUpdateInput>
  }

  /**
   * follows delete
   */
  export type followsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follows
     */
    select?: followsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the follows
     */
    omit?: followsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followsInclude<ExtArgs> | null
    /**
     * Filter which follows to delete.
     */
    where: followsWhereUniqueInput
  }

  /**
   * follows deleteMany
   */
  export type followsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which follows to delete
     */
    where?: followsWhereInput
    /**
     * Limit how many follows to delete.
     */
    limit?: number
  }

  /**
   * follows without action
   */
  export type followsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follows
     */
    select?: followsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the follows
     */
    omit?: followsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followsInclude<ExtArgs> | null
  }


  /**
   * Model notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsAvgAggregateOutputType = {
    id: number | null
    accountId: number | null
  }

  export type NotificationsSumAggregateOutputType = {
    id: number | null
    accountId: number | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: number | null
    type: string | null
    title: string | null
    content: string | null
    isRead: boolean | null
    accountId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: number | null
    type: string | null
    title: string | null
    content: string | null
    isRead: boolean | null
    accountId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    type: number
    title: number
    content: number
    metadata: number
    isRead: number
    accountId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationsAvgAggregateInputType = {
    id?: true
    accountId?: true
  }

  export type NotificationsSumAggregateInputType = {
    id?: true
    accountId?: true
  }

  export type NotificationsMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    content?: true
    isRead?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    content?: true
    isRead?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    content?: true
    metadata?: true
    isRead?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to aggregate.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type notificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithAggregationInput | notificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: notificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _avg?: NotificationsAvgAggregateInputType
    _sum?: NotificationsSumAggregateInputType
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    id: number
    type: string
    title: string
    content: string
    metadata: JsonValue | null
    isRead: boolean
    accountId: number
    createdAt: Date
    updatedAt: Date
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends notificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type notificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    metadata?: boolean
    isRead?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    metadata?: boolean
    isRead?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    metadata?: boolean
    isRead?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectScalar = {
    id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    metadata?: boolean
    isRead?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type notificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "title" | "content" | "metadata" | "isRead" | "accountId" | "createdAt" | "updatedAt", ExtArgs["result"]["notifications"]>
  export type notificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }
  export type notificationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }
  export type notificationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }

  export type $notificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notifications"
    objects: {
      account: Prisma.$accountsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      title: string
      content: string
      metadata: Prisma.JsonValue | null
      isRead: boolean
      accountId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }

  type notificationsGetPayload<S extends boolean | null | undefined | notificationsDefaultArgs> = $Result.GetResult<Prisma.$notificationsPayload, S>

  type notificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface notificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notifications'], meta: { name: 'notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {notificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationsFindUniqueArgs>(args: SelectSubset<T, notificationsFindUniqueArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationsFindFirstArgs>(args?: SelectSubset<T, notificationsFindFirstArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationsFindManyArgs>(args?: SelectSubset<T, notificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notifications.
     * @param {notificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
     */
    create<T extends notificationsCreateArgs>(args: SelectSubset<T, notificationsCreateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {notificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationsCreateManyArgs>(args?: SelectSubset<T, notificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {notificationsCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notificationsCreateManyAndReturnArgs>(args?: SelectSubset<T, notificationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notifications.
     * @param {notificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
     */
    delete<T extends notificationsDeleteArgs>(args: SelectSubset<T, notificationsDeleteArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notifications.
     * @param {notificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationsUpdateArgs>(args: SelectSubset<T, notificationsUpdateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {notificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationsDeleteManyArgs>(args?: SelectSubset<T, notificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationsUpdateManyArgs>(args: SelectSubset<T, notificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {notificationsUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends notificationsUpdateManyAndReturnArgs>(args: SelectSubset<T, notificationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notifications.
     * @param {notificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
     */
    upsert<T extends notificationsUpsertArgs>(args: SelectSubset<T, notificationsUpsertArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationsCountArgs>(
      args?: Subset<T, notificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationsGroupByArgs['orderBy'] }
        : { orderBy?: notificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notifications model
   */
  readonly fields: notificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends accountsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, accountsDefaultArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notifications model
   */
  interface notificationsFieldRefs {
    readonly id: FieldRef<"notifications", 'Int'>
    readonly type: FieldRef<"notifications", 'String'>
    readonly title: FieldRef<"notifications", 'String'>
    readonly content: FieldRef<"notifications", 'String'>
    readonly metadata: FieldRef<"notifications", 'Json'>
    readonly isRead: FieldRef<"notifications", 'Boolean'>
    readonly accountId: FieldRef<"notifications", 'Int'>
    readonly createdAt: FieldRef<"notifications", 'DateTime'>
    readonly updatedAt: FieldRef<"notifications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * notifications findUnique
   */
  export type notificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findUniqueOrThrow
   */
  export type notificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findFirst
   */
  export type notificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findFirstOrThrow
   */
  export type notificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findMany
   */
  export type notificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications create
   */
  export type notificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a notifications.
     */
    data: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
  }

  /**
   * notifications createMany
   */
  export type notificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notifications createManyAndReturn
   */
  export type notificationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * notifications update
   */
  export type notificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a notifications.
     */
    data: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
    /**
     * Choose, which notifications to update.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications updateMany
   */
  export type notificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
  }

  /**
   * notifications updateManyAndReturn
   */
  export type notificationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * notifications upsert
   */
  export type notificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the notifications to update in case it exists.
     */
    where: notificationsWhereUniqueInput
    /**
     * In case the notifications found by the `where` argument doesn't exist, create a new notifications with this data.
     */
    create: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
    /**
     * In case the notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
  }

  /**
   * notifications delete
   */
  export type notificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter which notifications to delete.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications deleteMany
   */
  export type notificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to delete.
     */
    limit?: number
  }

  /**
   * notifications without action
   */
  export type notificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
  }


  /**
   * Model cache
   */

  export type AggregateCache = {
    _count: CacheCountAggregateOutputType | null
    _avg: CacheAvgAggregateOutputType | null
    _sum: CacheSumAggregateOutputType | null
    _min: CacheMinAggregateOutputType | null
    _max: CacheMaxAggregateOutputType | null
  }

  export type CacheAvgAggregateOutputType = {
    id: number | null
  }

  export type CacheSumAggregateOutputType = {
    id: number | null
  }

  export type CacheMinAggregateOutputType = {
    id: number | null
    key: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CacheMaxAggregateOutputType = {
    id: number | null
    key: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CacheCountAggregateOutputType = {
    id: number
    key: number
    value: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CacheAvgAggregateInputType = {
    id?: true
  }

  export type CacheSumAggregateInputType = {
    id?: true
  }

  export type CacheMinAggregateInputType = {
    id?: true
    key?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CacheMaxAggregateInputType = {
    id?: true
    key?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CacheCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CacheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cache to aggregate.
     */
    where?: cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caches to fetch.
     */
    orderBy?: cacheOrderByWithRelationInput | cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned caches
    **/
    _count?: true | CacheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CacheAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CacheSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CacheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CacheMaxAggregateInputType
  }

  export type GetCacheAggregateType<T extends CacheAggregateArgs> = {
        [P in keyof T & keyof AggregateCache]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCache[P]>
      : GetScalarType<T[P], AggregateCache[P]>
  }




  export type cacheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cacheWhereInput
    orderBy?: cacheOrderByWithAggregationInput | cacheOrderByWithAggregationInput[]
    by: CacheScalarFieldEnum[] | CacheScalarFieldEnum
    having?: cacheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CacheCountAggregateInputType | true
    _avg?: CacheAvgAggregateInputType
    _sum?: CacheSumAggregateInputType
    _min?: CacheMinAggregateInputType
    _max?: CacheMaxAggregateInputType
  }

  export type CacheGroupByOutputType = {
    id: number
    key: string
    value: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: CacheCountAggregateOutputType | null
    _avg: CacheAvgAggregateOutputType | null
    _sum: CacheSumAggregateOutputType | null
    _min: CacheMinAggregateOutputType | null
    _max: CacheMaxAggregateOutputType | null
  }

  type GetCacheGroupByPayload<T extends cacheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CacheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CacheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CacheGroupByOutputType[P]>
            : GetScalarType<T[P], CacheGroupByOutputType[P]>
        }
      >
    >


  export type cacheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cache"]>

  export type cacheSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cache"]>

  export type cacheSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cache"]>

  export type cacheSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type cacheOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "createdAt" | "updatedAt", ExtArgs["result"]["cache"]>

  export type $cachePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cache"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      key: string
      value: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cache"]>
    composites: {}
  }

  type cacheGetPayload<S extends boolean | null | undefined | cacheDefaultArgs> = $Result.GetResult<Prisma.$cachePayload, S>

  type cacheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cacheFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CacheCountAggregateInputType | true
    }

  export interface cacheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cache'], meta: { name: 'cache' } }
    /**
     * Find zero or one Cache that matches the filter.
     * @param {cacheFindUniqueArgs} args - Arguments to find a Cache
     * @example
     * // Get one Cache
     * const cache = await prisma.cache.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cacheFindUniqueArgs>(args: SelectSubset<T, cacheFindUniqueArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cache that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cacheFindUniqueOrThrowArgs} args - Arguments to find a Cache
     * @example
     * // Get one Cache
     * const cache = await prisma.cache.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cacheFindUniqueOrThrowArgs>(args: SelectSubset<T, cacheFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cache that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cacheFindFirstArgs} args - Arguments to find a Cache
     * @example
     * // Get one Cache
     * const cache = await prisma.cache.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cacheFindFirstArgs>(args?: SelectSubset<T, cacheFindFirstArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cache that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cacheFindFirstOrThrowArgs} args - Arguments to find a Cache
     * @example
     * // Get one Cache
     * const cache = await prisma.cache.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cacheFindFirstOrThrowArgs>(args?: SelectSubset<T, cacheFindFirstOrThrowArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Caches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cacheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Caches
     * const caches = await prisma.cache.findMany()
     * 
     * // Get first 10 Caches
     * const caches = await prisma.cache.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cacheWithIdOnly = await prisma.cache.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cacheFindManyArgs>(args?: SelectSubset<T, cacheFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cache.
     * @param {cacheCreateArgs} args - Arguments to create a Cache.
     * @example
     * // Create one Cache
     * const Cache = await prisma.cache.create({
     *   data: {
     *     // ... data to create a Cache
     *   }
     * })
     * 
     */
    create<T extends cacheCreateArgs>(args: SelectSubset<T, cacheCreateArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Caches.
     * @param {cacheCreateManyArgs} args - Arguments to create many Caches.
     * @example
     * // Create many Caches
     * const cache = await prisma.cache.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cacheCreateManyArgs>(args?: SelectSubset<T, cacheCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Caches and returns the data saved in the database.
     * @param {cacheCreateManyAndReturnArgs} args - Arguments to create many Caches.
     * @example
     * // Create many Caches
     * const cache = await prisma.cache.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Caches and only return the `id`
     * const cacheWithIdOnly = await prisma.cache.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends cacheCreateManyAndReturnArgs>(args?: SelectSubset<T, cacheCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cache.
     * @param {cacheDeleteArgs} args - Arguments to delete one Cache.
     * @example
     * // Delete one Cache
     * const Cache = await prisma.cache.delete({
     *   where: {
     *     // ... filter to delete one Cache
     *   }
     * })
     * 
     */
    delete<T extends cacheDeleteArgs>(args: SelectSubset<T, cacheDeleteArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cache.
     * @param {cacheUpdateArgs} args - Arguments to update one Cache.
     * @example
     * // Update one Cache
     * const cache = await prisma.cache.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cacheUpdateArgs>(args: SelectSubset<T, cacheUpdateArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Caches.
     * @param {cacheDeleteManyArgs} args - Arguments to filter Caches to delete.
     * @example
     * // Delete a few Caches
     * const { count } = await prisma.cache.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cacheDeleteManyArgs>(args?: SelectSubset<T, cacheDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Caches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cacheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Caches
     * const cache = await prisma.cache.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cacheUpdateManyArgs>(args: SelectSubset<T, cacheUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Caches and returns the data updated in the database.
     * @param {cacheUpdateManyAndReturnArgs} args - Arguments to update many Caches.
     * @example
     * // Update many Caches
     * const cache = await prisma.cache.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Caches and only return the `id`
     * const cacheWithIdOnly = await prisma.cache.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends cacheUpdateManyAndReturnArgs>(args: SelectSubset<T, cacheUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cache.
     * @param {cacheUpsertArgs} args - Arguments to update or create a Cache.
     * @example
     * // Update or create a Cache
     * const cache = await prisma.cache.upsert({
     *   create: {
     *     // ... data to create a Cache
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cache we want to update
     *   }
     * })
     */
    upsert<T extends cacheUpsertArgs>(args: SelectSubset<T, cacheUpsertArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Caches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cacheCountArgs} args - Arguments to filter Caches to count.
     * @example
     * // Count the number of Caches
     * const count = await prisma.cache.count({
     *   where: {
     *     // ... the filter for the Caches we want to count
     *   }
     * })
    **/
    count<T extends cacheCountArgs>(
      args?: Subset<T, cacheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CacheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CacheAggregateArgs>(args: Subset<T, CacheAggregateArgs>): Prisma.PrismaPromise<GetCacheAggregateType<T>>

    /**
     * Group by Cache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cacheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cacheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cacheGroupByArgs['orderBy'] }
        : { orderBy?: cacheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cacheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCacheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cache model
   */
  readonly fields: cacheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cache.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cacheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cache model
   */
  interface cacheFieldRefs {
    readonly id: FieldRef<"cache", 'Int'>
    readonly key: FieldRef<"cache", 'String'>
    readonly value: FieldRef<"cache", 'Json'>
    readonly createdAt: FieldRef<"cache", 'DateTime'>
    readonly updatedAt: FieldRef<"cache", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * cache findUnique
   */
  export type cacheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * Filter, which cache to fetch.
     */
    where: cacheWhereUniqueInput
  }

  /**
   * cache findUniqueOrThrow
   */
  export type cacheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * Filter, which cache to fetch.
     */
    where: cacheWhereUniqueInput
  }

  /**
   * cache findFirst
   */
  export type cacheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * Filter, which cache to fetch.
     */
    where?: cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caches to fetch.
     */
    orderBy?: cacheOrderByWithRelationInput | cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for caches.
     */
    cursor?: cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of caches.
     */
    distinct?: CacheScalarFieldEnum | CacheScalarFieldEnum[]
  }

  /**
   * cache findFirstOrThrow
   */
  export type cacheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * Filter, which cache to fetch.
     */
    where?: cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caches to fetch.
     */
    orderBy?: cacheOrderByWithRelationInput | cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for caches.
     */
    cursor?: cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of caches.
     */
    distinct?: CacheScalarFieldEnum | CacheScalarFieldEnum[]
  }

  /**
   * cache findMany
   */
  export type cacheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * Filter, which caches to fetch.
     */
    where?: cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caches to fetch.
     */
    orderBy?: cacheOrderByWithRelationInput | cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing caches.
     */
    cursor?: cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caches.
     */
    skip?: number
    distinct?: CacheScalarFieldEnum | CacheScalarFieldEnum[]
  }

  /**
   * cache create
   */
  export type cacheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * The data needed to create a cache.
     */
    data: XOR<cacheCreateInput, cacheUncheckedCreateInput>
  }

  /**
   * cache createMany
   */
  export type cacheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many caches.
     */
    data: cacheCreateManyInput | cacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cache createManyAndReturn
   */
  export type cacheCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * The data used to create many caches.
     */
    data: cacheCreateManyInput | cacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cache update
   */
  export type cacheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * The data needed to update a cache.
     */
    data: XOR<cacheUpdateInput, cacheUncheckedUpdateInput>
    /**
     * Choose, which cache to update.
     */
    where: cacheWhereUniqueInput
  }

  /**
   * cache updateMany
   */
  export type cacheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update caches.
     */
    data: XOR<cacheUpdateManyMutationInput, cacheUncheckedUpdateManyInput>
    /**
     * Filter which caches to update
     */
    where?: cacheWhereInput
    /**
     * Limit how many caches to update.
     */
    limit?: number
  }

  /**
   * cache updateManyAndReturn
   */
  export type cacheUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * The data used to update caches.
     */
    data: XOR<cacheUpdateManyMutationInput, cacheUncheckedUpdateManyInput>
    /**
     * Filter which caches to update
     */
    where?: cacheWhereInput
    /**
     * Limit how many caches to update.
     */
    limit?: number
  }

  /**
   * cache upsert
   */
  export type cacheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * The filter to search for the cache to update in case it exists.
     */
    where: cacheWhereUniqueInput
    /**
     * In case the cache found by the `where` argument doesn't exist, create a new cache with this data.
     */
    create: XOR<cacheCreateInput, cacheUncheckedCreateInput>
    /**
     * In case the cache was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cacheUpdateInput, cacheUncheckedUpdateInput>
  }

  /**
   * cache delete
   */
  export type cacheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * Filter which cache to delete.
     */
    where: cacheWhereUniqueInput
  }

  /**
   * cache deleteMany
   */
  export type cacheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which caches to delete
     */
    where?: cacheWhereInput
    /**
     * Limit how many caches to delete.
     */
    limit?: number
  }

  /**
   * cache without action
   */
  export type cacheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
  }


  /**
   * Model plugin
   */

  export type AggregatePlugin = {
    _count: PluginCountAggregateOutputType | null
    _avg: PluginAvgAggregateOutputType | null
    _sum: PluginSumAggregateOutputType | null
    _min: PluginMinAggregateOutputType | null
    _max: PluginMaxAggregateOutputType | null
  }

  export type PluginAvgAggregateOutputType = {
    id: number | null
  }

  export type PluginSumAggregateOutputType = {
    id: number | null
  }

  export type PluginMinAggregateOutputType = {
    id: number | null
    path: string | null
    isUse: boolean | null
    isDev: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PluginMaxAggregateOutputType = {
    id: number | null
    path: string | null
    isUse: boolean | null
    isDev: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PluginCountAggregateOutputType = {
    id: number
    metadata: number
    path: number
    isUse: number
    isDev: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PluginAvgAggregateInputType = {
    id?: true
  }

  export type PluginSumAggregateInputType = {
    id?: true
  }

  export type PluginMinAggregateInputType = {
    id?: true
    path?: true
    isUse?: true
    isDev?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PluginMaxAggregateInputType = {
    id?: true
    path?: true
    isUse?: true
    isDev?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PluginCountAggregateInputType = {
    id?: true
    metadata?: true
    path?: true
    isUse?: true
    isDev?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PluginAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plugin to aggregate.
     */
    where?: pluginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plugins to fetch.
     */
    orderBy?: pluginOrderByWithRelationInput | pluginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pluginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plugins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plugins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plugins
    **/
    _count?: true | PluginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PluginAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PluginSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PluginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PluginMaxAggregateInputType
  }

  export type GetPluginAggregateType<T extends PluginAggregateArgs> = {
        [P in keyof T & keyof AggregatePlugin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlugin[P]>
      : GetScalarType<T[P], AggregatePlugin[P]>
  }




  export type pluginGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pluginWhereInput
    orderBy?: pluginOrderByWithAggregationInput | pluginOrderByWithAggregationInput[]
    by: PluginScalarFieldEnum[] | PluginScalarFieldEnum
    having?: pluginScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PluginCountAggregateInputType | true
    _avg?: PluginAvgAggregateInputType
    _sum?: PluginSumAggregateInputType
    _min?: PluginMinAggregateInputType
    _max?: PluginMaxAggregateInputType
  }

  export type PluginGroupByOutputType = {
    id: number
    metadata: JsonValue
    path: string
    isUse: boolean
    isDev: boolean
    createdAt: Date
    updatedAt: Date
    _count: PluginCountAggregateOutputType | null
    _avg: PluginAvgAggregateOutputType | null
    _sum: PluginSumAggregateOutputType | null
    _min: PluginMinAggregateOutputType | null
    _max: PluginMaxAggregateOutputType | null
  }

  type GetPluginGroupByPayload<T extends pluginGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PluginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PluginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PluginGroupByOutputType[P]>
            : GetScalarType<T[P], PluginGroupByOutputType[P]>
        }
      >
    >


  export type pluginSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metadata?: boolean
    path?: boolean
    isUse?: boolean
    isDev?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["plugin"]>

  export type pluginSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metadata?: boolean
    path?: boolean
    isUse?: boolean
    isDev?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["plugin"]>

  export type pluginSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metadata?: boolean
    path?: boolean
    isUse?: boolean
    isDev?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["plugin"]>

  export type pluginSelectScalar = {
    id?: boolean
    metadata?: boolean
    path?: boolean
    isUse?: boolean
    isDev?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type pluginOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "metadata" | "path" | "isUse" | "isDev" | "createdAt" | "updatedAt", ExtArgs["result"]["plugin"]>

  export type $pluginPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "plugin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      metadata: Prisma.JsonValue
      path: string
      isUse: boolean
      isDev: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["plugin"]>
    composites: {}
  }

  type pluginGetPayload<S extends boolean | null | undefined | pluginDefaultArgs> = $Result.GetResult<Prisma.$pluginPayload, S>

  type pluginCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pluginFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PluginCountAggregateInputType | true
    }

  export interface pluginDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['plugin'], meta: { name: 'plugin' } }
    /**
     * Find zero or one Plugin that matches the filter.
     * @param {pluginFindUniqueArgs} args - Arguments to find a Plugin
     * @example
     * // Get one Plugin
     * const plugin = await prisma.plugin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pluginFindUniqueArgs>(args: SelectSubset<T, pluginFindUniqueArgs<ExtArgs>>): Prisma__pluginClient<$Result.GetResult<Prisma.$pluginPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plugin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pluginFindUniqueOrThrowArgs} args - Arguments to find a Plugin
     * @example
     * // Get one Plugin
     * const plugin = await prisma.plugin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pluginFindUniqueOrThrowArgs>(args: SelectSubset<T, pluginFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pluginClient<$Result.GetResult<Prisma.$pluginPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plugin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pluginFindFirstArgs} args - Arguments to find a Plugin
     * @example
     * // Get one Plugin
     * const plugin = await prisma.plugin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pluginFindFirstArgs>(args?: SelectSubset<T, pluginFindFirstArgs<ExtArgs>>): Prisma__pluginClient<$Result.GetResult<Prisma.$pluginPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plugin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pluginFindFirstOrThrowArgs} args - Arguments to find a Plugin
     * @example
     * // Get one Plugin
     * const plugin = await prisma.plugin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pluginFindFirstOrThrowArgs>(args?: SelectSubset<T, pluginFindFirstOrThrowArgs<ExtArgs>>): Prisma__pluginClient<$Result.GetResult<Prisma.$pluginPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plugins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pluginFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plugins
     * const plugins = await prisma.plugin.findMany()
     * 
     * // Get first 10 Plugins
     * const plugins = await prisma.plugin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pluginWithIdOnly = await prisma.plugin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pluginFindManyArgs>(args?: SelectSubset<T, pluginFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pluginPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plugin.
     * @param {pluginCreateArgs} args - Arguments to create a Plugin.
     * @example
     * // Create one Plugin
     * const Plugin = await prisma.plugin.create({
     *   data: {
     *     // ... data to create a Plugin
     *   }
     * })
     * 
     */
    create<T extends pluginCreateArgs>(args: SelectSubset<T, pluginCreateArgs<ExtArgs>>): Prisma__pluginClient<$Result.GetResult<Prisma.$pluginPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plugins.
     * @param {pluginCreateManyArgs} args - Arguments to create many Plugins.
     * @example
     * // Create many Plugins
     * const plugin = await prisma.plugin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pluginCreateManyArgs>(args?: SelectSubset<T, pluginCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plugins and returns the data saved in the database.
     * @param {pluginCreateManyAndReturnArgs} args - Arguments to create many Plugins.
     * @example
     * // Create many Plugins
     * const plugin = await prisma.plugin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plugins and only return the `id`
     * const pluginWithIdOnly = await prisma.plugin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pluginCreateManyAndReturnArgs>(args?: SelectSubset<T, pluginCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pluginPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Plugin.
     * @param {pluginDeleteArgs} args - Arguments to delete one Plugin.
     * @example
     * // Delete one Plugin
     * const Plugin = await prisma.plugin.delete({
     *   where: {
     *     // ... filter to delete one Plugin
     *   }
     * })
     * 
     */
    delete<T extends pluginDeleteArgs>(args: SelectSubset<T, pluginDeleteArgs<ExtArgs>>): Prisma__pluginClient<$Result.GetResult<Prisma.$pluginPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plugin.
     * @param {pluginUpdateArgs} args - Arguments to update one Plugin.
     * @example
     * // Update one Plugin
     * const plugin = await prisma.plugin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pluginUpdateArgs>(args: SelectSubset<T, pluginUpdateArgs<ExtArgs>>): Prisma__pluginClient<$Result.GetResult<Prisma.$pluginPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plugins.
     * @param {pluginDeleteManyArgs} args - Arguments to filter Plugins to delete.
     * @example
     * // Delete a few Plugins
     * const { count } = await prisma.plugin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pluginDeleteManyArgs>(args?: SelectSubset<T, pluginDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plugins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pluginUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plugins
     * const plugin = await prisma.plugin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pluginUpdateManyArgs>(args: SelectSubset<T, pluginUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plugins and returns the data updated in the database.
     * @param {pluginUpdateManyAndReturnArgs} args - Arguments to update many Plugins.
     * @example
     * // Update many Plugins
     * const plugin = await prisma.plugin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Plugins and only return the `id`
     * const pluginWithIdOnly = await prisma.plugin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends pluginUpdateManyAndReturnArgs>(args: SelectSubset<T, pluginUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pluginPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Plugin.
     * @param {pluginUpsertArgs} args - Arguments to update or create a Plugin.
     * @example
     * // Update or create a Plugin
     * const plugin = await prisma.plugin.upsert({
     *   create: {
     *     // ... data to create a Plugin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plugin we want to update
     *   }
     * })
     */
    upsert<T extends pluginUpsertArgs>(args: SelectSubset<T, pluginUpsertArgs<ExtArgs>>): Prisma__pluginClient<$Result.GetResult<Prisma.$pluginPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plugins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pluginCountArgs} args - Arguments to filter Plugins to count.
     * @example
     * // Count the number of Plugins
     * const count = await prisma.plugin.count({
     *   where: {
     *     // ... the filter for the Plugins we want to count
     *   }
     * })
    **/
    count<T extends pluginCountArgs>(
      args?: Subset<T, pluginCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PluginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plugin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PluginAggregateArgs>(args: Subset<T, PluginAggregateArgs>): Prisma.PrismaPromise<GetPluginAggregateType<T>>

    /**
     * Group by Plugin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pluginGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pluginGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pluginGroupByArgs['orderBy'] }
        : { orderBy?: pluginGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pluginGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPluginGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the plugin model
   */
  readonly fields: pluginFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for plugin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pluginClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the plugin model
   */
  interface pluginFieldRefs {
    readonly id: FieldRef<"plugin", 'Int'>
    readonly metadata: FieldRef<"plugin", 'Json'>
    readonly path: FieldRef<"plugin", 'String'>
    readonly isUse: FieldRef<"plugin", 'Boolean'>
    readonly isDev: FieldRef<"plugin", 'Boolean'>
    readonly createdAt: FieldRef<"plugin", 'DateTime'>
    readonly updatedAt: FieldRef<"plugin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * plugin findUnique
   */
  export type pluginFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plugin
     */
    select?: pluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plugin
     */
    omit?: pluginOmit<ExtArgs> | null
    /**
     * Filter, which plugin to fetch.
     */
    where: pluginWhereUniqueInput
  }

  /**
   * plugin findUniqueOrThrow
   */
  export type pluginFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plugin
     */
    select?: pluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plugin
     */
    omit?: pluginOmit<ExtArgs> | null
    /**
     * Filter, which plugin to fetch.
     */
    where: pluginWhereUniqueInput
  }

  /**
   * plugin findFirst
   */
  export type pluginFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plugin
     */
    select?: pluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plugin
     */
    omit?: pluginOmit<ExtArgs> | null
    /**
     * Filter, which plugin to fetch.
     */
    where?: pluginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plugins to fetch.
     */
    orderBy?: pluginOrderByWithRelationInput | pluginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plugins.
     */
    cursor?: pluginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plugins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plugins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plugins.
     */
    distinct?: PluginScalarFieldEnum | PluginScalarFieldEnum[]
  }

  /**
   * plugin findFirstOrThrow
   */
  export type pluginFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plugin
     */
    select?: pluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plugin
     */
    omit?: pluginOmit<ExtArgs> | null
    /**
     * Filter, which plugin to fetch.
     */
    where?: pluginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plugins to fetch.
     */
    orderBy?: pluginOrderByWithRelationInput | pluginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plugins.
     */
    cursor?: pluginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plugins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plugins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plugins.
     */
    distinct?: PluginScalarFieldEnum | PluginScalarFieldEnum[]
  }

  /**
   * plugin findMany
   */
  export type pluginFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plugin
     */
    select?: pluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plugin
     */
    omit?: pluginOmit<ExtArgs> | null
    /**
     * Filter, which plugins to fetch.
     */
    where?: pluginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plugins to fetch.
     */
    orderBy?: pluginOrderByWithRelationInput | pluginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plugins.
     */
    cursor?: pluginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plugins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plugins.
     */
    skip?: number
    distinct?: PluginScalarFieldEnum | PluginScalarFieldEnum[]
  }

  /**
   * plugin create
   */
  export type pluginCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plugin
     */
    select?: pluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plugin
     */
    omit?: pluginOmit<ExtArgs> | null
    /**
     * The data needed to create a plugin.
     */
    data: XOR<pluginCreateInput, pluginUncheckedCreateInput>
  }

  /**
   * plugin createMany
   */
  export type pluginCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many plugins.
     */
    data: pluginCreateManyInput | pluginCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * plugin createManyAndReturn
   */
  export type pluginCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plugin
     */
    select?: pluginSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the plugin
     */
    omit?: pluginOmit<ExtArgs> | null
    /**
     * The data used to create many plugins.
     */
    data: pluginCreateManyInput | pluginCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * plugin update
   */
  export type pluginUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plugin
     */
    select?: pluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plugin
     */
    omit?: pluginOmit<ExtArgs> | null
    /**
     * The data needed to update a plugin.
     */
    data: XOR<pluginUpdateInput, pluginUncheckedUpdateInput>
    /**
     * Choose, which plugin to update.
     */
    where: pluginWhereUniqueInput
  }

  /**
   * plugin updateMany
   */
  export type pluginUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update plugins.
     */
    data: XOR<pluginUpdateManyMutationInput, pluginUncheckedUpdateManyInput>
    /**
     * Filter which plugins to update
     */
    where?: pluginWhereInput
    /**
     * Limit how many plugins to update.
     */
    limit?: number
  }

  /**
   * plugin updateManyAndReturn
   */
  export type pluginUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plugin
     */
    select?: pluginSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the plugin
     */
    omit?: pluginOmit<ExtArgs> | null
    /**
     * The data used to update plugins.
     */
    data: XOR<pluginUpdateManyMutationInput, pluginUncheckedUpdateManyInput>
    /**
     * Filter which plugins to update
     */
    where?: pluginWhereInput
    /**
     * Limit how many plugins to update.
     */
    limit?: number
  }

  /**
   * plugin upsert
   */
  export type pluginUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plugin
     */
    select?: pluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plugin
     */
    omit?: pluginOmit<ExtArgs> | null
    /**
     * The filter to search for the plugin to update in case it exists.
     */
    where: pluginWhereUniqueInput
    /**
     * In case the plugin found by the `where` argument doesn't exist, create a new plugin with this data.
     */
    create: XOR<pluginCreateInput, pluginUncheckedCreateInput>
    /**
     * In case the plugin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pluginUpdateInput, pluginUncheckedUpdateInput>
  }

  /**
   * plugin delete
   */
  export type pluginDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plugin
     */
    select?: pluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plugin
     */
    omit?: pluginOmit<ExtArgs> | null
    /**
     * Filter which plugin to delete.
     */
    where: pluginWhereUniqueInput
  }

  /**
   * plugin deleteMany
   */
  export type pluginDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plugins to delete
     */
    where?: pluginWhereInput
    /**
     * Limit how many plugins to delete.
     */
    limit?: number
  }

  /**
   * plugin without action
   */
  export type pluginDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plugin
     */
    select?: pluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plugin
     */
    omit?: pluginOmit<ExtArgs> | null
  }


  /**
   * Model conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _avg: ConversationAvgAggregateOutputType | null
    _sum: ConversationSumAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationAvgAggregateOutputType = {
    id: number | null
    accountId: number | null
  }

  export type ConversationSumAggregateOutputType = {
    id: number | null
    accountId: number | null
  }

  export type ConversationMinAggregateOutputType = {
    id: number | null
    title: string | null
    isShare: boolean | null
    accountId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: number | null
    title: string | null
    isShare: boolean | null
    accountId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    title: number
    isShare: number
    accountId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConversationAvgAggregateInputType = {
    id?: true
    accountId?: true
  }

  export type ConversationSumAggregateInputType = {
    id?: true
    accountId?: true
  }

  export type ConversationMinAggregateInputType = {
    id?: true
    title?: true
    isShare?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    title?: true
    isShare?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    title?: true
    isShare?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conversation to aggregate.
     */
    where?: conversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationOrderByWithRelationInput | conversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: conversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConversationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConversationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type conversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conversationWhereInput
    orderBy?: conversationOrderByWithAggregationInput | conversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: conversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _avg?: ConversationAvgAggregateInputType
    _sum?: ConversationSumAggregateInputType
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: number
    title: string
    isShare: boolean
    accountId: number
    createdAt: Date
    updatedAt: Date
    _count: ConversationCountAggregateOutputType | null
    _avg: ConversationAvgAggregateOutputType | null
    _sum: ConversationSumAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends conversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type conversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    isShare?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    messages?: boolean | conversation$messagesArgs<ExtArgs>
    account?: boolean | accountsDefaultArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type conversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    isShare?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type conversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    isShare?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type conversationSelectScalar = {
    id?: boolean
    title?: boolean
    isShare?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type conversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "isShare" | "accountId" | "createdAt" | "updatedAt", ExtArgs["result"]["conversation"]>
  export type conversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | conversation$messagesArgs<ExtArgs>
    account?: boolean | accountsDefaultArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type conversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }
  export type conversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }

  export type $conversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "conversation"
    objects: {
      messages: Prisma.$messagePayload<ExtArgs>[]
      account: Prisma.$accountsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      isShare: boolean
      accountId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type conversationGetPayload<S extends boolean | null | undefined | conversationDefaultArgs> = $Result.GetResult<Prisma.$conversationPayload, S>

  type conversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<conversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface conversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['conversation'], meta: { name: 'conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {conversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends conversationFindUniqueArgs>(args: SelectSubset<T, conversationFindUniqueArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {conversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends conversationFindUniqueOrThrowArgs>(args: SelectSubset<T, conversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends conversationFindFirstArgs>(args?: SelectSubset<T, conversationFindFirstArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends conversationFindFirstOrThrowArgs>(args?: SelectSubset<T, conversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends conversationFindManyArgs>(args?: SelectSubset<T, conversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conversation.
     * @param {conversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends conversationCreateArgs>(args: SelectSubset<T, conversationCreateArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conversations.
     * @param {conversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends conversationCreateManyArgs>(args?: SelectSubset<T, conversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {conversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends conversationCreateManyAndReturnArgs>(args?: SelectSubset<T, conversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conversation.
     * @param {conversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends conversationDeleteArgs>(args: SelectSubset<T, conversationDeleteArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conversation.
     * @param {conversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends conversationUpdateArgs>(args: SelectSubset<T, conversationUpdateArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conversations.
     * @param {conversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends conversationDeleteManyArgs>(args?: SelectSubset<T, conversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends conversationUpdateManyArgs>(args: SelectSubset<T, conversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations and returns the data updated in the database.
     * @param {conversationUpdateManyAndReturnArgs} args - Arguments to update many Conversations.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends conversationUpdateManyAndReturnArgs>(args: SelectSubset<T, conversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conversation.
     * @param {conversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends conversationUpsertArgs>(args: SelectSubset<T, conversationUpsertArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends conversationCountArgs>(
      args?: Subset<T, conversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends conversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: conversationGroupByArgs['orderBy'] }
        : { orderBy?: conversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, conversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the conversation model
   */
  readonly fields: conversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__conversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages<T extends conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    account<T extends accountsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, accountsDefaultArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the conversation model
   */
  interface conversationFieldRefs {
    readonly id: FieldRef<"conversation", 'Int'>
    readonly title: FieldRef<"conversation", 'String'>
    readonly isShare: FieldRef<"conversation", 'Boolean'>
    readonly accountId: FieldRef<"conversation", 'Int'>
    readonly createdAt: FieldRef<"conversation", 'DateTime'>
    readonly updatedAt: FieldRef<"conversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * conversation findUnique
   */
  export type conversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    /**
     * Filter, which conversation to fetch.
     */
    where: conversationWhereUniqueInput
  }

  /**
   * conversation findUniqueOrThrow
   */
  export type conversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    /**
     * Filter, which conversation to fetch.
     */
    where: conversationWhereUniqueInput
  }

  /**
   * conversation findFirst
   */
  export type conversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    /**
     * Filter, which conversation to fetch.
     */
    where?: conversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationOrderByWithRelationInput | conversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conversations.
     */
    cursor?: conversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * conversation findFirstOrThrow
   */
  export type conversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    /**
     * Filter, which conversation to fetch.
     */
    where?: conversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationOrderByWithRelationInput | conversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conversations.
     */
    cursor?: conversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * conversation findMany
   */
  export type conversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    /**
     * Filter, which conversations to fetch.
     */
    where?: conversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationOrderByWithRelationInput | conversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing conversations.
     */
    cursor?: conversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * conversation create
   */
  export type conversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    /**
     * The data needed to create a conversation.
     */
    data: XOR<conversationCreateInput, conversationUncheckedCreateInput>
  }

  /**
   * conversation createMany
   */
  export type conversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many conversations.
     */
    data: conversationCreateManyInput | conversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * conversation createManyAndReturn
   */
  export type conversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * The data used to create many conversations.
     */
    data: conversationCreateManyInput | conversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * conversation update
   */
  export type conversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    /**
     * The data needed to update a conversation.
     */
    data: XOR<conversationUpdateInput, conversationUncheckedUpdateInput>
    /**
     * Choose, which conversation to update.
     */
    where: conversationWhereUniqueInput
  }

  /**
   * conversation updateMany
   */
  export type conversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update conversations.
     */
    data: XOR<conversationUpdateManyMutationInput, conversationUncheckedUpdateManyInput>
    /**
     * Filter which conversations to update
     */
    where?: conversationWhereInput
    /**
     * Limit how many conversations to update.
     */
    limit?: number
  }

  /**
   * conversation updateManyAndReturn
   */
  export type conversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * The data used to update conversations.
     */
    data: XOR<conversationUpdateManyMutationInput, conversationUncheckedUpdateManyInput>
    /**
     * Filter which conversations to update
     */
    where?: conversationWhereInput
    /**
     * Limit how many conversations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * conversation upsert
   */
  export type conversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    /**
     * The filter to search for the conversation to update in case it exists.
     */
    where: conversationWhereUniqueInput
    /**
     * In case the conversation found by the `where` argument doesn't exist, create a new conversation with this data.
     */
    create: XOR<conversationCreateInput, conversationUncheckedCreateInput>
    /**
     * In case the conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<conversationUpdateInput, conversationUncheckedUpdateInput>
  }

  /**
   * conversation delete
   */
  export type conversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    /**
     * Filter which conversation to delete.
     */
    where: conversationWhereUniqueInput
  }

  /**
   * conversation deleteMany
   */
  export type conversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conversations to delete
     */
    where?: conversationWhereInput
    /**
     * Limit how many conversations to delete.
     */
    limit?: number
  }

  /**
   * conversation.messages
   */
  export type conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    where?: messageWhereInput
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    cursor?: messageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * conversation without action
   */
  export type conversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
  }


  /**
   * Model message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    id: number | null
    conversationId: number | null
  }

  export type MessageSumAggregateOutputType = {
    id: number | null
    conversationId: number | null
  }

  export type MessageMinAggregateOutputType = {
    id: number | null
    content: string | null
    role: string | null
    conversationId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: number | null
    content: string | null
    role: string | null
    conversationId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    content: number
    role: number
    conversationId: number
    createdAt: number
    updatedAt: number
    metadata: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    id?: true
    conversationId?: true
  }

  export type MessageSumAggregateInputType = {
    id?: true
    conversationId?: true
  }

  export type MessageMinAggregateInputType = {
    id?: true
    content?: true
    role?: true
    conversationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    content?: true
    role?: true
    conversationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    content?: true
    role?: true
    conversationId?: true
    createdAt?: true
    updatedAt?: true
    metadata?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which message to aggregate.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type messageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messageWhereInput
    orderBy?: messageOrderByWithAggregationInput | messageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: messageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: number
    content: string
    role: string
    conversationId: number
    createdAt: Date
    updatedAt: Date
    metadata: JsonValue | null
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends messageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type messageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    role?: boolean
    conversationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
    conversation?: boolean | conversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type messageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    role?: boolean
    conversationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
    conversation?: boolean | conversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type messageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    role?: boolean
    conversationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
    conversation?: boolean | conversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type messageSelectScalar = {
    id?: boolean
    content?: boolean
    role?: boolean
    conversationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
  }

  export type messageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "role" | "conversationId" | "createdAt" | "updatedAt" | "metadata", ExtArgs["result"]["message"]>
  export type messageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | conversationDefaultArgs<ExtArgs>
  }
  export type messageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | conversationDefaultArgs<ExtArgs>
  }
  export type messageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | conversationDefaultArgs<ExtArgs>
  }

  export type $messagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "message"
    objects: {
      conversation: Prisma.$conversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      content: string
      role: string
      conversationId: number
      createdAt: Date
      updatedAt: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type messageGetPayload<S extends boolean | null | undefined | messageDefaultArgs> = $Result.GetResult<Prisma.$messagePayload, S>

  type messageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<messageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface messageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['message'], meta: { name: 'message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {messageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends messageFindUniqueArgs>(args: SelectSubset<T, messageFindUniqueArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {messageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends messageFindUniqueOrThrowArgs>(args: SelectSubset<T, messageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends messageFindFirstArgs>(args?: SelectSubset<T, messageFindFirstArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends messageFindFirstOrThrowArgs>(args?: SelectSubset<T, messageFindFirstOrThrowArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends messageFindManyArgs>(args?: SelectSubset<T, messageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {messageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends messageCreateArgs>(args: SelectSubset<T, messageCreateArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {messageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends messageCreateManyArgs>(args?: SelectSubset<T, messageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {messageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends messageCreateManyAndReturnArgs>(args?: SelectSubset<T, messageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {messageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends messageDeleteArgs>(args: SelectSubset<T, messageDeleteArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {messageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends messageUpdateArgs>(args: SelectSubset<T, messageUpdateArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {messageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends messageDeleteManyArgs>(args?: SelectSubset<T, messageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends messageUpdateManyArgs>(args: SelectSubset<T, messageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {messageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends messageUpdateManyAndReturnArgs>(args: SelectSubset<T, messageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {messageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends messageUpsertArgs>(args: SelectSubset<T, messageUpsertArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends messageCountArgs>(
      args?: Subset<T, messageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends messageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: messageGroupByArgs['orderBy'] }
        : { orderBy?: messageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, messageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the message model
   */
  readonly fields: messageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__messageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends conversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, conversationDefaultArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the message model
   */
  interface messageFieldRefs {
    readonly id: FieldRef<"message", 'Int'>
    readonly content: FieldRef<"message", 'String'>
    readonly role: FieldRef<"message", 'String'>
    readonly conversationId: FieldRef<"message", 'Int'>
    readonly createdAt: FieldRef<"message", 'DateTime'>
    readonly updatedAt: FieldRef<"message", 'DateTime'>
    readonly metadata: FieldRef<"message", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * message findUnique
   */
  export type messageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where: messageWhereUniqueInput
  }

  /**
   * message findUniqueOrThrow
   */
  export type messageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where: messageWhereUniqueInput
  }

  /**
   * message findFirst
   */
  export type messageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * message findFirstOrThrow
   */
  export type messageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * message findMany
   */
  export type messageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing messages.
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * message create
   */
  export type messageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * The data needed to create a message.
     */
    data: XOR<messageCreateInput, messageUncheckedCreateInput>
  }

  /**
   * message createMany
   */
  export type messageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many messages.
     */
    data: messageCreateManyInput | messageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * message createManyAndReturn
   */
  export type messageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * The data used to create many messages.
     */
    data: messageCreateManyInput | messageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * message update
   */
  export type messageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * The data needed to update a message.
     */
    data: XOR<messageUpdateInput, messageUncheckedUpdateInput>
    /**
     * Choose, which message to update.
     */
    where: messageWhereUniqueInput
  }

  /**
   * message updateMany
   */
  export type messageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update messages.
     */
    data: XOR<messageUpdateManyMutationInput, messageUncheckedUpdateManyInput>
    /**
     * Filter which messages to update
     */
    where?: messageWhereInput
    /**
     * Limit how many messages to update.
     */
    limit?: number
  }

  /**
   * message updateManyAndReturn
   */
  export type messageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * The data used to update messages.
     */
    data: XOR<messageUpdateManyMutationInput, messageUncheckedUpdateManyInput>
    /**
     * Filter which messages to update
     */
    where?: messageWhereInput
    /**
     * Limit how many messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * message upsert
   */
  export type messageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * The filter to search for the message to update in case it exists.
     */
    where: messageWhereUniqueInput
    /**
     * In case the message found by the `where` argument doesn't exist, create a new message with this data.
     */
    create: XOR<messageCreateInput, messageUncheckedCreateInput>
    /**
     * In case the message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<messageUpdateInput, messageUncheckedUpdateInput>
  }

  /**
   * message delete
   */
  export type messageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter which message to delete.
     */
    where: messageWhereUniqueInput
  }

  /**
   * message deleteMany
   */
  export type messageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which messages to delete
     */
    where?: messageWhereInput
    /**
     * Limit how many messages to delete.
     */
    limit?: number
  }

  /**
   * message without action
   */
  export type messageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
  }


  /**
   * Model noteHistory
   */

  export type AggregateNoteHistory = {
    _count: NoteHistoryCountAggregateOutputType | null
    _avg: NoteHistoryAvgAggregateOutputType | null
    _sum: NoteHistorySumAggregateOutputType | null
    _min: NoteHistoryMinAggregateOutputType | null
    _max: NoteHistoryMaxAggregateOutputType | null
  }

  export type NoteHistoryAvgAggregateOutputType = {
    id: number | null
    noteId: number | null
    version: number | null
    accountId: number | null
  }

  export type NoteHistorySumAggregateOutputType = {
    id: number | null
    noteId: number | null
    version: number | null
    accountId: number | null
  }

  export type NoteHistoryMinAggregateOutputType = {
    id: number | null
    noteId: number | null
    content: string | null
    version: number | null
    accountId: number | null
    createdAt: Date | null
  }

  export type NoteHistoryMaxAggregateOutputType = {
    id: number | null
    noteId: number | null
    content: string | null
    version: number | null
    accountId: number | null
    createdAt: Date | null
  }

  export type NoteHistoryCountAggregateOutputType = {
    id: number
    noteId: number
    content: number
    metadata: number
    version: number
    accountId: number
    createdAt: number
    _all: number
  }


  export type NoteHistoryAvgAggregateInputType = {
    id?: true
    noteId?: true
    version?: true
    accountId?: true
  }

  export type NoteHistorySumAggregateInputType = {
    id?: true
    noteId?: true
    version?: true
    accountId?: true
  }

  export type NoteHistoryMinAggregateInputType = {
    id?: true
    noteId?: true
    content?: true
    version?: true
    accountId?: true
    createdAt?: true
  }

  export type NoteHistoryMaxAggregateInputType = {
    id?: true
    noteId?: true
    content?: true
    version?: true
    accountId?: true
    createdAt?: true
  }

  export type NoteHistoryCountAggregateInputType = {
    id?: true
    noteId?: true
    content?: true
    metadata?: true
    version?: true
    accountId?: true
    createdAt?: true
    _all?: true
  }

  export type NoteHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which noteHistory to aggregate.
     */
    where?: noteHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of noteHistories to fetch.
     */
    orderBy?: noteHistoryOrderByWithRelationInput | noteHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: noteHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` noteHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` noteHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned noteHistories
    **/
    _count?: true | NoteHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoteHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoteHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoteHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoteHistoryMaxAggregateInputType
  }

  export type GetNoteHistoryAggregateType<T extends NoteHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateNoteHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNoteHistory[P]>
      : GetScalarType<T[P], AggregateNoteHistory[P]>
  }




  export type noteHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: noteHistoryWhereInput
    orderBy?: noteHistoryOrderByWithAggregationInput | noteHistoryOrderByWithAggregationInput[]
    by: NoteHistoryScalarFieldEnum[] | NoteHistoryScalarFieldEnum
    having?: noteHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoteHistoryCountAggregateInputType | true
    _avg?: NoteHistoryAvgAggregateInputType
    _sum?: NoteHistorySumAggregateInputType
    _min?: NoteHistoryMinAggregateInputType
    _max?: NoteHistoryMaxAggregateInputType
  }

  export type NoteHistoryGroupByOutputType = {
    id: number
    noteId: number
    content: string
    metadata: JsonValue | null
    version: number
    accountId: number | null
    createdAt: Date
    _count: NoteHistoryCountAggregateOutputType | null
    _avg: NoteHistoryAvgAggregateOutputType | null
    _sum: NoteHistorySumAggregateOutputType | null
    _min: NoteHistoryMinAggregateOutputType | null
    _max: NoteHistoryMaxAggregateOutputType | null
  }

  type GetNoteHistoryGroupByPayload<T extends noteHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoteHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoteHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoteHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], NoteHistoryGroupByOutputType[P]>
        }
      >
    >


  export type noteHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    noteId?: boolean
    content?: boolean
    metadata?: boolean
    version?: boolean
    accountId?: boolean
    createdAt?: boolean
    note?: boolean | notesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["noteHistory"]>

  export type noteHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    noteId?: boolean
    content?: boolean
    metadata?: boolean
    version?: boolean
    accountId?: boolean
    createdAt?: boolean
    note?: boolean | notesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["noteHistory"]>

  export type noteHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    noteId?: boolean
    content?: boolean
    metadata?: boolean
    version?: boolean
    accountId?: boolean
    createdAt?: boolean
    note?: boolean | notesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["noteHistory"]>

  export type noteHistorySelectScalar = {
    id?: boolean
    noteId?: boolean
    content?: boolean
    metadata?: boolean
    version?: boolean
    accountId?: boolean
    createdAt?: boolean
  }

  export type noteHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "noteId" | "content" | "metadata" | "version" | "accountId" | "createdAt", ExtArgs["result"]["noteHistory"]>
  export type noteHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note?: boolean | notesDefaultArgs<ExtArgs>
  }
  export type noteHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note?: boolean | notesDefaultArgs<ExtArgs>
  }
  export type noteHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note?: boolean | notesDefaultArgs<ExtArgs>
  }

  export type $noteHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "noteHistory"
    objects: {
      note: Prisma.$notesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      noteId: number
      content: string
      metadata: Prisma.JsonValue | null
      version: number
      accountId: number | null
      createdAt: Date
    }, ExtArgs["result"]["noteHistory"]>
    composites: {}
  }

  type noteHistoryGetPayload<S extends boolean | null | undefined | noteHistoryDefaultArgs> = $Result.GetResult<Prisma.$noteHistoryPayload, S>

  type noteHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<noteHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NoteHistoryCountAggregateInputType | true
    }

  export interface noteHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['noteHistory'], meta: { name: 'noteHistory' } }
    /**
     * Find zero or one NoteHistory that matches the filter.
     * @param {noteHistoryFindUniqueArgs} args - Arguments to find a NoteHistory
     * @example
     * // Get one NoteHistory
     * const noteHistory = await prisma.noteHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends noteHistoryFindUniqueArgs>(args: SelectSubset<T, noteHistoryFindUniqueArgs<ExtArgs>>): Prisma__noteHistoryClient<$Result.GetResult<Prisma.$noteHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NoteHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {noteHistoryFindUniqueOrThrowArgs} args - Arguments to find a NoteHistory
     * @example
     * // Get one NoteHistory
     * const noteHistory = await prisma.noteHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends noteHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, noteHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__noteHistoryClient<$Result.GetResult<Prisma.$noteHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NoteHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteHistoryFindFirstArgs} args - Arguments to find a NoteHistory
     * @example
     * // Get one NoteHistory
     * const noteHistory = await prisma.noteHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends noteHistoryFindFirstArgs>(args?: SelectSubset<T, noteHistoryFindFirstArgs<ExtArgs>>): Prisma__noteHistoryClient<$Result.GetResult<Prisma.$noteHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NoteHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteHistoryFindFirstOrThrowArgs} args - Arguments to find a NoteHistory
     * @example
     * // Get one NoteHistory
     * const noteHistory = await prisma.noteHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends noteHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, noteHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__noteHistoryClient<$Result.GetResult<Prisma.$noteHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NoteHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NoteHistories
     * const noteHistories = await prisma.noteHistory.findMany()
     * 
     * // Get first 10 NoteHistories
     * const noteHistories = await prisma.noteHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noteHistoryWithIdOnly = await prisma.noteHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends noteHistoryFindManyArgs>(args?: SelectSubset<T, noteHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$noteHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NoteHistory.
     * @param {noteHistoryCreateArgs} args - Arguments to create a NoteHistory.
     * @example
     * // Create one NoteHistory
     * const NoteHistory = await prisma.noteHistory.create({
     *   data: {
     *     // ... data to create a NoteHistory
     *   }
     * })
     * 
     */
    create<T extends noteHistoryCreateArgs>(args: SelectSubset<T, noteHistoryCreateArgs<ExtArgs>>): Prisma__noteHistoryClient<$Result.GetResult<Prisma.$noteHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NoteHistories.
     * @param {noteHistoryCreateManyArgs} args - Arguments to create many NoteHistories.
     * @example
     * // Create many NoteHistories
     * const noteHistory = await prisma.noteHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends noteHistoryCreateManyArgs>(args?: SelectSubset<T, noteHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NoteHistories and returns the data saved in the database.
     * @param {noteHistoryCreateManyAndReturnArgs} args - Arguments to create many NoteHistories.
     * @example
     * // Create many NoteHistories
     * const noteHistory = await prisma.noteHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NoteHistories and only return the `id`
     * const noteHistoryWithIdOnly = await prisma.noteHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends noteHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, noteHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$noteHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NoteHistory.
     * @param {noteHistoryDeleteArgs} args - Arguments to delete one NoteHistory.
     * @example
     * // Delete one NoteHistory
     * const NoteHistory = await prisma.noteHistory.delete({
     *   where: {
     *     // ... filter to delete one NoteHistory
     *   }
     * })
     * 
     */
    delete<T extends noteHistoryDeleteArgs>(args: SelectSubset<T, noteHistoryDeleteArgs<ExtArgs>>): Prisma__noteHistoryClient<$Result.GetResult<Prisma.$noteHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NoteHistory.
     * @param {noteHistoryUpdateArgs} args - Arguments to update one NoteHistory.
     * @example
     * // Update one NoteHistory
     * const noteHistory = await prisma.noteHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends noteHistoryUpdateArgs>(args: SelectSubset<T, noteHistoryUpdateArgs<ExtArgs>>): Prisma__noteHistoryClient<$Result.GetResult<Prisma.$noteHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NoteHistories.
     * @param {noteHistoryDeleteManyArgs} args - Arguments to filter NoteHistories to delete.
     * @example
     * // Delete a few NoteHistories
     * const { count } = await prisma.noteHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends noteHistoryDeleteManyArgs>(args?: SelectSubset<T, noteHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NoteHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NoteHistories
     * const noteHistory = await prisma.noteHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends noteHistoryUpdateManyArgs>(args: SelectSubset<T, noteHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NoteHistories and returns the data updated in the database.
     * @param {noteHistoryUpdateManyAndReturnArgs} args - Arguments to update many NoteHistories.
     * @example
     * // Update many NoteHistories
     * const noteHistory = await prisma.noteHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NoteHistories and only return the `id`
     * const noteHistoryWithIdOnly = await prisma.noteHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends noteHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, noteHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$noteHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NoteHistory.
     * @param {noteHistoryUpsertArgs} args - Arguments to update or create a NoteHistory.
     * @example
     * // Update or create a NoteHistory
     * const noteHistory = await prisma.noteHistory.upsert({
     *   create: {
     *     // ... data to create a NoteHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NoteHistory we want to update
     *   }
     * })
     */
    upsert<T extends noteHistoryUpsertArgs>(args: SelectSubset<T, noteHistoryUpsertArgs<ExtArgs>>): Prisma__noteHistoryClient<$Result.GetResult<Prisma.$noteHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NoteHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteHistoryCountArgs} args - Arguments to filter NoteHistories to count.
     * @example
     * // Count the number of NoteHistories
     * const count = await prisma.noteHistory.count({
     *   where: {
     *     // ... the filter for the NoteHistories we want to count
     *   }
     * })
    **/
    count<T extends noteHistoryCountArgs>(
      args?: Subset<T, noteHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoteHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NoteHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoteHistoryAggregateArgs>(args: Subset<T, NoteHistoryAggregateArgs>): Prisma.PrismaPromise<GetNoteHistoryAggregateType<T>>

    /**
     * Group by NoteHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends noteHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: noteHistoryGroupByArgs['orderBy'] }
        : { orderBy?: noteHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, noteHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoteHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the noteHistory model
   */
  readonly fields: noteHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for noteHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__noteHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    note<T extends notesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, notesDefaultArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the noteHistory model
   */
  interface noteHistoryFieldRefs {
    readonly id: FieldRef<"noteHistory", 'Int'>
    readonly noteId: FieldRef<"noteHistory", 'Int'>
    readonly content: FieldRef<"noteHistory", 'String'>
    readonly metadata: FieldRef<"noteHistory", 'Json'>
    readonly version: FieldRef<"noteHistory", 'Int'>
    readonly accountId: FieldRef<"noteHistory", 'Int'>
    readonly createdAt: FieldRef<"noteHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * noteHistory findUnique
   */
  export type noteHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteHistory
     */
    select?: noteHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteHistory
     */
    omit?: noteHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteHistoryInclude<ExtArgs> | null
    /**
     * Filter, which noteHistory to fetch.
     */
    where: noteHistoryWhereUniqueInput
  }

  /**
   * noteHistory findUniqueOrThrow
   */
  export type noteHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteHistory
     */
    select?: noteHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteHistory
     */
    omit?: noteHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteHistoryInclude<ExtArgs> | null
    /**
     * Filter, which noteHistory to fetch.
     */
    where: noteHistoryWhereUniqueInput
  }

  /**
   * noteHistory findFirst
   */
  export type noteHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteHistory
     */
    select?: noteHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteHistory
     */
    omit?: noteHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteHistoryInclude<ExtArgs> | null
    /**
     * Filter, which noteHistory to fetch.
     */
    where?: noteHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of noteHistories to fetch.
     */
    orderBy?: noteHistoryOrderByWithRelationInput | noteHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for noteHistories.
     */
    cursor?: noteHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` noteHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` noteHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of noteHistories.
     */
    distinct?: NoteHistoryScalarFieldEnum | NoteHistoryScalarFieldEnum[]
  }

  /**
   * noteHistory findFirstOrThrow
   */
  export type noteHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteHistory
     */
    select?: noteHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteHistory
     */
    omit?: noteHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteHistoryInclude<ExtArgs> | null
    /**
     * Filter, which noteHistory to fetch.
     */
    where?: noteHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of noteHistories to fetch.
     */
    orderBy?: noteHistoryOrderByWithRelationInput | noteHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for noteHistories.
     */
    cursor?: noteHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` noteHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` noteHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of noteHistories.
     */
    distinct?: NoteHistoryScalarFieldEnum | NoteHistoryScalarFieldEnum[]
  }

  /**
   * noteHistory findMany
   */
  export type noteHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteHistory
     */
    select?: noteHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteHistory
     */
    omit?: noteHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteHistoryInclude<ExtArgs> | null
    /**
     * Filter, which noteHistories to fetch.
     */
    where?: noteHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of noteHistories to fetch.
     */
    orderBy?: noteHistoryOrderByWithRelationInput | noteHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing noteHistories.
     */
    cursor?: noteHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` noteHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` noteHistories.
     */
    skip?: number
    distinct?: NoteHistoryScalarFieldEnum | NoteHistoryScalarFieldEnum[]
  }

  /**
   * noteHistory create
   */
  export type noteHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteHistory
     */
    select?: noteHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteHistory
     */
    omit?: noteHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a noteHistory.
     */
    data: XOR<noteHistoryCreateInput, noteHistoryUncheckedCreateInput>
  }

  /**
   * noteHistory createMany
   */
  export type noteHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many noteHistories.
     */
    data: noteHistoryCreateManyInput | noteHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * noteHistory createManyAndReturn
   */
  export type noteHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteHistory
     */
    select?: noteHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the noteHistory
     */
    omit?: noteHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many noteHistories.
     */
    data: noteHistoryCreateManyInput | noteHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * noteHistory update
   */
  export type noteHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteHistory
     */
    select?: noteHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteHistory
     */
    omit?: noteHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a noteHistory.
     */
    data: XOR<noteHistoryUpdateInput, noteHistoryUncheckedUpdateInput>
    /**
     * Choose, which noteHistory to update.
     */
    where: noteHistoryWhereUniqueInput
  }

  /**
   * noteHistory updateMany
   */
  export type noteHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update noteHistories.
     */
    data: XOR<noteHistoryUpdateManyMutationInput, noteHistoryUncheckedUpdateManyInput>
    /**
     * Filter which noteHistories to update
     */
    where?: noteHistoryWhereInput
    /**
     * Limit how many noteHistories to update.
     */
    limit?: number
  }

  /**
   * noteHistory updateManyAndReturn
   */
  export type noteHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteHistory
     */
    select?: noteHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the noteHistory
     */
    omit?: noteHistoryOmit<ExtArgs> | null
    /**
     * The data used to update noteHistories.
     */
    data: XOR<noteHistoryUpdateManyMutationInput, noteHistoryUncheckedUpdateManyInput>
    /**
     * Filter which noteHistories to update
     */
    where?: noteHistoryWhereInput
    /**
     * Limit how many noteHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * noteHistory upsert
   */
  export type noteHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteHistory
     */
    select?: noteHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteHistory
     */
    omit?: noteHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the noteHistory to update in case it exists.
     */
    where: noteHistoryWhereUniqueInput
    /**
     * In case the noteHistory found by the `where` argument doesn't exist, create a new noteHistory with this data.
     */
    create: XOR<noteHistoryCreateInput, noteHistoryUncheckedCreateInput>
    /**
     * In case the noteHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<noteHistoryUpdateInput, noteHistoryUncheckedUpdateInput>
  }

  /**
   * noteHistory delete
   */
  export type noteHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteHistory
     */
    select?: noteHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteHistory
     */
    omit?: noteHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteHistoryInclude<ExtArgs> | null
    /**
     * Filter which noteHistory to delete.
     */
    where: noteHistoryWhereUniqueInput
  }

  /**
   * noteHistory deleteMany
   */
  export type noteHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which noteHistories to delete
     */
    where?: noteHistoryWhereInput
    /**
     * Limit how many noteHistories to delete.
     */
    limit?: number
  }

  /**
   * noteHistory without action
   */
  export type noteHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteHistory
     */
    select?: noteHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteHistory
     */
    omit?: noteHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteHistoryInclude<ExtArgs> | null
  }


  /**
   * Model noteInternalShare
   */

  export type AggregateNoteInternalShare = {
    _count: NoteInternalShareCountAggregateOutputType | null
    _avg: NoteInternalShareAvgAggregateOutputType | null
    _sum: NoteInternalShareSumAggregateOutputType | null
    _min: NoteInternalShareMinAggregateOutputType | null
    _max: NoteInternalShareMaxAggregateOutputType | null
  }

  export type NoteInternalShareAvgAggregateOutputType = {
    id: number | null
    noteId: number | null
    accountId: number | null
  }

  export type NoteInternalShareSumAggregateOutputType = {
    id: number | null
    noteId: number | null
    accountId: number | null
  }

  export type NoteInternalShareMinAggregateOutputType = {
    id: number | null
    noteId: number | null
    accountId: number | null
    canEdit: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NoteInternalShareMaxAggregateOutputType = {
    id: number | null
    noteId: number | null
    accountId: number | null
    canEdit: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NoteInternalShareCountAggregateOutputType = {
    id: number
    noteId: number
    accountId: number
    canEdit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NoteInternalShareAvgAggregateInputType = {
    id?: true
    noteId?: true
    accountId?: true
  }

  export type NoteInternalShareSumAggregateInputType = {
    id?: true
    noteId?: true
    accountId?: true
  }

  export type NoteInternalShareMinAggregateInputType = {
    id?: true
    noteId?: true
    accountId?: true
    canEdit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NoteInternalShareMaxAggregateInputType = {
    id?: true
    noteId?: true
    accountId?: true
    canEdit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NoteInternalShareCountAggregateInputType = {
    id?: true
    noteId?: true
    accountId?: true
    canEdit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NoteInternalShareAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which noteInternalShare to aggregate.
     */
    where?: noteInternalShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of noteInternalShares to fetch.
     */
    orderBy?: noteInternalShareOrderByWithRelationInput | noteInternalShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: noteInternalShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` noteInternalShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` noteInternalShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned noteInternalShares
    **/
    _count?: true | NoteInternalShareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoteInternalShareAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoteInternalShareSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoteInternalShareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoteInternalShareMaxAggregateInputType
  }

  export type GetNoteInternalShareAggregateType<T extends NoteInternalShareAggregateArgs> = {
        [P in keyof T & keyof AggregateNoteInternalShare]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNoteInternalShare[P]>
      : GetScalarType<T[P], AggregateNoteInternalShare[P]>
  }




  export type noteInternalShareGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: noteInternalShareWhereInput
    orderBy?: noteInternalShareOrderByWithAggregationInput | noteInternalShareOrderByWithAggregationInput[]
    by: NoteInternalShareScalarFieldEnum[] | NoteInternalShareScalarFieldEnum
    having?: noteInternalShareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoteInternalShareCountAggregateInputType | true
    _avg?: NoteInternalShareAvgAggregateInputType
    _sum?: NoteInternalShareSumAggregateInputType
    _min?: NoteInternalShareMinAggregateInputType
    _max?: NoteInternalShareMaxAggregateInputType
  }

  export type NoteInternalShareGroupByOutputType = {
    id: number
    noteId: number
    accountId: number
    canEdit: boolean
    createdAt: Date
    updatedAt: Date
    _count: NoteInternalShareCountAggregateOutputType | null
    _avg: NoteInternalShareAvgAggregateOutputType | null
    _sum: NoteInternalShareSumAggregateOutputType | null
    _min: NoteInternalShareMinAggregateOutputType | null
    _max: NoteInternalShareMaxAggregateOutputType | null
  }

  type GetNoteInternalShareGroupByPayload<T extends noteInternalShareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoteInternalShareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoteInternalShareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoteInternalShareGroupByOutputType[P]>
            : GetScalarType<T[P], NoteInternalShareGroupByOutputType[P]>
        }
      >
    >


  export type noteInternalShareSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    noteId?: boolean
    accountId?: boolean
    canEdit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    note?: boolean | notesDefaultArgs<ExtArgs>
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["noteInternalShare"]>

  export type noteInternalShareSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    noteId?: boolean
    accountId?: boolean
    canEdit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    note?: boolean | notesDefaultArgs<ExtArgs>
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["noteInternalShare"]>

  export type noteInternalShareSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    noteId?: boolean
    accountId?: boolean
    canEdit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    note?: boolean | notesDefaultArgs<ExtArgs>
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["noteInternalShare"]>

  export type noteInternalShareSelectScalar = {
    id?: boolean
    noteId?: boolean
    accountId?: boolean
    canEdit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type noteInternalShareOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "noteId" | "accountId" | "canEdit" | "createdAt" | "updatedAt", ExtArgs["result"]["noteInternalShare"]>
  export type noteInternalShareInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note?: boolean | notesDefaultArgs<ExtArgs>
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }
  export type noteInternalShareIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note?: boolean | notesDefaultArgs<ExtArgs>
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }
  export type noteInternalShareIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note?: boolean | notesDefaultArgs<ExtArgs>
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }

  export type $noteInternalSharePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "noteInternalShare"
    objects: {
      note: Prisma.$notesPayload<ExtArgs>
      account: Prisma.$accountsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      noteId: number
      accountId: number
      canEdit: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["noteInternalShare"]>
    composites: {}
  }

  type noteInternalShareGetPayload<S extends boolean | null | undefined | noteInternalShareDefaultArgs> = $Result.GetResult<Prisma.$noteInternalSharePayload, S>

  type noteInternalShareCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<noteInternalShareFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NoteInternalShareCountAggregateInputType | true
    }

  export interface noteInternalShareDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['noteInternalShare'], meta: { name: 'noteInternalShare' } }
    /**
     * Find zero or one NoteInternalShare that matches the filter.
     * @param {noteInternalShareFindUniqueArgs} args - Arguments to find a NoteInternalShare
     * @example
     * // Get one NoteInternalShare
     * const noteInternalShare = await prisma.noteInternalShare.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends noteInternalShareFindUniqueArgs>(args: SelectSubset<T, noteInternalShareFindUniqueArgs<ExtArgs>>): Prisma__noteInternalShareClient<$Result.GetResult<Prisma.$noteInternalSharePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NoteInternalShare that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {noteInternalShareFindUniqueOrThrowArgs} args - Arguments to find a NoteInternalShare
     * @example
     * // Get one NoteInternalShare
     * const noteInternalShare = await prisma.noteInternalShare.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends noteInternalShareFindUniqueOrThrowArgs>(args: SelectSubset<T, noteInternalShareFindUniqueOrThrowArgs<ExtArgs>>): Prisma__noteInternalShareClient<$Result.GetResult<Prisma.$noteInternalSharePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NoteInternalShare that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteInternalShareFindFirstArgs} args - Arguments to find a NoteInternalShare
     * @example
     * // Get one NoteInternalShare
     * const noteInternalShare = await prisma.noteInternalShare.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends noteInternalShareFindFirstArgs>(args?: SelectSubset<T, noteInternalShareFindFirstArgs<ExtArgs>>): Prisma__noteInternalShareClient<$Result.GetResult<Prisma.$noteInternalSharePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NoteInternalShare that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteInternalShareFindFirstOrThrowArgs} args - Arguments to find a NoteInternalShare
     * @example
     * // Get one NoteInternalShare
     * const noteInternalShare = await prisma.noteInternalShare.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends noteInternalShareFindFirstOrThrowArgs>(args?: SelectSubset<T, noteInternalShareFindFirstOrThrowArgs<ExtArgs>>): Prisma__noteInternalShareClient<$Result.GetResult<Prisma.$noteInternalSharePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NoteInternalShares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteInternalShareFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NoteInternalShares
     * const noteInternalShares = await prisma.noteInternalShare.findMany()
     * 
     * // Get first 10 NoteInternalShares
     * const noteInternalShares = await prisma.noteInternalShare.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noteInternalShareWithIdOnly = await prisma.noteInternalShare.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends noteInternalShareFindManyArgs>(args?: SelectSubset<T, noteInternalShareFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$noteInternalSharePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NoteInternalShare.
     * @param {noteInternalShareCreateArgs} args - Arguments to create a NoteInternalShare.
     * @example
     * // Create one NoteInternalShare
     * const NoteInternalShare = await prisma.noteInternalShare.create({
     *   data: {
     *     // ... data to create a NoteInternalShare
     *   }
     * })
     * 
     */
    create<T extends noteInternalShareCreateArgs>(args: SelectSubset<T, noteInternalShareCreateArgs<ExtArgs>>): Prisma__noteInternalShareClient<$Result.GetResult<Prisma.$noteInternalSharePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NoteInternalShares.
     * @param {noteInternalShareCreateManyArgs} args - Arguments to create many NoteInternalShares.
     * @example
     * // Create many NoteInternalShares
     * const noteInternalShare = await prisma.noteInternalShare.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends noteInternalShareCreateManyArgs>(args?: SelectSubset<T, noteInternalShareCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NoteInternalShares and returns the data saved in the database.
     * @param {noteInternalShareCreateManyAndReturnArgs} args - Arguments to create many NoteInternalShares.
     * @example
     * // Create many NoteInternalShares
     * const noteInternalShare = await prisma.noteInternalShare.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NoteInternalShares and only return the `id`
     * const noteInternalShareWithIdOnly = await prisma.noteInternalShare.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends noteInternalShareCreateManyAndReturnArgs>(args?: SelectSubset<T, noteInternalShareCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$noteInternalSharePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NoteInternalShare.
     * @param {noteInternalShareDeleteArgs} args - Arguments to delete one NoteInternalShare.
     * @example
     * // Delete one NoteInternalShare
     * const NoteInternalShare = await prisma.noteInternalShare.delete({
     *   where: {
     *     // ... filter to delete one NoteInternalShare
     *   }
     * })
     * 
     */
    delete<T extends noteInternalShareDeleteArgs>(args: SelectSubset<T, noteInternalShareDeleteArgs<ExtArgs>>): Prisma__noteInternalShareClient<$Result.GetResult<Prisma.$noteInternalSharePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NoteInternalShare.
     * @param {noteInternalShareUpdateArgs} args - Arguments to update one NoteInternalShare.
     * @example
     * // Update one NoteInternalShare
     * const noteInternalShare = await prisma.noteInternalShare.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends noteInternalShareUpdateArgs>(args: SelectSubset<T, noteInternalShareUpdateArgs<ExtArgs>>): Prisma__noteInternalShareClient<$Result.GetResult<Prisma.$noteInternalSharePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NoteInternalShares.
     * @param {noteInternalShareDeleteManyArgs} args - Arguments to filter NoteInternalShares to delete.
     * @example
     * // Delete a few NoteInternalShares
     * const { count } = await prisma.noteInternalShare.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends noteInternalShareDeleteManyArgs>(args?: SelectSubset<T, noteInternalShareDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NoteInternalShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteInternalShareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NoteInternalShares
     * const noteInternalShare = await prisma.noteInternalShare.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends noteInternalShareUpdateManyArgs>(args: SelectSubset<T, noteInternalShareUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NoteInternalShares and returns the data updated in the database.
     * @param {noteInternalShareUpdateManyAndReturnArgs} args - Arguments to update many NoteInternalShares.
     * @example
     * // Update many NoteInternalShares
     * const noteInternalShare = await prisma.noteInternalShare.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NoteInternalShares and only return the `id`
     * const noteInternalShareWithIdOnly = await prisma.noteInternalShare.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends noteInternalShareUpdateManyAndReturnArgs>(args: SelectSubset<T, noteInternalShareUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$noteInternalSharePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NoteInternalShare.
     * @param {noteInternalShareUpsertArgs} args - Arguments to update or create a NoteInternalShare.
     * @example
     * // Update or create a NoteInternalShare
     * const noteInternalShare = await prisma.noteInternalShare.upsert({
     *   create: {
     *     // ... data to create a NoteInternalShare
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NoteInternalShare we want to update
     *   }
     * })
     */
    upsert<T extends noteInternalShareUpsertArgs>(args: SelectSubset<T, noteInternalShareUpsertArgs<ExtArgs>>): Prisma__noteInternalShareClient<$Result.GetResult<Prisma.$noteInternalSharePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NoteInternalShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteInternalShareCountArgs} args - Arguments to filter NoteInternalShares to count.
     * @example
     * // Count the number of NoteInternalShares
     * const count = await prisma.noteInternalShare.count({
     *   where: {
     *     // ... the filter for the NoteInternalShares we want to count
     *   }
     * })
    **/
    count<T extends noteInternalShareCountArgs>(
      args?: Subset<T, noteInternalShareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoteInternalShareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NoteInternalShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteInternalShareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoteInternalShareAggregateArgs>(args: Subset<T, NoteInternalShareAggregateArgs>): Prisma.PrismaPromise<GetNoteInternalShareAggregateType<T>>

    /**
     * Group by NoteInternalShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteInternalShareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends noteInternalShareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: noteInternalShareGroupByArgs['orderBy'] }
        : { orderBy?: noteInternalShareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, noteInternalShareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoteInternalShareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the noteInternalShare model
   */
  readonly fields: noteInternalShareFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for noteInternalShare.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__noteInternalShareClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    note<T extends notesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, notesDefaultArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    account<T extends accountsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, accountsDefaultArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the noteInternalShare model
   */
  interface noteInternalShareFieldRefs {
    readonly id: FieldRef<"noteInternalShare", 'Int'>
    readonly noteId: FieldRef<"noteInternalShare", 'Int'>
    readonly accountId: FieldRef<"noteInternalShare", 'Int'>
    readonly canEdit: FieldRef<"noteInternalShare", 'Boolean'>
    readonly createdAt: FieldRef<"noteInternalShare", 'DateTime'>
    readonly updatedAt: FieldRef<"noteInternalShare", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * noteInternalShare findUnique
   */
  export type noteInternalShareFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteInternalShare
     */
    select?: noteInternalShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteInternalShare
     */
    omit?: noteInternalShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteInternalShareInclude<ExtArgs> | null
    /**
     * Filter, which noteInternalShare to fetch.
     */
    where: noteInternalShareWhereUniqueInput
  }

  /**
   * noteInternalShare findUniqueOrThrow
   */
  export type noteInternalShareFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteInternalShare
     */
    select?: noteInternalShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteInternalShare
     */
    omit?: noteInternalShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteInternalShareInclude<ExtArgs> | null
    /**
     * Filter, which noteInternalShare to fetch.
     */
    where: noteInternalShareWhereUniqueInput
  }

  /**
   * noteInternalShare findFirst
   */
  export type noteInternalShareFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteInternalShare
     */
    select?: noteInternalShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteInternalShare
     */
    omit?: noteInternalShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteInternalShareInclude<ExtArgs> | null
    /**
     * Filter, which noteInternalShare to fetch.
     */
    where?: noteInternalShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of noteInternalShares to fetch.
     */
    orderBy?: noteInternalShareOrderByWithRelationInput | noteInternalShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for noteInternalShares.
     */
    cursor?: noteInternalShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` noteInternalShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` noteInternalShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of noteInternalShares.
     */
    distinct?: NoteInternalShareScalarFieldEnum | NoteInternalShareScalarFieldEnum[]
  }

  /**
   * noteInternalShare findFirstOrThrow
   */
  export type noteInternalShareFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteInternalShare
     */
    select?: noteInternalShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteInternalShare
     */
    omit?: noteInternalShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteInternalShareInclude<ExtArgs> | null
    /**
     * Filter, which noteInternalShare to fetch.
     */
    where?: noteInternalShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of noteInternalShares to fetch.
     */
    orderBy?: noteInternalShareOrderByWithRelationInput | noteInternalShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for noteInternalShares.
     */
    cursor?: noteInternalShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` noteInternalShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` noteInternalShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of noteInternalShares.
     */
    distinct?: NoteInternalShareScalarFieldEnum | NoteInternalShareScalarFieldEnum[]
  }

  /**
   * noteInternalShare findMany
   */
  export type noteInternalShareFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteInternalShare
     */
    select?: noteInternalShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteInternalShare
     */
    omit?: noteInternalShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteInternalShareInclude<ExtArgs> | null
    /**
     * Filter, which noteInternalShares to fetch.
     */
    where?: noteInternalShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of noteInternalShares to fetch.
     */
    orderBy?: noteInternalShareOrderByWithRelationInput | noteInternalShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing noteInternalShares.
     */
    cursor?: noteInternalShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` noteInternalShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` noteInternalShares.
     */
    skip?: number
    distinct?: NoteInternalShareScalarFieldEnum | NoteInternalShareScalarFieldEnum[]
  }

  /**
   * noteInternalShare create
   */
  export type noteInternalShareCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteInternalShare
     */
    select?: noteInternalShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteInternalShare
     */
    omit?: noteInternalShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteInternalShareInclude<ExtArgs> | null
    /**
     * The data needed to create a noteInternalShare.
     */
    data: XOR<noteInternalShareCreateInput, noteInternalShareUncheckedCreateInput>
  }

  /**
   * noteInternalShare createMany
   */
  export type noteInternalShareCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many noteInternalShares.
     */
    data: noteInternalShareCreateManyInput | noteInternalShareCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * noteInternalShare createManyAndReturn
   */
  export type noteInternalShareCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteInternalShare
     */
    select?: noteInternalShareSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the noteInternalShare
     */
    omit?: noteInternalShareOmit<ExtArgs> | null
    /**
     * The data used to create many noteInternalShares.
     */
    data: noteInternalShareCreateManyInput | noteInternalShareCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteInternalShareIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * noteInternalShare update
   */
  export type noteInternalShareUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteInternalShare
     */
    select?: noteInternalShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteInternalShare
     */
    omit?: noteInternalShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteInternalShareInclude<ExtArgs> | null
    /**
     * The data needed to update a noteInternalShare.
     */
    data: XOR<noteInternalShareUpdateInput, noteInternalShareUncheckedUpdateInput>
    /**
     * Choose, which noteInternalShare to update.
     */
    where: noteInternalShareWhereUniqueInput
  }

  /**
   * noteInternalShare updateMany
   */
  export type noteInternalShareUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update noteInternalShares.
     */
    data: XOR<noteInternalShareUpdateManyMutationInput, noteInternalShareUncheckedUpdateManyInput>
    /**
     * Filter which noteInternalShares to update
     */
    where?: noteInternalShareWhereInput
    /**
     * Limit how many noteInternalShares to update.
     */
    limit?: number
  }

  /**
   * noteInternalShare updateManyAndReturn
   */
  export type noteInternalShareUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteInternalShare
     */
    select?: noteInternalShareSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the noteInternalShare
     */
    omit?: noteInternalShareOmit<ExtArgs> | null
    /**
     * The data used to update noteInternalShares.
     */
    data: XOR<noteInternalShareUpdateManyMutationInput, noteInternalShareUncheckedUpdateManyInput>
    /**
     * Filter which noteInternalShares to update
     */
    where?: noteInternalShareWhereInput
    /**
     * Limit how many noteInternalShares to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteInternalShareIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * noteInternalShare upsert
   */
  export type noteInternalShareUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteInternalShare
     */
    select?: noteInternalShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteInternalShare
     */
    omit?: noteInternalShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteInternalShareInclude<ExtArgs> | null
    /**
     * The filter to search for the noteInternalShare to update in case it exists.
     */
    where: noteInternalShareWhereUniqueInput
    /**
     * In case the noteInternalShare found by the `where` argument doesn't exist, create a new noteInternalShare with this data.
     */
    create: XOR<noteInternalShareCreateInput, noteInternalShareUncheckedCreateInput>
    /**
     * In case the noteInternalShare was found with the provided `where` argument, update it with this data.
     */
    update: XOR<noteInternalShareUpdateInput, noteInternalShareUncheckedUpdateInput>
  }

  /**
   * noteInternalShare delete
   */
  export type noteInternalShareDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteInternalShare
     */
    select?: noteInternalShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteInternalShare
     */
    omit?: noteInternalShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteInternalShareInclude<ExtArgs> | null
    /**
     * Filter which noteInternalShare to delete.
     */
    where: noteInternalShareWhereUniqueInput
  }

  /**
   * noteInternalShare deleteMany
   */
  export type noteInternalShareDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which noteInternalShares to delete
     */
    where?: noteInternalShareWhereInput
    /**
     * Limit how many noteInternalShares to delete.
     */
    limit?: number
  }

  /**
   * noteInternalShare without action
   */
  export type noteInternalShareDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noteInternalShare
     */
    select?: noteInternalShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the noteInternalShare
     */
    omit?: noteInternalShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteInternalShareInclude<ExtArgs> | null
  }


  /**
   * Model session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sid: string | null
    data: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sid: string | null
    data: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sid: number
    data: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sid?: true
    data?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sid?: true
    data?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sid?: true
    data?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which session to aggregate.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type sessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionWhereInput
    orderBy?: sessionOrderByWithAggregationInput | sessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: sessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sid: string
    data: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends sessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type sessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sid?: boolean
    data?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["session"]>

  export type sessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sid?: boolean
    data?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["session"]>

  export type sessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sid?: boolean
    data?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["session"]>

  export type sessionSelectScalar = {
    id?: boolean
    sid?: boolean
    data?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type sessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sid" | "data" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["session"]>

  export type $sessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "session"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sid: string
      data: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type sessionGetPayload<S extends boolean | null | undefined | sessionDefaultArgs> = $Result.GetResult<Prisma.$sessionPayload, S>

  type sessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface sessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['session'], meta: { name: 'session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {sessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sessionFindUniqueArgs>(args: SelectSubset<T, sessionFindUniqueArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sessionFindUniqueOrThrowArgs>(args: SelectSubset<T, sessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sessionFindFirstArgs>(args?: SelectSubset<T, sessionFindFirstArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sessionFindFirstOrThrowArgs>(args?: SelectSubset<T, sessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sessionFindManyArgs>(args?: SelectSubset<T, sessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {sessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends sessionCreateArgs>(args: SelectSubset<T, sessionCreateArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {sessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sessionCreateManyArgs>(args?: SelectSubset<T, sessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {sessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends sessionCreateManyAndReturnArgs>(args?: SelectSubset<T, sessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {sessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends sessionDeleteArgs>(args: SelectSubset<T, sessionDeleteArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {sessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sessionUpdateArgs>(args: SelectSubset<T, sessionUpdateArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {sessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sessionDeleteManyArgs>(args?: SelectSubset<T, sessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sessionUpdateManyArgs>(args: SelectSubset<T, sessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {sessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends sessionUpdateManyAndReturnArgs>(args: SelectSubset<T, sessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {sessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends sessionUpsertArgs>(args: SelectSubset<T, sessionUpsertArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends sessionCountArgs>(
      args?: Subset<T, sessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessionGroupByArgs['orderBy'] }
        : { orderBy?: sessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the session model
   */
  readonly fields: sessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the session model
   */
  interface sessionFieldRefs {
    readonly id: FieldRef<"session", 'String'>
    readonly sid: FieldRef<"session", 'String'>
    readonly data: FieldRef<"session", 'String'>
    readonly expiresAt: FieldRef<"session", 'DateTime'>
    readonly createdAt: FieldRef<"session", 'DateTime'>
    readonly updatedAt: FieldRef<"session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * session findUnique
   */
  export type sessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session findUniqueOrThrow
   */
  export type sessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session findFirst
   */
  export type sessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * session findFirstOrThrow
   */
  export type sessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * session findMany
   */
  export type sessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * session create
   */
  export type sessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * The data needed to create a session.
     */
    data: XOR<sessionCreateInput, sessionUncheckedCreateInput>
  }

  /**
   * session createMany
   */
  export type sessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions.
     */
    data: sessionCreateManyInput | sessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * session createManyAndReturn
   */
  export type sessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * The data used to create many sessions.
     */
    data: sessionCreateManyInput | sessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * session update
   */
  export type sessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * The data needed to update a session.
     */
    data: XOR<sessionUpdateInput, sessionUncheckedUpdateInput>
    /**
     * Choose, which session to update.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session updateMany
   */
  export type sessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionUpdateManyMutationInput, sessionUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
  }

  /**
   * session updateManyAndReturn
   */
  export type sessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionUpdateManyMutationInput, sessionUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
  }

  /**
   * session upsert
   */
  export type sessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * The filter to search for the session to update in case it exists.
     */
    where: sessionWhereUniqueInput
    /**
     * In case the session found by the `where` argument doesn't exist, create a new session with this data.
     */
    create: XOR<sessionCreateInput, sessionUncheckedCreateInput>
    /**
     * In case the session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessionUpdateInput, sessionUncheckedUpdateInput>
  }

  /**
   * session delete
   */
  export type sessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Filter which session to delete.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session deleteMany
   */
  export type sessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to delete
     */
    where?: sessionWhereInput
    /**
     * Limit how many sessions to delete.
     */
    limit?: number
  }

  /**
   * session without action
   */
  export type sessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
  }


  /**
   * Model aiProviders
   */

  export type AggregateAiProviders = {
    _count: AiProvidersCountAggregateOutputType | null
    _avg: AiProvidersAvgAggregateOutputType | null
    _sum: AiProvidersSumAggregateOutputType | null
    _min: AiProvidersMinAggregateOutputType | null
    _max: AiProvidersMaxAggregateOutputType | null
  }

  export type AiProvidersAvgAggregateOutputType = {
    id: number | null
    sortOrder: number | null
  }

  export type AiProvidersSumAggregateOutputType = {
    id: number | null
    sortOrder: number | null
  }

  export type AiProvidersMinAggregateOutputType = {
    id: number | null
    title: string | null
    provider: string | null
    baseURL: string | null
    apiKey: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiProvidersMaxAggregateOutputType = {
    id: number | null
    title: string | null
    provider: string | null
    baseURL: string | null
    apiKey: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiProvidersCountAggregateOutputType = {
    id: number
    title: number
    provider: number
    baseURL: number
    apiKey: number
    config: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AiProvidersAvgAggregateInputType = {
    id?: true
    sortOrder?: true
  }

  export type AiProvidersSumAggregateInputType = {
    id?: true
    sortOrder?: true
  }

  export type AiProvidersMinAggregateInputType = {
    id?: true
    title?: true
    provider?: true
    baseURL?: true
    apiKey?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiProvidersMaxAggregateInputType = {
    id?: true
    title?: true
    provider?: true
    baseURL?: true
    apiKey?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiProvidersCountAggregateInputType = {
    id?: true
    title?: true
    provider?: true
    baseURL?: true
    apiKey?: true
    config?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AiProvidersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which aiProviders to aggregate.
     */
    where?: aiProvidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aiProviders to fetch.
     */
    orderBy?: aiProvidersOrderByWithRelationInput | aiProvidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: aiProvidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aiProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aiProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned aiProviders
    **/
    _count?: true | AiProvidersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiProvidersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiProvidersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiProvidersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiProvidersMaxAggregateInputType
  }

  export type GetAiProvidersAggregateType<T extends AiProvidersAggregateArgs> = {
        [P in keyof T & keyof AggregateAiProviders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiProviders[P]>
      : GetScalarType<T[P], AggregateAiProviders[P]>
  }




  export type aiProvidersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: aiProvidersWhereInput
    orderBy?: aiProvidersOrderByWithAggregationInput | aiProvidersOrderByWithAggregationInput[]
    by: AiProvidersScalarFieldEnum[] | AiProvidersScalarFieldEnum
    having?: aiProvidersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiProvidersCountAggregateInputType | true
    _avg?: AiProvidersAvgAggregateInputType
    _sum?: AiProvidersSumAggregateInputType
    _min?: AiProvidersMinAggregateInputType
    _max?: AiProvidersMaxAggregateInputType
  }

  export type AiProvidersGroupByOutputType = {
    id: number
    title: string
    provider: string
    baseURL: string | null
    apiKey: string | null
    config: JsonValue | null
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: AiProvidersCountAggregateOutputType | null
    _avg: AiProvidersAvgAggregateOutputType | null
    _sum: AiProvidersSumAggregateOutputType | null
    _min: AiProvidersMinAggregateOutputType | null
    _max: AiProvidersMaxAggregateOutputType | null
  }

  type GetAiProvidersGroupByPayload<T extends aiProvidersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiProvidersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiProvidersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiProvidersGroupByOutputType[P]>
            : GetScalarType<T[P], AiProvidersGroupByOutputType[P]>
        }
      >
    >


  export type aiProvidersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    provider?: boolean
    baseURL?: boolean
    apiKey?: boolean
    config?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    models?: boolean | aiProviders$modelsArgs<ExtArgs>
    _count?: boolean | AiProvidersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiProviders"]>

  export type aiProvidersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    provider?: boolean
    baseURL?: boolean
    apiKey?: boolean
    config?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aiProviders"]>

  export type aiProvidersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    provider?: boolean
    baseURL?: boolean
    apiKey?: boolean
    config?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aiProviders"]>

  export type aiProvidersSelectScalar = {
    id?: boolean
    title?: boolean
    provider?: boolean
    baseURL?: boolean
    apiKey?: boolean
    config?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type aiProvidersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "provider" | "baseURL" | "apiKey" | "config" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["aiProviders"]>
  export type aiProvidersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    models?: boolean | aiProviders$modelsArgs<ExtArgs>
    _count?: boolean | AiProvidersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type aiProvidersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type aiProvidersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $aiProvidersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "aiProviders"
    objects: {
      models: Prisma.$aiModelsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      provider: string
      baseURL: string | null
      apiKey: string | null
      config: Prisma.JsonValue | null
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aiProviders"]>
    composites: {}
  }

  type aiProvidersGetPayload<S extends boolean | null | undefined | aiProvidersDefaultArgs> = $Result.GetResult<Prisma.$aiProvidersPayload, S>

  type aiProvidersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<aiProvidersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiProvidersCountAggregateInputType | true
    }

  export interface aiProvidersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['aiProviders'], meta: { name: 'aiProviders' } }
    /**
     * Find zero or one AiProviders that matches the filter.
     * @param {aiProvidersFindUniqueArgs} args - Arguments to find a AiProviders
     * @example
     * // Get one AiProviders
     * const aiProviders = await prisma.aiProviders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends aiProvidersFindUniqueArgs>(args: SelectSubset<T, aiProvidersFindUniqueArgs<ExtArgs>>): Prisma__aiProvidersClient<$Result.GetResult<Prisma.$aiProvidersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiProviders that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {aiProvidersFindUniqueOrThrowArgs} args - Arguments to find a AiProviders
     * @example
     * // Get one AiProviders
     * const aiProviders = await prisma.aiProviders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends aiProvidersFindUniqueOrThrowArgs>(args: SelectSubset<T, aiProvidersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__aiProvidersClient<$Result.GetResult<Prisma.$aiProvidersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiProviders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aiProvidersFindFirstArgs} args - Arguments to find a AiProviders
     * @example
     * // Get one AiProviders
     * const aiProviders = await prisma.aiProviders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends aiProvidersFindFirstArgs>(args?: SelectSubset<T, aiProvidersFindFirstArgs<ExtArgs>>): Prisma__aiProvidersClient<$Result.GetResult<Prisma.$aiProvidersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiProviders that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aiProvidersFindFirstOrThrowArgs} args - Arguments to find a AiProviders
     * @example
     * // Get one AiProviders
     * const aiProviders = await prisma.aiProviders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends aiProvidersFindFirstOrThrowArgs>(args?: SelectSubset<T, aiProvidersFindFirstOrThrowArgs<ExtArgs>>): Prisma__aiProvidersClient<$Result.GetResult<Prisma.$aiProvidersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiProviders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aiProvidersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiProviders
     * const aiProviders = await prisma.aiProviders.findMany()
     * 
     * // Get first 10 AiProviders
     * const aiProviders = await prisma.aiProviders.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiProvidersWithIdOnly = await prisma.aiProviders.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends aiProvidersFindManyArgs>(args?: SelectSubset<T, aiProvidersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aiProvidersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiProviders.
     * @param {aiProvidersCreateArgs} args - Arguments to create a AiProviders.
     * @example
     * // Create one AiProviders
     * const AiProviders = await prisma.aiProviders.create({
     *   data: {
     *     // ... data to create a AiProviders
     *   }
     * })
     * 
     */
    create<T extends aiProvidersCreateArgs>(args: SelectSubset<T, aiProvidersCreateArgs<ExtArgs>>): Prisma__aiProvidersClient<$Result.GetResult<Prisma.$aiProvidersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiProviders.
     * @param {aiProvidersCreateManyArgs} args - Arguments to create many AiProviders.
     * @example
     * // Create many AiProviders
     * const aiProviders = await prisma.aiProviders.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends aiProvidersCreateManyArgs>(args?: SelectSubset<T, aiProvidersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiProviders and returns the data saved in the database.
     * @param {aiProvidersCreateManyAndReturnArgs} args - Arguments to create many AiProviders.
     * @example
     * // Create many AiProviders
     * const aiProviders = await prisma.aiProviders.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiProviders and only return the `id`
     * const aiProvidersWithIdOnly = await prisma.aiProviders.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends aiProvidersCreateManyAndReturnArgs>(args?: SelectSubset<T, aiProvidersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aiProvidersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiProviders.
     * @param {aiProvidersDeleteArgs} args - Arguments to delete one AiProviders.
     * @example
     * // Delete one AiProviders
     * const AiProviders = await prisma.aiProviders.delete({
     *   where: {
     *     // ... filter to delete one AiProviders
     *   }
     * })
     * 
     */
    delete<T extends aiProvidersDeleteArgs>(args: SelectSubset<T, aiProvidersDeleteArgs<ExtArgs>>): Prisma__aiProvidersClient<$Result.GetResult<Prisma.$aiProvidersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiProviders.
     * @param {aiProvidersUpdateArgs} args - Arguments to update one AiProviders.
     * @example
     * // Update one AiProviders
     * const aiProviders = await prisma.aiProviders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends aiProvidersUpdateArgs>(args: SelectSubset<T, aiProvidersUpdateArgs<ExtArgs>>): Prisma__aiProvidersClient<$Result.GetResult<Prisma.$aiProvidersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiProviders.
     * @param {aiProvidersDeleteManyArgs} args - Arguments to filter AiProviders to delete.
     * @example
     * // Delete a few AiProviders
     * const { count } = await prisma.aiProviders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends aiProvidersDeleteManyArgs>(args?: SelectSubset<T, aiProvidersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aiProvidersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiProviders
     * const aiProviders = await prisma.aiProviders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends aiProvidersUpdateManyArgs>(args: SelectSubset<T, aiProvidersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiProviders and returns the data updated in the database.
     * @param {aiProvidersUpdateManyAndReturnArgs} args - Arguments to update many AiProviders.
     * @example
     * // Update many AiProviders
     * const aiProviders = await prisma.aiProviders.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiProviders and only return the `id`
     * const aiProvidersWithIdOnly = await prisma.aiProviders.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends aiProvidersUpdateManyAndReturnArgs>(args: SelectSubset<T, aiProvidersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aiProvidersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiProviders.
     * @param {aiProvidersUpsertArgs} args - Arguments to update or create a AiProviders.
     * @example
     * // Update or create a AiProviders
     * const aiProviders = await prisma.aiProviders.upsert({
     *   create: {
     *     // ... data to create a AiProviders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiProviders we want to update
     *   }
     * })
     */
    upsert<T extends aiProvidersUpsertArgs>(args: SelectSubset<T, aiProvidersUpsertArgs<ExtArgs>>): Prisma__aiProvidersClient<$Result.GetResult<Prisma.$aiProvidersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aiProvidersCountArgs} args - Arguments to filter AiProviders to count.
     * @example
     * // Count the number of AiProviders
     * const count = await prisma.aiProviders.count({
     *   where: {
     *     // ... the filter for the AiProviders we want to count
     *   }
     * })
    **/
    count<T extends aiProvidersCountArgs>(
      args?: Subset<T, aiProvidersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiProvidersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiProvidersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiProvidersAggregateArgs>(args: Subset<T, AiProvidersAggregateArgs>): Prisma.PrismaPromise<GetAiProvidersAggregateType<T>>

    /**
     * Group by AiProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aiProvidersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends aiProvidersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: aiProvidersGroupByArgs['orderBy'] }
        : { orderBy?: aiProvidersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, aiProvidersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiProvidersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the aiProviders model
   */
  readonly fields: aiProvidersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for aiProviders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__aiProvidersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    models<T extends aiProviders$modelsArgs<ExtArgs> = {}>(args?: Subset<T, aiProviders$modelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aiModelsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the aiProviders model
   */
  interface aiProvidersFieldRefs {
    readonly id: FieldRef<"aiProviders", 'Int'>
    readonly title: FieldRef<"aiProviders", 'String'>
    readonly provider: FieldRef<"aiProviders", 'String'>
    readonly baseURL: FieldRef<"aiProviders", 'String'>
    readonly apiKey: FieldRef<"aiProviders", 'String'>
    readonly config: FieldRef<"aiProviders", 'Json'>
    readonly sortOrder: FieldRef<"aiProviders", 'Int'>
    readonly createdAt: FieldRef<"aiProviders", 'DateTime'>
    readonly updatedAt: FieldRef<"aiProviders", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * aiProviders findUnique
   */
  export type aiProvidersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiProviders
     */
    select?: aiProvidersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiProviders
     */
    omit?: aiProvidersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiProvidersInclude<ExtArgs> | null
    /**
     * Filter, which aiProviders to fetch.
     */
    where: aiProvidersWhereUniqueInput
  }

  /**
   * aiProviders findUniqueOrThrow
   */
  export type aiProvidersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiProviders
     */
    select?: aiProvidersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiProviders
     */
    omit?: aiProvidersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiProvidersInclude<ExtArgs> | null
    /**
     * Filter, which aiProviders to fetch.
     */
    where: aiProvidersWhereUniqueInput
  }

  /**
   * aiProviders findFirst
   */
  export type aiProvidersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiProviders
     */
    select?: aiProvidersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiProviders
     */
    omit?: aiProvidersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiProvidersInclude<ExtArgs> | null
    /**
     * Filter, which aiProviders to fetch.
     */
    where?: aiProvidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aiProviders to fetch.
     */
    orderBy?: aiProvidersOrderByWithRelationInput | aiProvidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for aiProviders.
     */
    cursor?: aiProvidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aiProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aiProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of aiProviders.
     */
    distinct?: AiProvidersScalarFieldEnum | AiProvidersScalarFieldEnum[]
  }

  /**
   * aiProviders findFirstOrThrow
   */
  export type aiProvidersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiProviders
     */
    select?: aiProvidersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiProviders
     */
    omit?: aiProvidersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiProvidersInclude<ExtArgs> | null
    /**
     * Filter, which aiProviders to fetch.
     */
    where?: aiProvidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aiProviders to fetch.
     */
    orderBy?: aiProvidersOrderByWithRelationInput | aiProvidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for aiProviders.
     */
    cursor?: aiProvidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aiProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aiProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of aiProviders.
     */
    distinct?: AiProvidersScalarFieldEnum | AiProvidersScalarFieldEnum[]
  }

  /**
   * aiProviders findMany
   */
  export type aiProvidersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiProviders
     */
    select?: aiProvidersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiProviders
     */
    omit?: aiProvidersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiProvidersInclude<ExtArgs> | null
    /**
     * Filter, which aiProviders to fetch.
     */
    where?: aiProvidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aiProviders to fetch.
     */
    orderBy?: aiProvidersOrderByWithRelationInput | aiProvidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing aiProviders.
     */
    cursor?: aiProvidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aiProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aiProviders.
     */
    skip?: number
    distinct?: AiProvidersScalarFieldEnum | AiProvidersScalarFieldEnum[]
  }

  /**
   * aiProviders create
   */
  export type aiProvidersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiProviders
     */
    select?: aiProvidersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiProviders
     */
    omit?: aiProvidersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiProvidersInclude<ExtArgs> | null
    /**
     * The data needed to create a aiProviders.
     */
    data: XOR<aiProvidersCreateInput, aiProvidersUncheckedCreateInput>
  }

  /**
   * aiProviders createMany
   */
  export type aiProvidersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many aiProviders.
     */
    data: aiProvidersCreateManyInput | aiProvidersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * aiProviders createManyAndReturn
   */
  export type aiProvidersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiProviders
     */
    select?: aiProvidersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the aiProviders
     */
    omit?: aiProvidersOmit<ExtArgs> | null
    /**
     * The data used to create many aiProviders.
     */
    data: aiProvidersCreateManyInput | aiProvidersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * aiProviders update
   */
  export type aiProvidersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiProviders
     */
    select?: aiProvidersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiProviders
     */
    omit?: aiProvidersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiProvidersInclude<ExtArgs> | null
    /**
     * The data needed to update a aiProviders.
     */
    data: XOR<aiProvidersUpdateInput, aiProvidersUncheckedUpdateInput>
    /**
     * Choose, which aiProviders to update.
     */
    where: aiProvidersWhereUniqueInput
  }

  /**
   * aiProviders updateMany
   */
  export type aiProvidersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update aiProviders.
     */
    data: XOR<aiProvidersUpdateManyMutationInput, aiProvidersUncheckedUpdateManyInput>
    /**
     * Filter which aiProviders to update
     */
    where?: aiProvidersWhereInput
    /**
     * Limit how many aiProviders to update.
     */
    limit?: number
  }

  /**
   * aiProviders updateManyAndReturn
   */
  export type aiProvidersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiProviders
     */
    select?: aiProvidersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the aiProviders
     */
    omit?: aiProvidersOmit<ExtArgs> | null
    /**
     * The data used to update aiProviders.
     */
    data: XOR<aiProvidersUpdateManyMutationInput, aiProvidersUncheckedUpdateManyInput>
    /**
     * Filter which aiProviders to update
     */
    where?: aiProvidersWhereInput
    /**
     * Limit how many aiProviders to update.
     */
    limit?: number
  }

  /**
   * aiProviders upsert
   */
  export type aiProvidersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiProviders
     */
    select?: aiProvidersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiProviders
     */
    omit?: aiProvidersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiProvidersInclude<ExtArgs> | null
    /**
     * The filter to search for the aiProviders to update in case it exists.
     */
    where: aiProvidersWhereUniqueInput
    /**
     * In case the aiProviders found by the `where` argument doesn't exist, create a new aiProviders with this data.
     */
    create: XOR<aiProvidersCreateInput, aiProvidersUncheckedCreateInput>
    /**
     * In case the aiProviders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<aiProvidersUpdateInput, aiProvidersUncheckedUpdateInput>
  }

  /**
   * aiProviders delete
   */
  export type aiProvidersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiProviders
     */
    select?: aiProvidersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiProviders
     */
    omit?: aiProvidersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiProvidersInclude<ExtArgs> | null
    /**
     * Filter which aiProviders to delete.
     */
    where: aiProvidersWhereUniqueInput
  }

  /**
   * aiProviders deleteMany
   */
  export type aiProvidersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which aiProviders to delete
     */
    where?: aiProvidersWhereInput
    /**
     * Limit how many aiProviders to delete.
     */
    limit?: number
  }

  /**
   * aiProviders.models
   */
  export type aiProviders$modelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiModels
     */
    select?: aiModelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiModels
     */
    omit?: aiModelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiModelsInclude<ExtArgs> | null
    where?: aiModelsWhereInput
    orderBy?: aiModelsOrderByWithRelationInput | aiModelsOrderByWithRelationInput[]
    cursor?: aiModelsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiModelsScalarFieldEnum | AiModelsScalarFieldEnum[]
  }

  /**
   * aiProviders without action
   */
  export type aiProvidersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiProviders
     */
    select?: aiProvidersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiProviders
     */
    omit?: aiProvidersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiProvidersInclude<ExtArgs> | null
  }


  /**
   * Model aiModels
   */

  export type AggregateAiModels = {
    _count: AiModelsCountAggregateOutputType | null
    _avg: AiModelsAvgAggregateOutputType | null
    _sum: AiModelsSumAggregateOutputType | null
    _min: AiModelsMinAggregateOutputType | null
    _max: AiModelsMaxAggregateOutputType | null
  }

  export type AiModelsAvgAggregateOutputType = {
    id: number | null
    providerId: number | null
    sortOrder: number | null
  }

  export type AiModelsSumAggregateOutputType = {
    id: number | null
    providerId: number | null
    sortOrder: number | null
  }

  export type AiModelsMinAggregateOutputType = {
    id: number | null
    providerId: number | null
    title: string | null
    modelKey: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiModelsMaxAggregateOutputType = {
    id: number | null
    providerId: number | null
    title: string | null
    modelKey: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiModelsCountAggregateOutputType = {
    id: number
    providerId: number
    title: number
    modelKey: number
    capabilities: number
    config: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AiModelsAvgAggregateInputType = {
    id?: true
    providerId?: true
    sortOrder?: true
  }

  export type AiModelsSumAggregateInputType = {
    id?: true
    providerId?: true
    sortOrder?: true
  }

  export type AiModelsMinAggregateInputType = {
    id?: true
    providerId?: true
    title?: true
    modelKey?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiModelsMaxAggregateInputType = {
    id?: true
    providerId?: true
    title?: true
    modelKey?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiModelsCountAggregateInputType = {
    id?: true
    providerId?: true
    title?: true
    modelKey?: true
    capabilities?: true
    config?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AiModelsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which aiModels to aggregate.
     */
    where?: aiModelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aiModels to fetch.
     */
    orderBy?: aiModelsOrderByWithRelationInput | aiModelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: aiModelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aiModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aiModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned aiModels
    **/
    _count?: true | AiModelsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiModelsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiModelsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiModelsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiModelsMaxAggregateInputType
  }

  export type GetAiModelsAggregateType<T extends AiModelsAggregateArgs> = {
        [P in keyof T & keyof AggregateAiModels]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiModels[P]>
      : GetScalarType<T[P], AggregateAiModels[P]>
  }




  export type aiModelsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: aiModelsWhereInput
    orderBy?: aiModelsOrderByWithAggregationInput | aiModelsOrderByWithAggregationInput[]
    by: AiModelsScalarFieldEnum[] | AiModelsScalarFieldEnum
    having?: aiModelsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiModelsCountAggregateInputType | true
    _avg?: AiModelsAvgAggregateInputType
    _sum?: AiModelsSumAggregateInputType
    _min?: AiModelsMinAggregateInputType
    _max?: AiModelsMaxAggregateInputType
  }

  export type AiModelsGroupByOutputType = {
    id: number
    providerId: number
    title: string
    modelKey: string
    capabilities: JsonValue
    config: JsonValue | null
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: AiModelsCountAggregateOutputType | null
    _avg: AiModelsAvgAggregateOutputType | null
    _sum: AiModelsSumAggregateOutputType | null
    _min: AiModelsMinAggregateOutputType | null
    _max: AiModelsMaxAggregateOutputType | null
  }

  type GetAiModelsGroupByPayload<T extends aiModelsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiModelsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiModelsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiModelsGroupByOutputType[P]>
            : GetScalarType<T[P], AiModelsGroupByOutputType[P]>
        }
      >
    >


  export type aiModelsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    title?: boolean
    modelKey?: boolean
    capabilities?: boolean
    config?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | aiProvidersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiModels"]>

  export type aiModelsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    title?: boolean
    modelKey?: boolean
    capabilities?: boolean
    config?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | aiProvidersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiModels"]>

  export type aiModelsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    title?: boolean
    modelKey?: boolean
    capabilities?: boolean
    config?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | aiProvidersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiModels"]>

  export type aiModelsSelectScalar = {
    id?: boolean
    providerId?: boolean
    title?: boolean
    modelKey?: boolean
    capabilities?: boolean
    config?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type aiModelsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "providerId" | "title" | "modelKey" | "capabilities" | "config" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["aiModels"]>
  export type aiModelsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | aiProvidersDefaultArgs<ExtArgs>
  }
  export type aiModelsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | aiProvidersDefaultArgs<ExtArgs>
  }
  export type aiModelsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | aiProvidersDefaultArgs<ExtArgs>
  }

  export type $aiModelsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "aiModels"
    objects: {
      provider: Prisma.$aiProvidersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      providerId: number
      title: string
      modelKey: string
      capabilities: Prisma.JsonValue
      config: Prisma.JsonValue | null
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aiModels"]>
    composites: {}
  }

  type aiModelsGetPayload<S extends boolean | null | undefined | aiModelsDefaultArgs> = $Result.GetResult<Prisma.$aiModelsPayload, S>

  type aiModelsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<aiModelsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiModelsCountAggregateInputType | true
    }

  export interface aiModelsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['aiModels'], meta: { name: 'aiModels' } }
    /**
     * Find zero or one AiModels that matches the filter.
     * @param {aiModelsFindUniqueArgs} args - Arguments to find a AiModels
     * @example
     * // Get one AiModels
     * const aiModels = await prisma.aiModels.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends aiModelsFindUniqueArgs>(args: SelectSubset<T, aiModelsFindUniqueArgs<ExtArgs>>): Prisma__aiModelsClient<$Result.GetResult<Prisma.$aiModelsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiModels that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {aiModelsFindUniqueOrThrowArgs} args - Arguments to find a AiModels
     * @example
     * // Get one AiModels
     * const aiModels = await prisma.aiModels.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends aiModelsFindUniqueOrThrowArgs>(args: SelectSubset<T, aiModelsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__aiModelsClient<$Result.GetResult<Prisma.$aiModelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aiModelsFindFirstArgs} args - Arguments to find a AiModels
     * @example
     * // Get one AiModels
     * const aiModels = await prisma.aiModels.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends aiModelsFindFirstArgs>(args?: SelectSubset<T, aiModelsFindFirstArgs<ExtArgs>>): Prisma__aiModelsClient<$Result.GetResult<Prisma.$aiModelsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiModels that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aiModelsFindFirstOrThrowArgs} args - Arguments to find a AiModels
     * @example
     * // Get one AiModels
     * const aiModels = await prisma.aiModels.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends aiModelsFindFirstOrThrowArgs>(args?: SelectSubset<T, aiModelsFindFirstOrThrowArgs<ExtArgs>>): Prisma__aiModelsClient<$Result.GetResult<Prisma.$aiModelsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aiModelsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiModels
     * const aiModels = await prisma.aiModels.findMany()
     * 
     * // Get first 10 AiModels
     * const aiModels = await prisma.aiModels.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiModelsWithIdOnly = await prisma.aiModels.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends aiModelsFindManyArgs>(args?: SelectSubset<T, aiModelsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aiModelsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiModels.
     * @param {aiModelsCreateArgs} args - Arguments to create a AiModels.
     * @example
     * // Create one AiModels
     * const AiModels = await prisma.aiModels.create({
     *   data: {
     *     // ... data to create a AiModels
     *   }
     * })
     * 
     */
    create<T extends aiModelsCreateArgs>(args: SelectSubset<T, aiModelsCreateArgs<ExtArgs>>): Prisma__aiModelsClient<$Result.GetResult<Prisma.$aiModelsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiModels.
     * @param {aiModelsCreateManyArgs} args - Arguments to create many AiModels.
     * @example
     * // Create many AiModels
     * const aiModels = await prisma.aiModels.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends aiModelsCreateManyArgs>(args?: SelectSubset<T, aiModelsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiModels and returns the data saved in the database.
     * @param {aiModelsCreateManyAndReturnArgs} args - Arguments to create many AiModels.
     * @example
     * // Create many AiModels
     * const aiModels = await prisma.aiModels.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiModels and only return the `id`
     * const aiModelsWithIdOnly = await prisma.aiModels.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends aiModelsCreateManyAndReturnArgs>(args?: SelectSubset<T, aiModelsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aiModelsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiModels.
     * @param {aiModelsDeleteArgs} args - Arguments to delete one AiModels.
     * @example
     * // Delete one AiModels
     * const AiModels = await prisma.aiModels.delete({
     *   where: {
     *     // ... filter to delete one AiModels
     *   }
     * })
     * 
     */
    delete<T extends aiModelsDeleteArgs>(args: SelectSubset<T, aiModelsDeleteArgs<ExtArgs>>): Prisma__aiModelsClient<$Result.GetResult<Prisma.$aiModelsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiModels.
     * @param {aiModelsUpdateArgs} args - Arguments to update one AiModels.
     * @example
     * // Update one AiModels
     * const aiModels = await prisma.aiModels.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends aiModelsUpdateArgs>(args: SelectSubset<T, aiModelsUpdateArgs<ExtArgs>>): Prisma__aiModelsClient<$Result.GetResult<Prisma.$aiModelsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiModels.
     * @param {aiModelsDeleteManyArgs} args - Arguments to filter AiModels to delete.
     * @example
     * // Delete a few AiModels
     * const { count } = await prisma.aiModels.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends aiModelsDeleteManyArgs>(args?: SelectSubset<T, aiModelsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aiModelsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiModels
     * const aiModels = await prisma.aiModels.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends aiModelsUpdateManyArgs>(args: SelectSubset<T, aiModelsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiModels and returns the data updated in the database.
     * @param {aiModelsUpdateManyAndReturnArgs} args - Arguments to update many AiModels.
     * @example
     * // Update many AiModels
     * const aiModels = await prisma.aiModels.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiModels and only return the `id`
     * const aiModelsWithIdOnly = await prisma.aiModels.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends aiModelsUpdateManyAndReturnArgs>(args: SelectSubset<T, aiModelsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aiModelsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiModels.
     * @param {aiModelsUpsertArgs} args - Arguments to update or create a AiModels.
     * @example
     * // Update or create a AiModels
     * const aiModels = await prisma.aiModels.upsert({
     *   create: {
     *     // ... data to create a AiModels
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiModels we want to update
     *   }
     * })
     */
    upsert<T extends aiModelsUpsertArgs>(args: SelectSubset<T, aiModelsUpsertArgs<ExtArgs>>): Prisma__aiModelsClient<$Result.GetResult<Prisma.$aiModelsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aiModelsCountArgs} args - Arguments to filter AiModels to count.
     * @example
     * // Count the number of AiModels
     * const count = await prisma.aiModels.count({
     *   where: {
     *     // ... the filter for the AiModels we want to count
     *   }
     * })
    **/
    count<T extends aiModelsCountArgs>(
      args?: Subset<T, aiModelsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiModelsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiModelsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiModelsAggregateArgs>(args: Subset<T, AiModelsAggregateArgs>): Prisma.PrismaPromise<GetAiModelsAggregateType<T>>

    /**
     * Group by AiModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aiModelsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends aiModelsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: aiModelsGroupByArgs['orderBy'] }
        : { orderBy?: aiModelsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, aiModelsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiModelsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the aiModels model
   */
  readonly fields: aiModelsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for aiModels.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__aiModelsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider<T extends aiProvidersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, aiProvidersDefaultArgs<ExtArgs>>): Prisma__aiProvidersClient<$Result.GetResult<Prisma.$aiProvidersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the aiModels model
   */
  interface aiModelsFieldRefs {
    readonly id: FieldRef<"aiModels", 'Int'>
    readonly providerId: FieldRef<"aiModels", 'Int'>
    readonly title: FieldRef<"aiModels", 'String'>
    readonly modelKey: FieldRef<"aiModels", 'String'>
    readonly capabilities: FieldRef<"aiModels", 'Json'>
    readonly config: FieldRef<"aiModels", 'Json'>
    readonly sortOrder: FieldRef<"aiModels", 'Int'>
    readonly createdAt: FieldRef<"aiModels", 'DateTime'>
    readonly updatedAt: FieldRef<"aiModels", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * aiModels findUnique
   */
  export type aiModelsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiModels
     */
    select?: aiModelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiModels
     */
    omit?: aiModelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiModelsInclude<ExtArgs> | null
    /**
     * Filter, which aiModels to fetch.
     */
    where: aiModelsWhereUniqueInput
  }

  /**
   * aiModels findUniqueOrThrow
   */
  export type aiModelsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiModels
     */
    select?: aiModelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiModels
     */
    omit?: aiModelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiModelsInclude<ExtArgs> | null
    /**
     * Filter, which aiModels to fetch.
     */
    where: aiModelsWhereUniqueInput
  }

  /**
   * aiModels findFirst
   */
  export type aiModelsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiModels
     */
    select?: aiModelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiModels
     */
    omit?: aiModelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiModelsInclude<ExtArgs> | null
    /**
     * Filter, which aiModels to fetch.
     */
    where?: aiModelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aiModels to fetch.
     */
    orderBy?: aiModelsOrderByWithRelationInput | aiModelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for aiModels.
     */
    cursor?: aiModelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aiModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aiModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of aiModels.
     */
    distinct?: AiModelsScalarFieldEnum | AiModelsScalarFieldEnum[]
  }

  /**
   * aiModels findFirstOrThrow
   */
  export type aiModelsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiModels
     */
    select?: aiModelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiModels
     */
    omit?: aiModelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiModelsInclude<ExtArgs> | null
    /**
     * Filter, which aiModels to fetch.
     */
    where?: aiModelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aiModels to fetch.
     */
    orderBy?: aiModelsOrderByWithRelationInput | aiModelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for aiModels.
     */
    cursor?: aiModelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aiModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aiModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of aiModels.
     */
    distinct?: AiModelsScalarFieldEnum | AiModelsScalarFieldEnum[]
  }

  /**
   * aiModels findMany
   */
  export type aiModelsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiModels
     */
    select?: aiModelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiModels
     */
    omit?: aiModelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiModelsInclude<ExtArgs> | null
    /**
     * Filter, which aiModels to fetch.
     */
    where?: aiModelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aiModels to fetch.
     */
    orderBy?: aiModelsOrderByWithRelationInput | aiModelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing aiModels.
     */
    cursor?: aiModelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aiModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aiModels.
     */
    skip?: number
    distinct?: AiModelsScalarFieldEnum | AiModelsScalarFieldEnum[]
  }

  /**
   * aiModels create
   */
  export type aiModelsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiModels
     */
    select?: aiModelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiModels
     */
    omit?: aiModelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiModelsInclude<ExtArgs> | null
    /**
     * The data needed to create a aiModels.
     */
    data: XOR<aiModelsCreateInput, aiModelsUncheckedCreateInput>
  }

  /**
   * aiModels createMany
   */
  export type aiModelsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many aiModels.
     */
    data: aiModelsCreateManyInput | aiModelsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * aiModels createManyAndReturn
   */
  export type aiModelsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiModels
     */
    select?: aiModelsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the aiModels
     */
    omit?: aiModelsOmit<ExtArgs> | null
    /**
     * The data used to create many aiModels.
     */
    data: aiModelsCreateManyInput | aiModelsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiModelsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * aiModels update
   */
  export type aiModelsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiModels
     */
    select?: aiModelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiModels
     */
    omit?: aiModelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiModelsInclude<ExtArgs> | null
    /**
     * The data needed to update a aiModels.
     */
    data: XOR<aiModelsUpdateInput, aiModelsUncheckedUpdateInput>
    /**
     * Choose, which aiModels to update.
     */
    where: aiModelsWhereUniqueInput
  }

  /**
   * aiModels updateMany
   */
  export type aiModelsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update aiModels.
     */
    data: XOR<aiModelsUpdateManyMutationInput, aiModelsUncheckedUpdateManyInput>
    /**
     * Filter which aiModels to update
     */
    where?: aiModelsWhereInput
    /**
     * Limit how many aiModels to update.
     */
    limit?: number
  }

  /**
   * aiModels updateManyAndReturn
   */
  export type aiModelsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiModels
     */
    select?: aiModelsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the aiModels
     */
    omit?: aiModelsOmit<ExtArgs> | null
    /**
     * The data used to update aiModels.
     */
    data: XOR<aiModelsUpdateManyMutationInput, aiModelsUncheckedUpdateManyInput>
    /**
     * Filter which aiModels to update
     */
    where?: aiModelsWhereInput
    /**
     * Limit how many aiModels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiModelsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * aiModels upsert
   */
  export type aiModelsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiModels
     */
    select?: aiModelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiModels
     */
    omit?: aiModelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiModelsInclude<ExtArgs> | null
    /**
     * The filter to search for the aiModels to update in case it exists.
     */
    where: aiModelsWhereUniqueInput
    /**
     * In case the aiModels found by the `where` argument doesn't exist, create a new aiModels with this data.
     */
    create: XOR<aiModelsCreateInput, aiModelsUncheckedCreateInput>
    /**
     * In case the aiModels was found with the provided `where` argument, update it with this data.
     */
    update: XOR<aiModelsUpdateInput, aiModelsUncheckedUpdateInput>
  }

  /**
   * aiModels delete
   */
  export type aiModelsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiModels
     */
    select?: aiModelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiModels
     */
    omit?: aiModelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiModelsInclude<ExtArgs> | null
    /**
     * Filter which aiModels to delete.
     */
    where: aiModelsWhereUniqueInput
  }

  /**
   * aiModels deleteMany
   */
  export type aiModelsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which aiModels to delete
     */
    where?: aiModelsWhereInput
    /**
     * Limit how many aiModels to delete.
     */
    limit?: number
  }

  /**
   * aiModels without action
   */
  export type aiModelsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiModels
     */
    select?: aiModelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiModels
     */
    omit?: aiModelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiModelsInclude<ExtArgs> | null
  }


  /**
   * Model aiScheduledTask
   */

  export type AggregateAiScheduledTask = {
    _count: AiScheduledTaskCountAggregateOutputType | null
    _avg: AiScheduledTaskAvgAggregateOutputType | null
    _sum: AiScheduledTaskSumAggregateOutputType | null
    _min: AiScheduledTaskMinAggregateOutputType | null
    _max: AiScheduledTaskMaxAggregateOutputType | null
  }

  export type AiScheduledTaskAvgAggregateOutputType = {
    id: number | null
    accountId: number | null
  }

  export type AiScheduledTaskSumAggregateOutputType = {
    id: number | null
    accountId: number | null
  }

  export type AiScheduledTaskMinAggregateOutputType = {
    id: number | null
    name: string | null
    prompt: string | null
    schedule: string | null
    isEnabled: boolean | null
    lastRun: Date | null
    accountId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiScheduledTaskMaxAggregateOutputType = {
    id: number | null
    name: string | null
    prompt: string | null
    schedule: string | null
    isEnabled: boolean | null
    lastRun: Date | null
    accountId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiScheduledTaskCountAggregateOutputType = {
    id: number
    name: number
    prompt: number
    schedule: number
    isEnabled: number
    lastRun: number
    lastResult: number
    accountId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AiScheduledTaskAvgAggregateInputType = {
    id?: true
    accountId?: true
  }

  export type AiScheduledTaskSumAggregateInputType = {
    id?: true
    accountId?: true
  }

  export type AiScheduledTaskMinAggregateInputType = {
    id?: true
    name?: true
    prompt?: true
    schedule?: true
    isEnabled?: true
    lastRun?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiScheduledTaskMaxAggregateInputType = {
    id?: true
    name?: true
    prompt?: true
    schedule?: true
    isEnabled?: true
    lastRun?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiScheduledTaskCountAggregateInputType = {
    id?: true
    name?: true
    prompt?: true
    schedule?: true
    isEnabled?: true
    lastRun?: true
    lastResult?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AiScheduledTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which aiScheduledTask to aggregate.
     */
    where?: aiScheduledTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aiScheduledTasks to fetch.
     */
    orderBy?: aiScheduledTaskOrderByWithRelationInput | aiScheduledTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: aiScheduledTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aiScheduledTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aiScheduledTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned aiScheduledTasks
    **/
    _count?: true | AiScheduledTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiScheduledTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiScheduledTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiScheduledTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiScheduledTaskMaxAggregateInputType
  }

  export type GetAiScheduledTaskAggregateType<T extends AiScheduledTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateAiScheduledTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiScheduledTask[P]>
      : GetScalarType<T[P], AggregateAiScheduledTask[P]>
  }




  export type aiScheduledTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: aiScheduledTaskWhereInput
    orderBy?: aiScheduledTaskOrderByWithAggregationInput | aiScheduledTaskOrderByWithAggregationInput[]
    by: AiScheduledTaskScalarFieldEnum[] | AiScheduledTaskScalarFieldEnum
    having?: aiScheduledTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiScheduledTaskCountAggregateInputType | true
    _avg?: AiScheduledTaskAvgAggregateInputType
    _sum?: AiScheduledTaskSumAggregateInputType
    _min?: AiScheduledTaskMinAggregateInputType
    _max?: AiScheduledTaskMaxAggregateInputType
  }

  export type AiScheduledTaskGroupByOutputType = {
    id: number
    name: string
    prompt: string
    schedule: string
    isEnabled: boolean
    lastRun: Date | null
    lastResult: JsonValue | null
    accountId: number
    createdAt: Date
    updatedAt: Date
    _count: AiScheduledTaskCountAggregateOutputType | null
    _avg: AiScheduledTaskAvgAggregateOutputType | null
    _sum: AiScheduledTaskSumAggregateOutputType | null
    _min: AiScheduledTaskMinAggregateOutputType | null
    _max: AiScheduledTaskMaxAggregateOutputType | null
  }

  type GetAiScheduledTaskGroupByPayload<T extends aiScheduledTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiScheduledTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiScheduledTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiScheduledTaskGroupByOutputType[P]>
            : GetScalarType<T[P], AiScheduledTaskGroupByOutputType[P]>
        }
      >
    >


  export type aiScheduledTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    prompt?: boolean
    schedule?: boolean
    isEnabled?: boolean
    lastRun?: boolean
    lastResult?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiScheduledTask"]>

  export type aiScheduledTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    prompt?: boolean
    schedule?: boolean
    isEnabled?: boolean
    lastRun?: boolean
    lastResult?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiScheduledTask"]>

  export type aiScheduledTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    prompt?: boolean
    schedule?: boolean
    isEnabled?: boolean
    lastRun?: boolean
    lastResult?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiScheduledTask"]>

  export type aiScheduledTaskSelectScalar = {
    id?: boolean
    name?: boolean
    prompt?: boolean
    schedule?: boolean
    isEnabled?: boolean
    lastRun?: boolean
    lastResult?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type aiScheduledTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "prompt" | "schedule" | "isEnabled" | "lastRun" | "lastResult" | "accountId" | "createdAt" | "updatedAt", ExtArgs["result"]["aiScheduledTask"]>
  export type aiScheduledTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }
  export type aiScheduledTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }
  export type aiScheduledTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | accountsDefaultArgs<ExtArgs>
  }

  export type $aiScheduledTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "aiScheduledTask"
    objects: {
      account: Prisma.$accountsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      prompt: string
      schedule: string
      isEnabled: boolean
      lastRun: Date | null
      lastResult: Prisma.JsonValue | null
      accountId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aiScheduledTask"]>
    composites: {}
  }

  type aiScheduledTaskGetPayload<S extends boolean | null | undefined | aiScheduledTaskDefaultArgs> = $Result.GetResult<Prisma.$aiScheduledTaskPayload, S>

  type aiScheduledTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<aiScheduledTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiScheduledTaskCountAggregateInputType | true
    }

  export interface aiScheduledTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['aiScheduledTask'], meta: { name: 'aiScheduledTask' } }
    /**
     * Find zero or one AiScheduledTask that matches the filter.
     * @param {aiScheduledTaskFindUniqueArgs} args - Arguments to find a AiScheduledTask
     * @example
     * // Get one AiScheduledTask
     * const aiScheduledTask = await prisma.aiScheduledTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends aiScheduledTaskFindUniqueArgs>(args: SelectSubset<T, aiScheduledTaskFindUniqueArgs<ExtArgs>>): Prisma__aiScheduledTaskClient<$Result.GetResult<Prisma.$aiScheduledTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiScheduledTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {aiScheduledTaskFindUniqueOrThrowArgs} args - Arguments to find a AiScheduledTask
     * @example
     * // Get one AiScheduledTask
     * const aiScheduledTask = await prisma.aiScheduledTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends aiScheduledTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, aiScheduledTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__aiScheduledTaskClient<$Result.GetResult<Prisma.$aiScheduledTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiScheduledTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aiScheduledTaskFindFirstArgs} args - Arguments to find a AiScheduledTask
     * @example
     * // Get one AiScheduledTask
     * const aiScheduledTask = await prisma.aiScheduledTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends aiScheduledTaskFindFirstArgs>(args?: SelectSubset<T, aiScheduledTaskFindFirstArgs<ExtArgs>>): Prisma__aiScheduledTaskClient<$Result.GetResult<Prisma.$aiScheduledTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiScheduledTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aiScheduledTaskFindFirstOrThrowArgs} args - Arguments to find a AiScheduledTask
     * @example
     * // Get one AiScheduledTask
     * const aiScheduledTask = await prisma.aiScheduledTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends aiScheduledTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, aiScheduledTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__aiScheduledTaskClient<$Result.GetResult<Prisma.$aiScheduledTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiScheduledTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aiScheduledTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiScheduledTasks
     * const aiScheduledTasks = await prisma.aiScheduledTask.findMany()
     * 
     * // Get first 10 AiScheduledTasks
     * const aiScheduledTasks = await prisma.aiScheduledTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiScheduledTaskWithIdOnly = await prisma.aiScheduledTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends aiScheduledTaskFindManyArgs>(args?: SelectSubset<T, aiScheduledTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aiScheduledTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiScheduledTask.
     * @param {aiScheduledTaskCreateArgs} args - Arguments to create a AiScheduledTask.
     * @example
     * // Create one AiScheduledTask
     * const AiScheduledTask = await prisma.aiScheduledTask.create({
     *   data: {
     *     // ... data to create a AiScheduledTask
     *   }
     * })
     * 
     */
    create<T extends aiScheduledTaskCreateArgs>(args: SelectSubset<T, aiScheduledTaskCreateArgs<ExtArgs>>): Prisma__aiScheduledTaskClient<$Result.GetResult<Prisma.$aiScheduledTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiScheduledTasks.
     * @param {aiScheduledTaskCreateManyArgs} args - Arguments to create many AiScheduledTasks.
     * @example
     * // Create many AiScheduledTasks
     * const aiScheduledTask = await prisma.aiScheduledTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends aiScheduledTaskCreateManyArgs>(args?: SelectSubset<T, aiScheduledTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiScheduledTasks and returns the data saved in the database.
     * @param {aiScheduledTaskCreateManyAndReturnArgs} args - Arguments to create many AiScheduledTasks.
     * @example
     * // Create many AiScheduledTasks
     * const aiScheduledTask = await prisma.aiScheduledTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiScheduledTasks and only return the `id`
     * const aiScheduledTaskWithIdOnly = await prisma.aiScheduledTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends aiScheduledTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, aiScheduledTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aiScheduledTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiScheduledTask.
     * @param {aiScheduledTaskDeleteArgs} args - Arguments to delete one AiScheduledTask.
     * @example
     * // Delete one AiScheduledTask
     * const AiScheduledTask = await prisma.aiScheduledTask.delete({
     *   where: {
     *     // ... filter to delete one AiScheduledTask
     *   }
     * })
     * 
     */
    delete<T extends aiScheduledTaskDeleteArgs>(args: SelectSubset<T, aiScheduledTaskDeleteArgs<ExtArgs>>): Prisma__aiScheduledTaskClient<$Result.GetResult<Prisma.$aiScheduledTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiScheduledTask.
     * @param {aiScheduledTaskUpdateArgs} args - Arguments to update one AiScheduledTask.
     * @example
     * // Update one AiScheduledTask
     * const aiScheduledTask = await prisma.aiScheduledTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends aiScheduledTaskUpdateArgs>(args: SelectSubset<T, aiScheduledTaskUpdateArgs<ExtArgs>>): Prisma__aiScheduledTaskClient<$Result.GetResult<Prisma.$aiScheduledTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiScheduledTasks.
     * @param {aiScheduledTaskDeleteManyArgs} args - Arguments to filter AiScheduledTasks to delete.
     * @example
     * // Delete a few AiScheduledTasks
     * const { count } = await prisma.aiScheduledTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends aiScheduledTaskDeleteManyArgs>(args?: SelectSubset<T, aiScheduledTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiScheduledTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aiScheduledTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiScheduledTasks
     * const aiScheduledTask = await prisma.aiScheduledTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends aiScheduledTaskUpdateManyArgs>(args: SelectSubset<T, aiScheduledTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiScheduledTasks and returns the data updated in the database.
     * @param {aiScheduledTaskUpdateManyAndReturnArgs} args - Arguments to update many AiScheduledTasks.
     * @example
     * // Update many AiScheduledTasks
     * const aiScheduledTask = await prisma.aiScheduledTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiScheduledTasks and only return the `id`
     * const aiScheduledTaskWithIdOnly = await prisma.aiScheduledTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends aiScheduledTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, aiScheduledTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aiScheduledTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiScheduledTask.
     * @param {aiScheduledTaskUpsertArgs} args - Arguments to update or create a AiScheduledTask.
     * @example
     * // Update or create a AiScheduledTask
     * const aiScheduledTask = await prisma.aiScheduledTask.upsert({
     *   create: {
     *     // ... data to create a AiScheduledTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiScheduledTask we want to update
     *   }
     * })
     */
    upsert<T extends aiScheduledTaskUpsertArgs>(args: SelectSubset<T, aiScheduledTaskUpsertArgs<ExtArgs>>): Prisma__aiScheduledTaskClient<$Result.GetResult<Prisma.$aiScheduledTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiScheduledTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aiScheduledTaskCountArgs} args - Arguments to filter AiScheduledTasks to count.
     * @example
     * // Count the number of AiScheduledTasks
     * const count = await prisma.aiScheduledTask.count({
     *   where: {
     *     // ... the filter for the AiScheduledTasks we want to count
     *   }
     * })
    **/
    count<T extends aiScheduledTaskCountArgs>(
      args?: Subset<T, aiScheduledTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiScheduledTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiScheduledTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiScheduledTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiScheduledTaskAggregateArgs>(args: Subset<T, AiScheduledTaskAggregateArgs>): Prisma.PrismaPromise<GetAiScheduledTaskAggregateType<T>>

    /**
     * Group by AiScheduledTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aiScheduledTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends aiScheduledTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: aiScheduledTaskGroupByArgs['orderBy'] }
        : { orderBy?: aiScheduledTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, aiScheduledTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiScheduledTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the aiScheduledTask model
   */
  readonly fields: aiScheduledTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for aiScheduledTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__aiScheduledTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends accountsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, accountsDefaultArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the aiScheduledTask model
   */
  interface aiScheduledTaskFieldRefs {
    readonly id: FieldRef<"aiScheduledTask", 'Int'>
    readonly name: FieldRef<"aiScheduledTask", 'String'>
    readonly prompt: FieldRef<"aiScheduledTask", 'String'>
    readonly schedule: FieldRef<"aiScheduledTask", 'String'>
    readonly isEnabled: FieldRef<"aiScheduledTask", 'Boolean'>
    readonly lastRun: FieldRef<"aiScheduledTask", 'DateTime'>
    readonly lastResult: FieldRef<"aiScheduledTask", 'Json'>
    readonly accountId: FieldRef<"aiScheduledTask", 'Int'>
    readonly createdAt: FieldRef<"aiScheduledTask", 'DateTime'>
    readonly updatedAt: FieldRef<"aiScheduledTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * aiScheduledTask findUnique
   */
  export type aiScheduledTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiScheduledTask
     */
    select?: aiScheduledTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiScheduledTask
     */
    omit?: aiScheduledTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiScheduledTaskInclude<ExtArgs> | null
    /**
     * Filter, which aiScheduledTask to fetch.
     */
    where: aiScheduledTaskWhereUniqueInput
  }

  /**
   * aiScheduledTask findUniqueOrThrow
   */
  export type aiScheduledTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiScheduledTask
     */
    select?: aiScheduledTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiScheduledTask
     */
    omit?: aiScheduledTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiScheduledTaskInclude<ExtArgs> | null
    /**
     * Filter, which aiScheduledTask to fetch.
     */
    where: aiScheduledTaskWhereUniqueInput
  }

  /**
   * aiScheduledTask findFirst
   */
  export type aiScheduledTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiScheduledTask
     */
    select?: aiScheduledTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiScheduledTask
     */
    omit?: aiScheduledTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiScheduledTaskInclude<ExtArgs> | null
    /**
     * Filter, which aiScheduledTask to fetch.
     */
    where?: aiScheduledTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aiScheduledTasks to fetch.
     */
    orderBy?: aiScheduledTaskOrderByWithRelationInput | aiScheduledTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for aiScheduledTasks.
     */
    cursor?: aiScheduledTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aiScheduledTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aiScheduledTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of aiScheduledTasks.
     */
    distinct?: AiScheduledTaskScalarFieldEnum | AiScheduledTaskScalarFieldEnum[]
  }

  /**
   * aiScheduledTask findFirstOrThrow
   */
  export type aiScheduledTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiScheduledTask
     */
    select?: aiScheduledTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiScheduledTask
     */
    omit?: aiScheduledTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiScheduledTaskInclude<ExtArgs> | null
    /**
     * Filter, which aiScheduledTask to fetch.
     */
    where?: aiScheduledTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aiScheduledTasks to fetch.
     */
    orderBy?: aiScheduledTaskOrderByWithRelationInput | aiScheduledTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for aiScheduledTasks.
     */
    cursor?: aiScheduledTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aiScheduledTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aiScheduledTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of aiScheduledTasks.
     */
    distinct?: AiScheduledTaskScalarFieldEnum | AiScheduledTaskScalarFieldEnum[]
  }

  /**
   * aiScheduledTask findMany
   */
  export type aiScheduledTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiScheduledTask
     */
    select?: aiScheduledTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiScheduledTask
     */
    omit?: aiScheduledTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiScheduledTaskInclude<ExtArgs> | null
    /**
     * Filter, which aiScheduledTasks to fetch.
     */
    where?: aiScheduledTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aiScheduledTasks to fetch.
     */
    orderBy?: aiScheduledTaskOrderByWithRelationInput | aiScheduledTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing aiScheduledTasks.
     */
    cursor?: aiScheduledTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aiScheduledTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aiScheduledTasks.
     */
    skip?: number
    distinct?: AiScheduledTaskScalarFieldEnum | AiScheduledTaskScalarFieldEnum[]
  }

  /**
   * aiScheduledTask create
   */
  export type aiScheduledTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiScheduledTask
     */
    select?: aiScheduledTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiScheduledTask
     */
    omit?: aiScheduledTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiScheduledTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a aiScheduledTask.
     */
    data: XOR<aiScheduledTaskCreateInput, aiScheduledTaskUncheckedCreateInput>
  }

  /**
   * aiScheduledTask createMany
   */
  export type aiScheduledTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many aiScheduledTasks.
     */
    data: aiScheduledTaskCreateManyInput | aiScheduledTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * aiScheduledTask createManyAndReturn
   */
  export type aiScheduledTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiScheduledTask
     */
    select?: aiScheduledTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the aiScheduledTask
     */
    omit?: aiScheduledTaskOmit<ExtArgs> | null
    /**
     * The data used to create many aiScheduledTasks.
     */
    data: aiScheduledTaskCreateManyInput | aiScheduledTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiScheduledTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * aiScheduledTask update
   */
  export type aiScheduledTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiScheduledTask
     */
    select?: aiScheduledTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiScheduledTask
     */
    omit?: aiScheduledTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiScheduledTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a aiScheduledTask.
     */
    data: XOR<aiScheduledTaskUpdateInput, aiScheduledTaskUncheckedUpdateInput>
    /**
     * Choose, which aiScheduledTask to update.
     */
    where: aiScheduledTaskWhereUniqueInput
  }

  /**
   * aiScheduledTask updateMany
   */
  export type aiScheduledTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update aiScheduledTasks.
     */
    data: XOR<aiScheduledTaskUpdateManyMutationInput, aiScheduledTaskUncheckedUpdateManyInput>
    /**
     * Filter which aiScheduledTasks to update
     */
    where?: aiScheduledTaskWhereInput
    /**
     * Limit how many aiScheduledTasks to update.
     */
    limit?: number
  }

  /**
   * aiScheduledTask updateManyAndReturn
   */
  export type aiScheduledTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiScheduledTask
     */
    select?: aiScheduledTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the aiScheduledTask
     */
    omit?: aiScheduledTaskOmit<ExtArgs> | null
    /**
     * The data used to update aiScheduledTasks.
     */
    data: XOR<aiScheduledTaskUpdateManyMutationInput, aiScheduledTaskUncheckedUpdateManyInput>
    /**
     * Filter which aiScheduledTasks to update
     */
    where?: aiScheduledTaskWhereInput
    /**
     * Limit how many aiScheduledTasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiScheduledTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * aiScheduledTask upsert
   */
  export type aiScheduledTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiScheduledTask
     */
    select?: aiScheduledTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiScheduledTask
     */
    omit?: aiScheduledTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiScheduledTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the aiScheduledTask to update in case it exists.
     */
    where: aiScheduledTaskWhereUniqueInput
    /**
     * In case the aiScheduledTask found by the `where` argument doesn't exist, create a new aiScheduledTask with this data.
     */
    create: XOR<aiScheduledTaskCreateInput, aiScheduledTaskUncheckedCreateInput>
    /**
     * In case the aiScheduledTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<aiScheduledTaskUpdateInput, aiScheduledTaskUncheckedUpdateInput>
  }

  /**
   * aiScheduledTask delete
   */
  export type aiScheduledTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiScheduledTask
     */
    select?: aiScheduledTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiScheduledTask
     */
    omit?: aiScheduledTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiScheduledTaskInclude<ExtArgs> | null
    /**
     * Filter which aiScheduledTask to delete.
     */
    where: aiScheduledTaskWhereUniqueInput
  }

  /**
   * aiScheduledTask deleteMany
   */
  export type aiScheduledTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which aiScheduledTasks to delete
     */
    where?: aiScheduledTaskWhereInput
    /**
     * Limit how many aiScheduledTasks to delete.
     */
    limit?: number
  }

  /**
   * aiScheduledTask without action
   */
  export type aiScheduledTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aiScheduledTask
     */
    select?: aiScheduledTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aiScheduledTask
     */
    omit?: aiScheduledTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aiScheduledTaskInclude<ExtArgs> | null
  }


  /**
   * Model mcpServers
   */

  export type AggregateMcpServers = {
    _count: McpServersCountAggregateOutputType | null
    _avg: McpServersAvgAggregateOutputType | null
    _sum: McpServersSumAggregateOutputType | null
    _min: McpServersMinAggregateOutputType | null
    _max: McpServersMaxAggregateOutputType | null
  }

  export type McpServersAvgAggregateOutputType = {
    id: number | null
  }

  export type McpServersSumAggregateOutputType = {
    id: number | null
  }

  export type McpServersMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    type: string | null
    command: string | null
    url: string | null
    isEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type McpServersMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    type: string | null
    command: string | null
    url: string | null
    isEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type McpServersCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    command: number
    args: number
    url: number
    env: number
    headers: number
    isEnabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type McpServersAvgAggregateInputType = {
    id?: true
  }

  export type McpServersSumAggregateInputType = {
    id?: true
  }

  export type McpServersMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    command?: true
    url?: true
    isEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type McpServersMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    command?: true
    url?: true
    isEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type McpServersCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    command?: true
    args?: true
    url?: true
    env?: true
    headers?: true
    isEnabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type McpServersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mcpServers to aggregate.
     */
    where?: mcpServersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mcpServers to fetch.
     */
    orderBy?: mcpServersOrderByWithRelationInput | mcpServersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mcpServersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mcpServers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mcpServers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mcpServers
    **/
    _count?: true | McpServersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: McpServersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: McpServersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: McpServersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: McpServersMaxAggregateInputType
  }

  export type GetMcpServersAggregateType<T extends McpServersAggregateArgs> = {
        [P in keyof T & keyof AggregateMcpServers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMcpServers[P]>
      : GetScalarType<T[P], AggregateMcpServers[P]>
  }




  export type mcpServersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mcpServersWhereInput
    orderBy?: mcpServersOrderByWithAggregationInput | mcpServersOrderByWithAggregationInput[]
    by: McpServersScalarFieldEnum[] | McpServersScalarFieldEnum
    having?: mcpServersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: McpServersCountAggregateInputType | true
    _avg?: McpServersAvgAggregateInputType
    _sum?: McpServersSumAggregateInputType
    _min?: McpServersMinAggregateInputType
    _max?: McpServersMaxAggregateInputType
  }

  export type McpServersGroupByOutputType = {
    id: number
    name: string
    description: string | null
    type: string
    command: string | null
    args: JsonValue | null
    url: string | null
    env: JsonValue | null
    headers: JsonValue | null
    isEnabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: McpServersCountAggregateOutputType | null
    _avg: McpServersAvgAggregateOutputType | null
    _sum: McpServersSumAggregateOutputType | null
    _min: McpServersMinAggregateOutputType | null
    _max: McpServersMaxAggregateOutputType | null
  }

  type GetMcpServersGroupByPayload<T extends mcpServersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<McpServersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof McpServersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], McpServersGroupByOutputType[P]>
            : GetScalarType<T[P], McpServersGroupByOutputType[P]>
        }
      >
    >


  export type mcpServersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    command?: boolean
    args?: boolean
    url?: boolean
    env?: boolean
    headers?: boolean
    isEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mcpServers"]>

  export type mcpServersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    command?: boolean
    args?: boolean
    url?: boolean
    env?: boolean
    headers?: boolean
    isEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mcpServers"]>

  export type mcpServersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    command?: boolean
    args?: boolean
    url?: boolean
    env?: boolean
    headers?: boolean
    isEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mcpServers"]>

  export type mcpServersSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    command?: boolean
    args?: boolean
    url?: boolean
    env?: boolean
    headers?: boolean
    isEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type mcpServersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "command" | "args" | "url" | "env" | "headers" | "isEnabled" | "createdAt" | "updatedAt", ExtArgs["result"]["mcpServers"]>

  export type $mcpServersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "mcpServers"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      type: string
      command: string | null
      args: Prisma.JsonValue | null
      url: string | null
      env: Prisma.JsonValue | null
      headers: Prisma.JsonValue | null
      isEnabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mcpServers"]>
    composites: {}
  }

  type mcpServersGetPayload<S extends boolean | null | undefined | mcpServersDefaultArgs> = $Result.GetResult<Prisma.$mcpServersPayload, S>

  type mcpServersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<mcpServersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: McpServersCountAggregateInputType | true
    }

  export interface mcpServersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mcpServers'], meta: { name: 'mcpServers' } }
    /**
     * Find zero or one McpServers that matches the filter.
     * @param {mcpServersFindUniqueArgs} args - Arguments to find a McpServers
     * @example
     * // Get one McpServers
     * const mcpServers = await prisma.mcpServers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mcpServersFindUniqueArgs>(args: SelectSubset<T, mcpServersFindUniqueArgs<ExtArgs>>): Prisma__mcpServersClient<$Result.GetResult<Prisma.$mcpServersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one McpServers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {mcpServersFindUniqueOrThrowArgs} args - Arguments to find a McpServers
     * @example
     * // Get one McpServers
     * const mcpServers = await prisma.mcpServers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mcpServersFindUniqueOrThrowArgs>(args: SelectSubset<T, mcpServersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mcpServersClient<$Result.GetResult<Prisma.$mcpServersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first McpServers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mcpServersFindFirstArgs} args - Arguments to find a McpServers
     * @example
     * // Get one McpServers
     * const mcpServers = await prisma.mcpServers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mcpServersFindFirstArgs>(args?: SelectSubset<T, mcpServersFindFirstArgs<ExtArgs>>): Prisma__mcpServersClient<$Result.GetResult<Prisma.$mcpServersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first McpServers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mcpServersFindFirstOrThrowArgs} args - Arguments to find a McpServers
     * @example
     * // Get one McpServers
     * const mcpServers = await prisma.mcpServers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mcpServersFindFirstOrThrowArgs>(args?: SelectSubset<T, mcpServersFindFirstOrThrowArgs<ExtArgs>>): Prisma__mcpServersClient<$Result.GetResult<Prisma.$mcpServersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more McpServers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mcpServersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all McpServers
     * const mcpServers = await prisma.mcpServers.findMany()
     * 
     * // Get first 10 McpServers
     * const mcpServers = await prisma.mcpServers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mcpServersWithIdOnly = await prisma.mcpServers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends mcpServersFindManyArgs>(args?: SelectSubset<T, mcpServersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mcpServersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a McpServers.
     * @param {mcpServersCreateArgs} args - Arguments to create a McpServers.
     * @example
     * // Create one McpServers
     * const McpServers = await prisma.mcpServers.create({
     *   data: {
     *     // ... data to create a McpServers
     *   }
     * })
     * 
     */
    create<T extends mcpServersCreateArgs>(args: SelectSubset<T, mcpServersCreateArgs<ExtArgs>>): Prisma__mcpServersClient<$Result.GetResult<Prisma.$mcpServersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many McpServers.
     * @param {mcpServersCreateManyArgs} args - Arguments to create many McpServers.
     * @example
     * // Create many McpServers
     * const mcpServers = await prisma.mcpServers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mcpServersCreateManyArgs>(args?: SelectSubset<T, mcpServersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many McpServers and returns the data saved in the database.
     * @param {mcpServersCreateManyAndReturnArgs} args - Arguments to create many McpServers.
     * @example
     * // Create many McpServers
     * const mcpServers = await prisma.mcpServers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many McpServers and only return the `id`
     * const mcpServersWithIdOnly = await prisma.mcpServers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends mcpServersCreateManyAndReturnArgs>(args?: SelectSubset<T, mcpServersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mcpServersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a McpServers.
     * @param {mcpServersDeleteArgs} args - Arguments to delete one McpServers.
     * @example
     * // Delete one McpServers
     * const McpServers = await prisma.mcpServers.delete({
     *   where: {
     *     // ... filter to delete one McpServers
     *   }
     * })
     * 
     */
    delete<T extends mcpServersDeleteArgs>(args: SelectSubset<T, mcpServersDeleteArgs<ExtArgs>>): Prisma__mcpServersClient<$Result.GetResult<Prisma.$mcpServersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one McpServers.
     * @param {mcpServersUpdateArgs} args - Arguments to update one McpServers.
     * @example
     * // Update one McpServers
     * const mcpServers = await prisma.mcpServers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mcpServersUpdateArgs>(args: SelectSubset<T, mcpServersUpdateArgs<ExtArgs>>): Prisma__mcpServersClient<$Result.GetResult<Prisma.$mcpServersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more McpServers.
     * @param {mcpServersDeleteManyArgs} args - Arguments to filter McpServers to delete.
     * @example
     * // Delete a few McpServers
     * const { count } = await prisma.mcpServers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mcpServersDeleteManyArgs>(args?: SelectSubset<T, mcpServersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more McpServers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mcpServersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many McpServers
     * const mcpServers = await prisma.mcpServers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mcpServersUpdateManyArgs>(args: SelectSubset<T, mcpServersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more McpServers and returns the data updated in the database.
     * @param {mcpServersUpdateManyAndReturnArgs} args - Arguments to update many McpServers.
     * @example
     * // Update many McpServers
     * const mcpServers = await prisma.mcpServers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more McpServers and only return the `id`
     * const mcpServersWithIdOnly = await prisma.mcpServers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends mcpServersUpdateManyAndReturnArgs>(args: SelectSubset<T, mcpServersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mcpServersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one McpServers.
     * @param {mcpServersUpsertArgs} args - Arguments to update or create a McpServers.
     * @example
     * // Update or create a McpServers
     * const mcpServers = await prisma.mcpServers.upsert({
     *   create: {
     *     // ... data to create a McpServers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the McpServers we want to update
     *   }
     * })
     */
    upsert<T extends mcpServersUpsertArgs>(args: SelectSubset<T, mcpServersUpsertArgs<ExtArgs>>): Prisma__mcpServersClient<$Result.GetResult<Prisma.$mcpServersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of McpServers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mcpServersCountArgs} args - Arguments to filter McpServers to count.
     * @example
     * // Count the number of McpServers
     * const count = await prisma.mcpServers.count({
     *   where: {
     *     // ... the filter for the McpServers we want to count
     *   }
     * })
    **/
    count<T extends mcpServersCountArgs>(
      args?: Subset<T, mcpServersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], McpServersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a McpServers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McpServersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends McpServersAggregateArgs>(args: Subset<T, McpServersAggregateArgs>): Prisma.PrismaPromise<GetMcpServersAggregateType<T>>

    /**
     * Group by McpServers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mcpServersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mcpServersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mcpServersGroupByArgs['orderBy'] }
        : { orderBy?: mcpServersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mcpServersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMcpServersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mcpServers model
   */
  readonly fields: mcpServersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mcpServers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mcpServersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the mcpServers model
   */
  interface mcpServersFieldRefs {
    readonly id: FieldRef<"mcpServers", 'Int'>
    readonly name: FieldRef<"mcpServers", 'String'>
    readonly description: FieldRef<"mcpServers", 'String'>
    readonly type: FieldRef<"mcpServers", 'String'>
    readonly command: FieldRef<"mcpServers", 'String'>
    readonly args: FieldRef<"mcpServers", 'Json'>
    readonly url: FieldRef<"mcpServers", 'String'>
    readonly env: FieldRef<"mcpServers", 'Json'>
    readonly headers: FieldRef<"mcpServers", 'Json'>
    readonly isEnabled: FieldRef<"mcpServers", 'Boolean'>
    readonly createdAt: FieldRef<"mcpServers", 'DateTime'>
    readonly updatedAt: FieldRef<"mcpServers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * mcpServers findUnique
   */
  export type mcpServersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mcpServers
     */
    select?: mcpServersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mcpServers
     */
    omit?: mcpServersOmit<ExtArgs> | null
    /**
     * Filter, which mcpServers to fetch.
     */
    where: mcpServersWhereUniqueInput
  }

  /**
   * mcpServers findUniqueOrThrow
   */
  export type mcpServersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mcpServers
     */
    select?: mcpServersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mcpServers
     */
    omit?: mcpServersOmit<ExtArgs> | null
    /**
     * Filter, which mcpServers to fetch.
     */
    where: mcpServersWhereUniqueInput
  }

  /**
   * mcpServers findFirst
   */
  export type mcpServersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mcpServers
     */
    select?: mcpServersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mcpServers
     */
    omit?: mcpServersOmit<ExtArgs> | null
    /**
     * Filter, which mcpServers to fetch.
     */
    where?: mcpServersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mcpServers to fetch.
     */
    orderBy?: mcpServersOrderByWithRelationInput | mcpServersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mcpServers.
     */
    cursor?: mcpServersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mcpServers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mcpServers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mcpServers.
     */
    distinct?: McpServersScalarFieldEnum | McpServersScalarFieldEnum[]
  }

  /**
   * mcpServers findFirstOrThrow
   */
  export type mcpServersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mcpServers
     */
    select?: mcpServersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mcpServers
     */
    omit?: mcpServersOmit<ExtArgs> | null
    /**
     * Filter, which mcpServers to fetch.
     */
    where?: mcpServersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mcpServers to fetch.
     */
    orderBy?: mcpServersOrderByWithRelationInput | mcpServersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mcpServers.
     */
    cursor?: mcpServersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mcpServers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mcpServers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mcpServers.
     */
    distinct?: McpServersScalarFieldEnum | McpServersScalarFieldEnum[]
  }

  /**
   * mcpServers findMany
   */
  export type mcpServersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mcpServers
     */
    select?: mcpServersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mcpServers
     */
    omit?: mcpServersOmit<ExtArgs> | null
    /**
     * Filter, which mcpServers to fetch.
     */
    where?: mcpServersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mcpServers to fetch.
     */
    orderBy?: mcpServersOrderByWithRelationInput | mcpServersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mcpServers.
     */
    cursor?: mcpServersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mcpServers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mcpServers.
     */
    skip?: number
    distinct?: McpServersScalarFieldEnum | McpServersScalarFieldEnum[]
  }

  /**
   * mcpServers create
   */
  export type mcpServersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mcpServers
     */
    select?: mcpServersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mcpServers
     */
    omit?: mcpServersOmit<ExtArgs> | null
    /**
     * The data needed to create a mcpServers.
     */
    data: XOR<mcpServersCreateInput, mcpServersUncheckedCreateInput>
  }

  /**
   * mcpServers createMany
   */
  export type mcpServersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mcpServers.
     */
    data: mcpServersCreateManyInput | mcpServersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mcpServers createManyAndReturn
   */
  export type mcpServersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mcpServers
     */
    select?: mcpServersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mcpServers
     */
    omit?: mcpServersOmit<ExtArgs> | null
    /**
     * The data used to create many mcpServers.
     */
    data: mcpServersCreateManyInput | mcpServersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mcpServers update
   */
  export type mcpServersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mcpServers
     */
    select?: mcpServersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mcpServers
     */
    omit?: mcpServersOmit<ExtArgs> | null
    /**
     * The data needed to update a mcpServers.
     */
    data: XOR<mcpServersUpdateInput, mcpServersUncheckedUpdateInput>
    /**
     * Choose, which mcpServers to update.
     */
    where: mcpServersWhereUniqueInput
  }

  /**
   * mcpServers updateMany
   */
  export type mcpServersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mcpServers.
     */
    data: XOR<mcpServersUpdateManyMutationInput, mcpServersUncheckedUpdateManyInput>
    /**
     * Filter which mcpServers to update
     */
    where?: mcpServersWhereInput
    /**
     * Limit how many mcpServers to update.
     */
    limit?: number
  }

  /**
   * mcpServers updateManyAndReturn
   */
  export type mcpServersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mcpServers
     */
    select?: mcpServersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mcpServers
     */
    omit?: mcpServersOmit<ExtArgs> | null
    /**
     * The data used to update mcpServers.
     */
    data: XOR<mcpServersUpdateManyMutationInput, mcpServersUncheckedUpdateManyInput>
    /**
     * Filter which mcpServers to update
     */
    where?: mcpServersWhereInput
    /**
     * Limit how many mcpServers to update.
     */
    limit?: number
  }

  /**
   * mcpServers upsert
   */
  export type mcpServersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mcpServers
     */
    select?: mcpServersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mcpServers
     */
    omit?: mcpServersOmit<ExtArgs> | null
    /**
     * The filter to search for the mcpServers to update in case it exists.
     */
    where: mcpServersWhereUniqueInput
    /**
     * In case the mcpServers found by the `where` argument doesn't exist, create a new mcpServers with this data.
     */
    create: XOR<mcpServersCreateInput, mcpServersUncheckedCreateInput>
    /**
     * In case the mcpServers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mcpServersUpdateInput, mcpServersUncheckedUpdateInput>
  }

  /**
   * mcpServers delete
   */
  export type mcpServersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mcpServers
     */
    select?: mcpServersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mcpServers
     */
    omit?: mcpServersOmit<ExtArgs> | null
    /**
     * Filter which mcpServers to delete.
     */
    where: mcpServersWhereUniqueInput
  }

  /**
   * mcpServers deleteMany
   */
  export type mcpServersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mcpServers to delete
     */
    where?: mcpServersWhereInput
    /**
     * Limit how many mcpServers to delete.
     */
    limit?: number
  }

  /**
   * mcpServers without action
   */
  export type mcpServersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mcpServers
     */
    select?: mcpServersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mcpServers
     */
    omit?: mcpServersOmit<ExtArgs> | null
  }


  /**
   * Model fonts
   */

  export type AggregateFonts = {
    _count: FontsCountAggregateOutputType | null
    _avg: FontsAvgAggregateOutputType | null
    _sum: FontsSumAggregateOutputType | null
    _min: FontsMinAggregateOutputType | null
    _max: FontsMaxAggregateOutputType | null
  }

  export type FontsAvgAggregateOutputType = {
    id: number | null
    sortOrder: number | null
  }

  export type FontsSumAggregateOutputType = {
    id: number | null
    sortOrder: number | null
  }

  export type FontsMinAggregateOutputType = {
    id: number | null
    name: string | null
    displayName: string | null
    url: string | null
    fileData: Bytes | null
    isLocal: boolean | null
    isSystem: boolean | null
    category: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FontsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    displayName: string | null
    url: string | null
    fileData: Bytes | null
    isLocal: boolean | null
    isSystem: boolean | null
    category: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FontsCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    url: number
    fileData: number
    isLocal: number
    isSystem: number
    weights: number
    category: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FontsAvgAggregateInputType = {
    id?: true
    sortOrder?: true
  }

  export type FontsSumAggregateInputType = {
    id?: true
    sortOrder?: true
  }

  export type FontsMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    url?: true
    fileData?: true
    isLocal?: true
    isSystem?: true
    category?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FontsMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    url?: true
    fileData?: true
    isLocal?: true
    isSystem?: true
    category?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FontsCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    url?: true
    fileData?: true
    isLocal?: true
    isSystem?: true
    weights?: true
    category?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FontsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fonts to aggregate.
     */
    where?: fontsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fonts to fetch.
     */
    orderBy?: fontsOrderByWithRelationInput | fontsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fontsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fonts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fonts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fonts
    **/
    _count?: true | FontsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FontsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FontsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FontsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FontsMaxAggregateInputType
  }

  export type GetFontsAggregateType<T extends FontsAggregateArgs> = {
        [P in keyof T & keyof AggregateFonts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFonts[P]>
      : GetScalarType<T[P], AggregateFonts[P]>
  }




  export type fontsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: fontsWhereInput
    orderBy?: fontsOrderByWithAggregationInput | fontsOrderByWithAggregationInput[]
    by: FontsScalarFieldEnum[] | FontsScalarFieldEnum
    having?: fontsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FontsCountAggregateInputType | true
    _avg?: FontsAvgAggregateInputType
    _sum?: FontsSumAggregateInputType
    _min?: FontsMinAggregateInputType
    _max?: FontsMaxAggregateInputType
  }

  export type FontsGroupByOutputType = {
    id: number
    name: string
    displayName: string
    url: string | null
    fileData: Bytes | null
    isLocal: boolean
    isSystem: boolean
    weights: JsonValue
    category: string
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: FontsCountAggregateOutputType | null
    _avg: FontsAvgAggregateOutputType | null
    _sum: FontsSumAggregateOutputType | null
    _min: FontsMinAggregateOutputType | null
    _max: FontsMaxAggregateOutputType | null
  }

  type GetFontsGroupByPayload<T extends fontsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FontsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FontsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FontsGroupByOutputType[P]>
            : GetScalarType<T[P], FontsGroupByOutputType[P]>
        }
      >
    >


  export type fontsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    url?: boolean
    fileData?: boolean
    isLocal?: boolean
    isSystem?: boolean
    weights?: boolean
    category?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fonts"]>

  export type fontsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    url?: boolean
    fileData?: boolean
    isLocal?: boolean
    isSystem?: boolean
    weights?: boolean
    category?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fonts"]>

  export type fontsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    url?: boolean
    fileData?: boolean
    isLocal?: boolean
    isSystem?: boolean
    weights?: boolean
    category?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fonts"]>

  export type fontsSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    url?: boolean
    fileData?: boolean
    isLocal?: boolean
    isSystem?: boolean
    weights?: boolean
    category?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type fontsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "displayName" | "url" | "fileData" | "isLocal" | "isSystem" | "weights" | "category" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["fonts"]>

  export type $fontsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "fonts"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      displayName: string
      url: string | null
      fileData: Prisma.Bytes | null
      isLocal: boolean
      isSystem: boolean
      weights: Prisma.JsonValue
      category: string
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fonts"]>
    composites: {}
  }

  type fontsGetPayload<S extends boolean | null | undefined | fontsDefaultArgs> = $Result.GetResult<Prisma.$fontsPayload, S>

  type fontsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<fontsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FontsCountAggregateInputType | true
    }

  export interface fontsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['fonts'], meta: { name: 'fonts' } }
    /**
     * Find zero or one Fonts that matches the filter.
     * @param {fontsFindUniqueArgs} args - Arguments to find a Fonts
     * @example
     * // Get one Fonts
     * const fonts = await prisma.fonts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends fontsFindUniqueArgs>(args: SelectSubset<T, fontsFindUniqueArgs<ExtArgs>>): Prisma__fontsClient<$Result.GetResult<Prisma.$fontsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Fonts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {fontsFindUniqueOrThrowArgs} args - Arguments to find a Fonts
     * @example
     * // Get one Fonts
     * const fonts = await prisma.fonts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends fontsFindUniqueOrThrowArgs>(args: SelectSubset<T, fontsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__fontsClient<$Result.GetResult<Prisma.$fontsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fonts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fontsFindFirstArgs} args - Arguments to find a Fonts
     * @example
     * // Get one Fonts
     * const fonts = await prisma.fonts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends fontsFindFirstArgs>(args?: SelectSubset<T, fontsFindFirstArgs<ExtArgs>>): Prisma__fontsClient<$Result.GetResult<Prisma.$fontsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fonts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fontsFindFirstOrThrowArgs} args - Arguments to find a Fonts
     * @example
     * // Get one Fonts
     * const fonts = await prisma.fonts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends fontsFindFirstOrThrowArgs>(args?: SelectSubset<T, fontsFindFirstOrThrowArgs<ExtArgs>>): Prisma__fontsClient<$Result.GetResult<Prisma.$fontsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fonts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fontsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fonts
     * const fonts = await prisma.fonts.findMany()
     * 
     * // Get first 10 Fonts
     * const fonts = await prisma.fonts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fontsWithIdOnly = await prisma.fonts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends fontsFindManyArgs>(args?: SelectSubset<T, fontsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$fontsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Fonts.
     * @param {fontsCreateArgs} args - Arguments to create a Fonts.
     * @example
     * // Create one Fonts
     * const Fonts = await prisma.fonts.create({
     *   data: {
     *     // ... data to create a Fonts
     *   }
     * })
     * 
     */
    create<T extends fontsCreateArgs>(args: SelectSubset<T, fontsCreateArgs<ExtArgs>>): Prisma__fontsClient<$Result.GetResult<Prisma.$fontsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fonts.
     * @param {fontsCreateManyArgs} args - Arguments to create many Fonts.
     * @example
     * // Create many Fonts
     * const fonts = await prisma.fonts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends fontsCreateManyArgs>(args?: SelectSubset<T, fontsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Fonts and returns the data saved in the database.
     * @param {fontsCreateManyAndReturnArgs} args - Arguments to create many Fonts.
     * @example
     * // Create many Fonts
     * const fonts = await prisma.fonts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Fonts and only return the `id`
     * const fontsWithIdOnly = await prisma.fonts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends fontsCreateManyAndReturnArgs>(args?: SelectSubset<T, fontsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$fontsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Fonts.
     * @param {fontsDeleteArgs} args - Arguments to delete one Fonts.
     * @example
     * // Delete one Fonts
     * const Fonts = await prisma.fonts.delete({
     *   where: {
     *     // ... filter to delete one Fonts
     *   }
     * })
     * 
     */
    delete<T extends fontsDeleteArgs>(args: SelectSubset<T, fontsDeleteArgs<ExtArgs>>): Prisma__fontsClient<$Result.GetResult<Prisma.$fontsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Fonts.
     * @param {fontsUpdateArgs} args - Arguments to update one Fonts.
     * @example
     * // Update one Fonts
     * const fonts = await prisma.fonts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends fontsUpdateArgs>(args: SelectSubset<T, fontsUpdateArgs<ExtArgs>>): Prisma__fontsClient<$Result.GetResult<Prisma.$fontsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fonts.
     * @param {fontsDeleteManyArgs} args - Arguments to filter Fonts to delete.
     * @example
     * // Delete a few Fonts
     * const { count } = await prisma.fonts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends fontsDeleteManyArgs>(args?: SelectSubset<T, fontsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fonts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fontsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fonts
     * const fonts = await prisma.fonts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends fontsUpdateManyArgs>(args: SelectSubset<T, fontsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fonts and returns the data updated in the database.
     * @param {fontsUpdateManyAndReturnArgs} args - Arguments to update many Fonts.
     * @example
     * // Update many Fonts
     * const fonts = await prisma.fonts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Fonts and only return the `id`
     * const fontsWithIdOnly = await prisma.fonts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends fontsUpdateManyAndReturnArgs>(args: SelectSubset<T, fontsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$fontsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Fonts.
     * @param {fontsUpsertArgs} args - Arguments to update or create a Fonts.
     * @example
     * // Update or create a Fonts
     * const fonts = await prisma.fonts.upsert({
     *   create: {
     *     // ... data to create a Fonts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fonts we want to update
     *   }
     * })
     */
    upsert<T extends fontsUpsertArgs>(args: SelectSubset<T, fontsUpsertArgs<ExtArgs>>): Prisma__fontsClient<$Result.GetResult<Prisma.$fontsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Fonts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fontsCountArgs} args - Arguments to filter Fonts to count.
     * @example
     * // Count the number of Fonts
     * const count = await prisma.fonts.count({
     *   where: {
     *     // ... the filter for the Fonts we want to count
     *   }
     * })
    **/
    count<T extends fontsCountArgs>(
      args?: Subset<T, fontsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FontsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fonts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FontsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FontsAggregateArgs>(args: Subset<T, FontsAggregateArgs>): Prisma.PrismaPromise<GetFontsAggregateType<T>>

    /**
     * Group by Fonts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fontsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends fontsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: fontsGroupByArgs['orderBy'] }
        : { orderBy?: fontsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, fontsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFontsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the fonts model
   */
  readonly fields: fontsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for fonts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__fontsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the fonts model
   */
  interface fontsFieldRefs {
    readonly id: FieldRef<"fonts", 'Int'>
    readonly name: FieldRef<"fonts", 'String'>
    readonly displayName: FieldRef<"fonts", 'String'>
    readonly url: FieldRef<"fonts", 'String'>
    readonly fileData: FieldRef<"fonts", 'Bytes'>
    readonly isLocal: FieldRef<"fonts", 'Boolean'>
    readonly isSystem: FieldRef<"fonts", 'Boolean'>
    readonly weights: FieldRef<"fonts", 'Json'>
    readonly category: FieldRef<"fonts", 'String'>
    readonly sortOrder: FieldRef<"fonts", 'Int'>
    readonly createdAt: FieldRef<"fonts", 'DateTime'>
    readonly updatedAt: FieldRef<"fonts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * fonts findUnique
   */
  export type fontsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fonts
     */
    select?: fontsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fonts
     */
    omit?: fontsOmit<ExtArgs> | null
    /**
     * Filter, which fonts to fetch.
     */
    where: fontsWhereUniqueInput
  }

  /**
   * fonts findUniqueOrThrow
   */
  export type fontsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fonts
     */
    select?: fontsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fonts
     */
    omit?: fontsOmit<ExtArgs> | null
    /**
     * Filter, which fonts to fetch.
     */
    where: fontsWhereUniqueInput
  }

  /**
   * fonts findFirst
   */
  export type fontsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fonts
     */
    select?: fontsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fonts
     */
    omit?: fontsOmit<ExtArgs> | null
    /**
     * Filter, which fonts to fetch.
     */
    where?: fontsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fonts to fetch.
     */
    orderBy?: fontsOrderByWithRelationInput | fontsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fonts.
     */
    cursor?: fontsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fonts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fonts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fonts.
     */
    distinct?: FontsScalarFieldEnum | FontsScalarFieldEnum[]
  }

  /**
   * fonts findFirstOrThrow
   */
  export type fontsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fonts
     */
    select?: fontsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fonts
     */
    omit?: fontsOmit<ExtArgs> | null
    /**
     * Filter, which fonts to fetch.
     */
    where?: fontsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fonts to fetch.
     */
    orderBy?: fontsOrderByWithRelationInput | fontsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fonts.
     */
    cursor?: fontsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fonts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fonts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fonts.
     */
    distinct?: FontsScalarFieldEnum | FontsScalarFieldEnum[]
  }

  /**
   * fonts findMany
   */
  export type fontsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fonts
     */
    select?: fontsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fonts
     */
    omit?: fontsOmit<ExtArgs> | null
    /**
     * Filter, which fonts to fetch.
     */
    where?: fontsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fonts to fetch.
     */
    orderBy?: fontsOrderByWithRelationInput | fontsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fonts.
     */
    cursor?: fontsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fonts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fonts.
     */
    skip?: number
    distinct?: FontsScalarFieldEnum | FontsScalarFieldEnum[]
  }

  /**
   * fonts create
   */
  export type fontsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fonts
     */
    select?: fontsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fonts
     */
    omit?: fontsOmit<ExtArgs> | null
    /**
     * The data needed to create a fonts.
     */
    data: XOR<fontsCreateInput, fontsUncheckedCreateInput>
  }

  /**
   * fonts createMany
   */
  export type fontsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many fonts.
     */
    data: fontsCreateManyInput | fontsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * fonts createManyAndReturn
   */
  export type fontsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fonts
     */
    select?: fontsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the fonts
     */
    omit?: fontsOmit<ExtArgs> | null
    /**
     * The data used to create many fonts.
     */
    data: fontsCreateManyInput | fontsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * fonts update
   */
  export type fontsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fonts
     */
    select?: fontsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fonts
     */
    omit?: fontsOmit<ExtArgs> | null
    /**
     * The data needed to update a fonts.
     */
    data: XOR<fontsUpdateInput, fontsUncheckedUpdateInput>
    /**
     * Choose, which fonts to update.
     */
    where: fontsWhereUniqueInput
  }

  /**
   * fonts updateMany
   */
  export type fontsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update fonts.
     */
    data: XOR<fontsUpdateManyMutationInput, fontsUncheckedUpdateManyInput>
    /**
     * Filter which fonts to update
     */
    where?: fontsWhereInput
    /**
     * Limit how many fonts to update.
     */
    limit?: number
  }

  /**
   * fonts updateManyAndReturn
   */
  export type fontsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fonts
     */
    select?: fontsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the fonts
     */
    omit?: fontsOmit<ExtArgs> | null
    /**
     * The data used to update fonts.
     */
    data: XOR<fontsUpdateManyMutationInput, fontsUncheckedUpdateManyInput>
    /**
     * Filter which fonts to update
     */
    where?: fontsWhereInput
    /**
     * Limit how many fonts to update.
     */
    limit?: number
  }

  /**
   * fonts upsert
   */
  export type fontsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fonts
     */
    select?: fontsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fonts
     */
    omit?: fontsOmit<ExtArgs> | null
    /**
     * The filter to search for the fonts to update in case it exists.
     */
    where: fontsWhereUniqueInput
    /**
     * In case the fonts found by the `where` argument doesn't exist, create a new fonts with this data.
     */
    create: XOR<fontsCreateInput, fontsUncheckedCreateInput>
    /**
     * In case the fonts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fontsUpdateInput, fontsUncheckedUpdateInput>
  }

  /**
   * fonts delete
   */
  export type fontsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fonts
     */
    select?: fontsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fonts
     */
    omit?: fontsOmit<ExtArgs> | null
    /**
     * Filter which fonts to delete.
     */
    where: fontsWhereUniqueInput
  }

  /**
   * fonts deleteMany
   */
  export type fontsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fonts to delete
     */
    where?: fontsWhereInput
    /**
     * Limit how many fonts to delete.
     */
    limit?: number
  }

  /**
   * fonts without action
   */
  export type fontsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fonts
     */
    select?: fontsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fonts
     */
    omit?: fontsOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    nickname: 'nickname',
    password: 'password',
    image: 'image',
    apiToken: 'apiToken',
    description: 'description',
    note: 'note',
    role: 'role',
    loginType: 'loginType',
    linkAccountId: 'linkAccountId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountsScalarFieldEnum = (typeof AccountsScalarFieldEnum)[keyof typeof AccountsScalarFieldEnum]


  export const AttachmentsScalarFieldEnum: {
    id: 'id',
    isShare: 'isShare',
    sharePassword: 'sharePassword',
    name: 'name',
    path: 'path',
    size: 'size',
    type: 'type',
    noteId: 'noteId',
    accountId: 'accountId',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    perfixPath: 'perfixPath',
    depth: 'depth',
    metadata: 'metadata'
  };

  export type AttachmentsScalarFieldEnum = (typeof AttachmentsScalarFieldEnum)[keyof typeof AttachmentsScalarFieldEnum]


  export const ConfigScalarFieldEnum: {
    id: 'id',
    key: 'key',
    config: 'config',
    userId: 'userId'
  };

  export type ConfigScalarFieldEnum = (typeof ConfigScalarFieldEnum)[keyof typeof ConfigScalarFieldEnum]


  export const NotesScalarFieldEnum: {
    id: 'id',
    type: 'type',
    content: 'content',
    isArchived: 'isArchived',
    isRecycle: 'isRecycle',
    isShare: 'isShare',
    isTop: 'isTop',
    isReviewed: 'isReviewed',
    sharePassword: 'sharePassword',
    shareEncryptedUrl: 'shareEncryptedUrl',
    shareExpiryDate: 'shareExpiryDate',
    shareMaxView: 'shareMaxView',
    shareViewCount: 'shareViewCount',
    metadata: 'metadata',
    accountId: 'accountId',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotesScalarFieldEnum = (typeof NotesScalarFieldEnum)[keyof typeof NotesScalarFieldEnum]


  export const CommentsScalarFieldEnum: {
    id: 'id',
    content: 'content',
    accountId: 'accountId',
    guestName: 'guestName',
    guestIP: 'guestIP',
    guestUA: 'guestUA',
    noteId: 'noteId',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentsScalarFieldEnum = (typeof CommentsScalarFieldEnum)[keyof typeof CommentsScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    icon: 'icon',
    parent: 'parent',
    accountId: 'accountId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sortOrder: 'sortOrder'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const TagsToNoteScalarFieldEnum: {
    id: 'id',
    noteId: 'noteId',
    tagId: 'tagId'
  };

  export type TagsToNoteScalarFieldEnum = (typeof TagsToNoteScalarFieldEnum)[keyof typeof TagsToNoteScalarFieldEnum]


  export const NoteReferenceScalarFieldEnum: {
    id: 'id',
    fromNoteId: 'fromNoteId',
    toNoteId: 'toNoteId',
    createdAt: 'createdAt'
  };

  export type NoteReferenceScalarFieldEnum = (typeof NoteReferenceScalarFieldEnum)[keyof typeof NoteReferenceScalarFieldEnum]


  export const FollowsScalarFieldEnum: {
    id: 'id',
    siteName: 'siteName',
    siteUrl: 'siteUrl',
    siteAvatar: 'siteAvatar',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    followType: 'followType',
    accountId: 'accountId'
  };

  export type FollowsScalarFieldEnum = (typeof FollowsScalarFieldEnum)[keyof typeof FollowsScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    content: 'content',
    metadata: 'metadata',
    isRead: 'isRead',
    accountId: 'accountId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const CacheScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CacheScalarFieldEnum = (typeof CacheScalarFieldEnum)[keyof typeof CacheScalarFieldEnum]


  export const PluginScalarFieldEnum: {
    id: 'id',
    metadata: 'metadata',
    path: 'path',
    isUse: 'isUse',
    isDev: 'isDev',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PluginScalarFieldEnum = (typeof PluginScalarFieldEnum)[keyof typeof PluginScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    isShare: 'isShare',
    accountId: 'accountId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    role: 'role',
    conversationId: 'conversationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    metadata: 'metadata'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const NoteHistoryScalarFieldEnum: {
    id: 'id',
    noteId: 'noteId',
    content: 'content',
    metadata: 'metadata',
    version: 'version',
    accountId: 'accountId',
    createdAt: 'createdAt'
  };

  export type NoteHistoryScalarFieldEnum = (typeof NoteHistoryScalarFieldEnum)[keyof typeof NoteHistoryScalarFieldEnum]


  export const NoteInternalShareScalarFieldEnum: {
    id: 'id',
    noteId: 'noteId',
    accountId: 'accountId',
    canEdit: 'canEdit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NoteInternalShareScalarFieldEnum = (typeof NoteInternalShareScalarFieldEnum)[keyof typeof NoteInternalShareScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sid: 'sid',
    data: 'data',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AiProvidersScalarFieldEnum: {
    id: 'id',
    title: 'title',
    provider: 'provider',
    baseURL: 'baseURL',
    apiKey: 'apiKey',
    config: 'config',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AiProvidersScalarFieldEnum = (typeof AiProvidersScalarFieldEnum)[keyof typeof AiProvidersScalarFieldEnum]


  export const AiModelsScalarFieldEnum: {
    id: 'id',
    providerId: 'providerId',
    title: 'title',
    modelKey: 'modelKey',
    capabilities: 'capabilities',
    config: 'config',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AiModelsScalarFieldEnum = (typeof AiModelsScalarFieldEnum)[keyof typeof AiModelsScalarFieldEnum]


  export const AiScheduledTaskScalarFieldEnum: {
    id: 'id',
    name: 'name',
    prompt: 'prompt',
    schedule: 'schedule',
    isEnabled: 'isEnabled',
    lastRun: 'lastRun',
    lastResult: 'lastResult',
    accountId: 'accountId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AiScheduledTaskScalarFieldEnum = (typeof AiScheduledTaskScalarFieldEnum)[keyof typeof AiScheduledTaskScalarFieldEnum]


  export const McpServersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    command: 'command',
    args: 'args',
    url: 'url',
    env: 'env',
    headers: 'headers',
    isEnabled: 'isEnabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type McpServersScalarFieldEnum = (typeof McpServersScalarFieldEnum)[keyof typeof McpServersScalarFieldEnum]


  export const FontsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    url: 'url',
    fileData: 'fileData',
    isLocal: 'isLocal',
    isSystem: 'isSystem',
    weights: 'weights',
    category: 'category',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FontsScalarFieldEnum = (typeof FontsScalarFieldEnum)[keyof typeof FontsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type accountsWhereInput = {
    AND?: accountsWhereInput | accountsWhereInput[]
    OR?: accountsWhereInput[]
    NOT?: accountsWhereInput | accountsWhereInput[]
    id?: IntFilter<"accounts"> | number
    name?: StringFilter<"accounts"> | string
    nickname?: StringFilter<"accounts"> | string
    password?: StringFilter<"accounts"> | string
    image?: StringFilter<"accounts"> | string
    apiToken?: StringFilter<"accounts"> | string
    description?: StringFilter<"accounts"> | string
    note?: IntFilter<"accounts"> | number
    role?: StringFilter<"accounts"> | string
    loginType?: StringFilter<"accounts"> | string
    linkAccountId?: IntNullableFilter<"accounts"> | number | null
    createdAt?: DateTimeFilter<"accounts"> | Date | string
    updatedAt?: DateTimeFilter<"accounts"> | Date | string
    notes?: NotesListRelationFilter
    configs?: ConfigListRelationFilter
    tags?: TagListRelationFilter
    comments?: CommentsListRelationFilter
    attachments?: AttachmentsListRelationFilter
    follows?: FollowsListRelationFilter
    notifications?: NotificationsListRelationFilter
    conversations?: ConversationListRelationFilter
    sharedNotes?: NoteInternalShareListRelationFilter
    aiScheduledTasks?: AiScheduledTaskListRelationFilter
  }

  export type accountsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    nickname?: SortOrder
    password?: SortOrder
    image?: SortOrder
    apiToken?: SortOrder
    description?: SortOrder
    note?: SortOrder
    role?: SortOrder
    loginType?: SortOrder
    linkAccountId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notes?: notesOrderByRelationAggregateInput
    configs?: configOrderByRelationAggregateInput
    tags?: tagOrderByRelationAggregateInput
    comments?: commentsOrderByRelationAggregateInput
    attachments?: attachmentsOrderByRelationAggregateInput
    follows?: followsOrderByRelationAggregateInput
    notifications?: notificationsOrderByRelationAggregateInput
    conversations?: conversationOrderByRelationAggregateInput
    sharedNotes?: noteInternalShareOrderByRelationAggregateInput
    aiScheduledTasks?: aiScheduledTaskOrderByRelationAggregateInput
  }

  export type accountsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: accountsWhereInput | accountsWhereInput[]
    OR?: accountsWhereInput[]
    NOT?: accountsWhereInput | accountsWhereInput[]
    name?: StringFilter<"accounts"> | string
    nickname?: StringFilter<"accounts"> | string
    password?: StringFilter<"accounts"> | string
    image?: StringFilter<"accounts"> | string
    apiToken?: StringFilter<"accounts"> | string
    description?: StringFilter<"accounts"> | string
    note?: IntFilter<"accounts"> | number
    role?: StringFilter<"accounts"> | string
    loginType?: StringFilter<"accounts"> | string
    linkAccountId?: IntNullableFilter<"accounts"> | number | null
    createdAt?: DateTimeFilter<"accounts"> | Date | string
    updatedAt?: DateTimeFilter<"accounts"> | Date | string
    notes?: NotesListRelationFilter
    configs?: ConfigListRelationFilter
    tags?: TagListRelationFilter
    comments?: CommentsListRelationFilter
    attachments?: AttachmentsListRelationFilter
    follows?: FollowsListRelationFilter
    notifications?: NotificationsListRelationFilter
    conversations?: ConversationListRelationFilter
    sharedNotes?: NoteInternalShareListRelationFilter
    aiScheduledTasks?: AiScheduledTaskListRelationFilter
  }, "id">

  export type accountsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    nickname?: SortOrder
    password?: SortOrder
    image?: SortOrder
    apiToken?: SortOrder
    description?: SortOrder
    note?: SortOrder
    role?: SortOrder
    loginType?: SortOrder
    linkAccountId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: accountsCountOrderByAggregateInput
    _avg?: accountsAvgOrderByAggregateInput
    _max?: accountsMaxOrderByAggregateInput
    _min?: accountsMinOrderByAggregateInput
    _sum?: accountsSumOrderByAggregateInput
  }

  export type accountsScalarWhereWithAggregatesInput = {
    AND?: accountsScalarWhereWithAggregatesInput | accountsScalarWhereWithAggregatesInput[]
    OR?: accountsScalarWhereWithAggregatesInput[]
    NOT?: accountsScalarWhereWithAggregatesInput | accountsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"accounts"> | number
    name?: StringWithAggregatesFilter<"accounts"> | string
    nickname?: StringWithAggregatesFilter<"accounts"> | string
    password?: StringWithAggregatesFilter<"accounts"> | string
    image?: StringWithAggregatesFilter<"accounts"> | string
    apiToken?: StringWithAggregatesFilter<"accounts"> | string
    description?: StringWithAggregatesFilter<"accounts"> | string
    note?: IntWithAggregatesFilter<"accounts"> | number
    role?: StringWithAggregatesFilter<"accounts"> | string
    loginType?: StringWithAggregatesFilter<"accounts"> | string
    linkAccountId?: IntNullableWithAggregatesFilter<"accounts"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"accounts"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"accounts"> | Date | string
  }

  export type attachmentsWhereInput = {
    AND?: attachmentsWhereInput | attachmentsWhereInput[]
    OR?: attachmentsWhereInput[]
    NOT?: attachmentsWhereInput | attachmentsWhereInput[]
    id?: IntFilter<"attachments"> | number
    isShare?: BoolFilter<"attachments"> | boolean
    sharePassword?: StringFilter<"attachments"> | string
    name?: StringFilter<"attachments"> | string
    path?: StringFilter<"attachments"> | string
    size?: DecimalFilter<"attachments"> | Decimal | DecimalJsLike | number | string
    type?: StringFilter<"attachments"> | string
    noteId?: IntNullableFilter<"attachments"> | number | null
    accountId?: IntNullableFilter<"attachments"> | number | null
    sortOrder?: IntFilter<"attachments"> | number
    createdAt?: DateTimeFilter<"attachments"> | Date | string
    updatedAt?: DateTimeFilter<"attachments"> | Date | string
    perfixPath?: StringNullableFilter<"attachments"> | string | null
    depth?: IntNullableFilter<"attachments"> | number | null
    metadata?: JsonNullableFilter<"attachments">
    note?: XOR<NotesNullableScalarRelationFilter, notesWhereInput> | null
    account?: XOR<AccountsNullableScalarRelationFilter, accountsWhereInput> | null
  }

  export type attachmentsOrderByWithRelationInput = {
    id?: SortOrder
    isShare?: SortOrder
    sharePassword?: SortOrder
    name?: SortOrder
    path?: SortOrder
    size?: SortOrder
    type?: SortOrder
    noteId?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    perfixPath?: SortOrderInput | SortOrder
    depth?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    note?: notesOrderByWithRelationInput
    account?: accountsOrderByWithRelationInput
  }

  export type attachmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: attachmentsWhereInput | attachmentsWhereInput[]
    OR?: attachmentsWhereInput[]
    NOT?: attachmentsWhereInput | attachmentsWhereInput[]
    isShare?: BoolFilter<"attachments"> | boolean
    sharePassword?: StringFilter<"attachments"> | string
    name?: StringFilter<"attachments"> | string
    path?: StringFilter<"attachments"> | string
    size?: DecimalFilter<"attachments"> | Decimal | DecimalJsLike | number | string
    type?: StringFilter<"attachments"> | string
    noteId?: IntNullableFilter<"attachments"> | number | null
    accountId?: IntNullableFilter<"attachments"> | number | null
    sortOrder?: IntFilter<"attachments"> | number
    createdAt?: DateTimeFilter<"attachments"> | Date | string
    updatedAt?: DateTimeFilter<"attachments"> | Date | string
    perfixPath?: StringNullableFilter<"attachments"> | string | null
    depth?: IntNullableFilter<"attachments"> | number | null
    metadata?: JsonNullableFilter<"attachments">
    note?: XOR<NotesNullableScalarRelationFilter, notesWhereInput> | null
    account?: XOR<AccountsNullableScalarRelationFilter, accountsWhereInput> | null
  }, "id">

  export type attachmentsOrderByWithAggregationInput = {
    id?: SortOrder
    isShare?: SortOrder
    sharePassword?: SortOrder
    name?: SortOrder
    path?: SortOrder
    size?: SortOrder
    type?: SortOrder
    noteId?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    perfixPath?: SortOrderInput | SortOrder
    depth?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: attachmentsCountOrderByAggregateInput
    _avg?: attachmentsAvgOrderByAggregateInput
    _max?: attachmentsMaxOrderByAggregateInput
    _min?: attachmentsMinOrderByAggregateInput
    _sum?: attachmentsSumOrderByAggregateInput
  }

  export type attachmentsScalarWhereWithAggregatesInput = {
    AND?: attachmentsScalarWhereWithAggregatesInput | attachmentsScalarWhereWithAggregatesInput[]
    OR?: attachmentsScalarWhereWithAggregatesInput[]
    NOT?: attachmentsScalarWhereWithAggregatesInput | attachmentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"attachments"> | number
    isShare?: BoolWithAggregatesFilter<"attachments"> | boolean
    sharePassword?: StringWithAggregatesFilter<"attachments"> | string
    name?: StringWithAggregatesFilter<"attachments"> | string
    path?: StringWithAggregatesFilter<"attachments"> | string
    size?: DecimalWithAggregatesFilter<"attachments"> | Decimal | DecimalJsLike | number | string
    type?: StringWithAggregatesFilter<"attachments"> | string
    noteId?: IntNullableWithAggregatesFilter<"attachments"> | number | null
    accountId?: IntNullableWithAggregatesFilter<"attachments"> | number | null
    sortOrder?: IntWithAggregatesFilter<"attachments"> | number
    createdAt?: DateTimeWithAggregatesFilter<"attachments"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"attachments"> | Date | string
    perfixPath?: StringNullableWithAggregatesFilter<"attachments"> | string | null
    depth?: IntNullableWithAggregatesFilter<"attachments"> | number | null
    metadata?: JsonNullableWithAggregatesFilter<"attachments">
  }

  export type configWhereInput = {
    AND?: configWhereInput | configWhereInput[]
    OR?: configWhereInput[]
    NOT?: configWhereInput | configWhereInput[]
    id?: IntFilter<"config"> | number
    key?: StringFilter<"config"> | string
    config?: JsonNullableFilter<"config">
    userId?: IntNullableFilter<"config"> | number | null
    user?: XOR<AccountsNullableScalarRelationFilter, accountsWhereInput> | null
  }

  export type configOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    config?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    user?: accountsOrderByWithRelationInput
  }

  export type configWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: configWhereInput | configWhereInput[]
    OR?: configWhereInput[]
    NOT?: configWhereInput | configWhereInput[]
    key?: StringFilter<"config"> | string
    config?: JsonNullableFilter<"config">
    userId?: IntNullableFilter<"config"> | number | null
    user?: XOR<AccountsNullableScalarRelationFilter, accountsWhereInput> | null
  }, "id">

  export type configOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    config?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: configCountOrderByAggregateInput
    _avg?: configAvgOrderByAggregateInput
    _max?: configMaxOrderByAggregateInput
    _min?: configMinOrderByAggregateInput
    _sum?: configSumOrderByAggregateInput
  }

  export type configScalarWhereWithAggregatesInput = {
    AND?: configScalarWhereWithAggregatesInput | configScalarWhereWithAggregatesInput[]
    OR?: configScalarWhereWithAggregatesInput[]
    NOT?: configScalarWhereWithAggregatesInput | configScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"config"> | number
    key?: StringWithAggregatesFilter<"config"> | string
    config?: JsonNullableWithAggregatesFilter<"config">
    userId?: IntNullableWithAggregatesFilter<"config"> | number | null
  }

  export type notesWhereInput = {
    AND?: notesWhereInput | notesWhereInput[]
    OR?: notesWhereInput[]
    NOT?: notesWhereInput | notesWhereInput[]
    id?: IntFilter<"notes"> | number
    type?: IntFilter<"notes"> | number
    content?: StringFilter<"notes"> | string
    isArchived?: BoolFilter<"notes"> | boolean
    isRecycle?: BoolFilter<"notes"> | boolean
    isShare?: BoolFilter<"notes"> | boolean
    isTop?: BoolFilter<"notes"> | boolean
    isReviewed?: BoolFilter<"notes"> | boolean
    sharePassword?: StringFilter<"notes"> | string
    shareEncryptedUrl?: StringNullableFilter<"notes"> | string | null
    shareExpiryDate?: DateTimeNullableFilter<"notes"> | Date | string | null
    shareMaxView?: IntNullableFilter<"notes"> | number | null
    shareViewCount?: IntNullableFilter<"notes"> | number | null
    metadata?: JsonNullableFilter<"notes">
    accountId?: IntNullableFilter<"notes"> | number | null
    sortOrder?: IntFilter<"notes"> | number
    createdAt?: DateTimeFilter<"notes"> | Date | string
    updatedAt?: DateTimeFilter<"notes"> | Date | string
    attachments?: AttachmentsListRelationFilter
    tags?: TagsToNoteListRelationFilter
    account?: XOR<AccountsNullableScalarRelationFilter, accountsWhereInput> | null
    referencedBy?: NoteReferenceListRelationFilter
    references?: NoteReferenceListRelationFilter
    comments?: CommentsListRelationFilter
    histories?: NoteHistoryListRelationFilter
    internalShares?: NoteInternalShareListRelationFilter
  }

  export type notesOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    isArchived?: SortOrder
    isRecycle?: SortOrder
    isShare?: SortOrder
    isTop?: SortOrder
    isReviewed?: SortOrder
    sharePassword?: SortOrder
    shareEncryptedUrl?: SortOrderInput | SortOrder
    shareExpiryDate?: SortOrderInput | SortOrder
    shareMaxView?: SortOrderInput | SortOrder
    shareViewCount?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    attachments?: attachmentsOrderByRelationAggregateInput
    tags?: tagsToNoteOrderByRelationAggregateInput
    account?: accountsOrderByWithRelationInput
    referencedBy?: noteReferenceOrderByRelationAggregateInput
    references?: noteReferenceOrderByRelationAggregateInput
    comments?: commentsOrderByRelationAggregateInput
    histories?: noteHistoryOrderByRelationAggregateInput
    internalShares?: noteInternalShareOrderByRelationAggregateInput
  }

  export type notesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: notesWhereInput | notesWhereInput[]
    OR?: notesWhereInput[]
    NOT?: notesWhereInput | notesWhereInput[]
    type?: IntFilter<"notes"> | number
    content?: StringFilter<"notes"> | string
    isArchived?: BoolFilter<"notes"> | boolean
    isRecycle?: BoolFilter<"notes"> | boolean
    isShare?: BoolFilter<"notes"> | boolean
    isTop?: BoolFilter<"notes"> | boolean
    isReviewed?: BoolFilter<"notes"> | boolean
    sharePassword?: StringFilter<"notes"> | string
    shareEncryptedUrl?: StringNullableFilter<"notes"> | string | null
    shareExpiryDate?: DateTimeNullableFilter<"notes"> | Date | string | null
    shareMaxView?: IntNullableFilter<"notes"> | number | null
    shareViewCount?: IntNullableFilter<"notes"> | number | null
    metadata?: JsonNullableFilter<"notes">
    accountId?: IntNullableFilter<"notes"> | number | null
    sortOrder?: IntFilter<"notes"> | number
    createdAt?: DateTimeFilter<"notes"> | Date | string
    updatedAt?: DateTimeFilter<"notes"> | Date | string
    attachments?: AttachmentsListRelationFilter
    tags?: TagsToNoteListRelationFilter
    account?: XOR<AccountsNullableScalarRelationFilter, accountsWhereInput> | null
    referencedBy?: NoteReferenceListRelationFilter
    references?: NoteReferenceListRelationFilter
    comments?: CommentsListRelationFilter
    histories?: NoteHistoryListRelationFilter
    internalShares?: NoteInternalShareListRelationFilter
  }, "id">

  export type notesOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    isArchived?: SortOrder
    isRecycle?: SortOrder
    isShare?: SortOrder
    isTop?: SortOrder
    isReviewed?: SortOrder
    sharePassword?: SortOrder
    shareEncryptedUrl?: SortOrderInput | SortOrder
    shareExpiryDate?: SortOrderInput | SortOrder
    shareMaxView?: SortOrderInput | SortOrder
    shareViewCount?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: notesCountOrderByAggregateInput
    _avg?: notesAvgOrderByAggregateInput
    _max?: notesMaxOrderByAggregateInput
    _min?: notesMinOrderByAggregateInput
    _sum?: notesSumOrderByAggregateInput
  }

  export type notesScalarWhereWithAggregatesInput = {
    AND?: notesScalarWhereWithAggregatesInput | notesScalarWhereWithAggregatesInput[]
    OR?: notesScalarWhereWithAggregatesInput[]
    NOT?: notesScalarWhereWithAggregatesInput | notesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"notes"> | number
    type?: IntWithAggregatesFilter<"notes"> | number
    content?: StringWithAggregatesFilter<"notes"> | string
    isArchived?: BoolWithAggregatesFilter<"notes"> | boolean
    isRecycle?: BoolWithAggregatesFilter<"notes"> | boolean
    isShare?: BoolWithAggregatesFilter<"notes"> | boolean
    isTop?: BoolWithAggregatesFilter<"notes"> | boolean
    isReviewed?: BoolWithAggregatesFilter<"notes"> | boolean
    sharePassword?: StringWithAggregatesFilter<"notes"> | string
    shareEncryptedUrl?: StringNullableWithAggregatesFilter<"notes"> | string | null
    shareExpiryDate?: DateTimeNullableWithAggregatesFilter<"notes"> | Date | string | null
    shareMaxView?: IntNullableWithAggregatesFilter<"notes"> | number | null
    shareViewCount?: IntNullableWithAggregatesFilter<"notes"> | number | null
    metadata?: JsonNullableWithAggregatesFilter<"notes">
    accountId?: IntNullableWithAggregatesFilter<"notes"> | number | null
    sortOrder?: IntWithAggregatesFilter<"notes"> | number
    createdAt?: DateTimeWithAggregatesFilter<"notes"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"notes"> | Date | string
  }

  export type commentsWhereInput = {
    AND?: commentsWhereInput | commentsWhereInput[]
    OR?: commentsWhereInput[]
    NOT?: commentsWhereInput | commentsWhereInput[]
    id?: IntFilter<"comments"> | number
    content?: StringFilter<"comments"> | string
    accountId?: IntNullableFilter<"comments"> | number | null
    guestName?: StringNullableFilter<"comments"> | string | null
    guestIP?: StringNullableFilter<"comments"> | string | null
    guestUA?: StringNullableFilter<"comments"> | string | null
    noteId?: IntFilter<"comments"> | number
    parentId?: IntNullableFilter<"comments"> | number | null
    createdAt?: DateTimeFilter<"comments"> | Date | string
    updatedAt?: DateTimeFilter<"comments"> | Date | string
    note?: XOR<NotesScalarRelationFilter, notesWhereInput>
    account?: XOR<AccountsNullableScalarRelationFilter, accountsWhereInput> | null
    parent?: XOR<CommentsNullableScalarRelationFilter, commentsWhereInput> | null
    replies?: CommentsListRelationFilter
  }

  export type commentsOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    accountId?: SortOrderInput | SortOrder
    guestName?: SortOrderInput | SortOrder
    guestIP?: SortOrderInput | SortOrder
    guestUA?: SortOrderInput | SortOrder
    noteId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    note?: notesOrderByWithRelationInput
    account?: accountsOrderByWithRelationInput
    parent?: commentsOrderByWithRelationInput
    replies?: commentsOrderByRelationAggregateInput
  }

  export type commentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: commentsWhereInput | commentsWhereInput[]
    OR?: commentsWhereInput[]
    NOT?: commentsWhereInput | commentsWhereInput[]
    content?: StringFilter<"comments"> | string
    accountId?: IntNullableFilter<"comments"> | number | null
    guestName?: StringNullableFilter<"comments"> | string | null
    guestIP?: StringNullableFilter<"comments"> | string | null
    guestUA?: StringNullableFilter<"comments"> | string | null
    noteId?: IntFilter<"comments"> | number
    parentId?: IntNullableFilter<"comments"> | number | null
    createdAt?: DateTimeFilter<"comments"> | Date | string
    updatedAt?: DateTimeFilter<"comments"> | Date | string
    note?: XOR<NotesScalarRelationFilter, notesWhereInput>
    account?: XOR<AccountsNullableScalarRelationFilter, accountsWhereInput> | null
    parent?: XOR<CommentsNullableScalarRelationFilter, commentsWhereInput> | null
    replies?: CommentsListRelationFilter
  }, "id">

  export type commentsOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    accountId?: SortOrderInput | SortOrder
    guestName?: SortOrderInput | SortOrder
    guestIP?: SortOrderInput | SortOrder
    guestUA?: SortOrderInput | SortOrder
    noteId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: commentsCountOrderByAggregateInput
    _avg?: commentsAvgOrderByAggregateInput
    _max?: commentsMaxOrderByAggregateInput
    _min?: commentsMinOrderByAggregateInput
    _sum?: commentsSumOrderByAggregateInput
  }

  export type commentsScalarWhereWithAggregatesInput = {
    AND?: commentsScalarWhereWithAggregatesInput | commentsScalarWhereWithAggregatesInput[]
    OR?: commentsScalarWhereWithAggregatesInput[]
    NOT?: commentsScalarWhereWithAggregatesInput | commentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"comments"> | number
    content?: StringWithAggregatesFilter<"comments"> | string
    accountId?: IntNullableWithAggregatesFilter<"comments"> | number | null
    guestName?: StringNullableWithAggregatesFilter<"comments"> | string | null
    guestIP?: StringNullableWithAggregatesFilter<"comments"> | string | null
    guestUA?: StringNullableWithAggregatesFilter<"comments"> | string | null
    noteId?: IntWithAggregatesFilter<"comments"> | number
    parentId?: IntNullableWithAggregatesFilter<"comments"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"comments"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"comments"> | Date | string
  }

  export type tagWhereInput = {
    AND?: tagWhereInput | tagWhereInput[]
    OR?: tagWhereInput[]
    NOT?: tagWhereInput | tagWhereInput[]
    id?: IntFilter<"tag"> | number
    name?: StringFilter<"tag"> | string
    icon?: StringFilter<"tag"> | string
    parent?: IntFilter<"tag"> | number
    accountId?: IntNullableFilter<"tag"> | number | null
    createdAt?: DateTimeFilter<"tag"> | Date | string
    updatedAt?: DateTimeFilter<"tag"> | Date | string
    sortOrder?: IntFilter<"tag"> | number
    tagsToNote?: TagsToNoteListRelationFilter
    account?: XOR<AccountsNullableScalarRelationFilter, accountsWhereInput> | null
  }

  export type tagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    parent?: SortOrder
    accountId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sortOrder?: SortOrder
    tagsToNote?: tagsToNoteOrderByRelationAggregateInput
    account?: accountsOrderByWithRelationInput
  }

  export type tagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: tagWhereInput | tagWhereInput[]
    OR?: tagWhereInput[]
    NOT?: tagWhereInput | tagWhereInput[]
    name?: StringFilter<"tag"> | string
    icon?: StringFilter<"tag"> | string
    parent?: IntFilter<"tag"> | number
    accountId?: IntNullableFilter<"tag"> | number | null
    createdAt?: DateTimeFilter<"tag"> | Date | string
    updatedAt?: DateTimeFilter<"tag"> | Date | string
    sortOrder?: IntFilter<"tag"> | number
    tagsToNote?: TagsToNoteListRelationFilter
    account?: XOR<AccountsNullableScalarRelationFilter, accountsWhereInput> | null
  }, "id">

  export type tagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    parent?: SortOrder
    accountId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sortOrder?: SortOrder
    _count?: tagCountOrderByAggregateInput
    _avg?: tagAvgOrderByAggregateInput
    _max?: tagMaxOrderByAggregateInput
    _min?: tagMinOrderByAggregateInput
    _sum?: tagSumOrderByAggregateInput
  }

  export type tagScalarWhereWithAggregatesInput = {
    AND?: tagScalarWhereWithAggregatesInput | tagScalarWhereWithAggregatesInput[]
    OR?: tagScalarWhereWithAggregatesInput[]
    NOT?: tagScalarWhereWithAggregatesInput | tagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tag"> | number
    name?: StringWithAggregatesFilter<"tag"> | string
    icon?: StringWithAggregatesFilter<"tag"> | string
    parent?: IntWithAggregatesFilter<"tag"> | number
    accountId?: IntNullableWithAggregatesFilter<"tag"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"tag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"tag"> | Date | string
    sortOrder?: IntWithAggregatesFilter<"tag"> | number
  }

  export type tagsToNoteWhereInput = {
    AND?: tagsToNoteWhereInput | tagsToNoteWhereInput[]
    OR?: tagsToNoteWhereInput[]
    NOT?: tagsToNoteWhereInput | tagsToNoteWhereInput[]
    id?: IntFilter<"tagsToNote"> | number
    noteId?: IntFilter<"tagsToNote"> | number
    tagId?: IntFilter<"tagsToNote"> | number
    note?: XOR<NotesScalarRelationFilter, notesWhereInput>
    tag?: XOR<TagScalarRelationFilter, tagWhereInput>
  }

  export type tagsToNoteOrderByWithRelationInput = {
    id?: SortOrder
    noteId?: SortOrder
    tagId?: SortOrder
    note?: notesOrderByWithRelationInput
    tag?: tagOrderByWithRelationInput
  }

  export type tagsToNoteWhereUniqueInput = Prisma.AtLeast<{
    noteId_tagId?: tagsToNoteNoteIdTagIdCompoundUniqueInput
    AND?: tagsToNoteWhereInput | tagsToNoteWhereInput[]
    OR?: tagsToNoteWhereInput[]
    NOT?: tagsToNoteWhereInput | tagsToNoteWhereInput[]
    id?: IntFilter<"tagsToNote"> | number
    noteId?: IntFilter<"tagsToNote"> | number
    tagId?: IntFilter<"tagsToNote"> | number
    note?: XOR<NotesScalarRelationFilter, notesWhereInput>
    tag?: XOR<TagScalarRelationFilter, tagWhereInput>
  }, "noteId_tagId">

  export type tagsToNoteOrderByWithAggregationInput = {
    id?: SortOrder
    noteId?: SortOrder
    tagId?: SortOrder
    _count?: tagsToNoteCountOrderByAggregateInput
    _avg?: tagsToNoteAvgOrderByAggregateInput
    _max?: tagsToNoteMaxOrderByAggregateInput
    _min?: tagsToNoteMinOrderByAggregateInput
    _sum?: tagsToNoteSumOrderByAggregateInput
  }

  export type tagsToNoteScalarWhereWithAggregatesInput = {
    AND?: tagsToNoteScalarWhereWithAggregatesInput | tagsToNoteScalarWhereWithAggregatesInput[]
    OR?: tagsToNoteScalarWhereWithAggregatesInput[]
    NOT?: tagsToNoteScalarWhereWithAggregatesInput | tagsToNoteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tagsToNote"> | number
    noteId?: IntWithAggregatesFilter<"tagsToNote"> | number
    tagId?: IntWithAggregatesFilter<"tagsToNote"> | number
  }

  export type noteReferenceWhereInput = {
    AND?: noteReferenceWhereInput | noteReferenceWhereInput[]
    OR?: noteReferenceWhereInput[]
    NOT?: noteReferenceWhereInput | noteReferenceWhereInput[]
    id?: IntFilter<"noteReference"> | number
    fromNoteId?: IntFilter<"noteReference"> | number
    toNoteId?: IntFilter<"noteReference"> | number
    createdAt?: DateTimeFilter<"noteReference"> | Date | string
    fromNote?: XOR<NotesScalarRelationFilter, notesWhereInput>
    toNote?: XOR<NotesScalarRelationFilter, notesWhereInput>
  }

  export type noteReferenceOrderByWithRelationInput = {
    id?: SortOrder
    fromNoteId?: SortOrder
    toNoteId?: SortOrder
    createdAt?: SortOrder
    fromNote?: notesOrderByWithRelationInput
    toNote?: notesOrderByWithRelationInput
  }

  export type noteReferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    fromNoteId_toNoteId?: noteReferenceFromNoteIdToNoteIdCompoundUniqueInput
    AND?: noteReferenceWhereInput | noteReferenceWhereInput[]
    OR?: noteReferenceWhereInput[]
    NOT?: noteReferenceWhereInput | noteReferenceWhereInput[]
    fromNoteId?: IntFilter<"noteReference"> | number
    toNoteId?: IntFilter<"noteReference"> | number
    createdAt?: DateTimeFilter<"noteReference"> | Date | string
    fromNote?: XOR<NotesScalarRelationFilter, notesWhereInput>
    toNote?: XOR<NotesScalarRelationFilter, notesWhereInput>
  }, "id" | "fromNoteId_toNoteId">

  export type noteReferenceOrderByWithAggregationInput = {
    id?: SortOrder
    fromNoteId?: SortOrder
    toNoteId?: SortOrder
    createdAt?: SortOrder
    _count?: noteReferenceCountOrderByAggregateInput
    _avg?: noteReferenceAvgOrderByAggregateInput
    _max?: noteReferenceMaxOrderByAggregateInput
    _min?: noteReferenceMinOrderByAggregateInput
    _sum?: noteReferenceSumOrderByAggregateInput
  }

  export type noteReferenceScalarWhereWithAggregatesInput = {
    AND?: noteReferenceScalarWhereWithAggregatesInput | noteReferenceScalarWhereWithAggregatesInput[]
    OR?: noteReferenceScalarWhereWithAggregatesInput[]
    NOT?: noteReferenceScalarWhereWithAggregatesInput | noteReferenceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"noteReference"> | number
    fromNoteId?: IntWithAggregatesFilter<"noteReference"> | number
    toNoteId?: IntWithAggregatesFilter<"noteReference"> | number
    createdAt?: DateTimeWithAggregatesFilter<"noteReference"> | Date | string
  }

  export type followsWhereInput = {
    AND?: followsWhereInput | followsWhereInput[]
    OR?: followsWhereInput[]
    NOT?: followsWhereInput | followsWhereInput[]
    id?: IntFilter<"follows"> | number
    siteName?: StringNullableFilter<"follows"> | string | null
    siteUrl?: StringFilter<"follows"> | string
    siteAvatar?: StringNullableFilter<"follows"> | string | null
    description?: StringNullableFilter<"follows"> | string | null
    createdAt?: DateTimeFilter<"follows"> | Date | string
    updatedAt?: DateTimeFilter<"follows"> | Date | string
    followType?: StringFilter<"follows"> | string
    accountId?: IntFilter<"follows"> | number
    account?: XOR<AccountsScalarRelationFilter, accountsWhereInput>
  }

  export type followsOrderByWithRelationInput = {
    id?: SortOrder
    siteName?: SortOrderInput | SortOrder
    siteUrl?: SortOrder
    siteAvatar?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    followType?: SortOrder
    accountId?: SortOrder
    account?: accountsOrderByWithRelationInput
  }

  export type followsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: followsWhereInput | followsWhereInput[]
    OR?: followsWhereInput[]
    NOT?: followsWhereInput | followsWhereInput[]
    siteName?: StringNullableFilter<"follows"> | string | null
    siteUrl?: StringFilter<"follows"> | string
    siteAvatar?: StringNullableFilter<"follows"> | string | null
    description?: StringNullableFilter<"follows"> | string | null
    createdAt?: DateTimeFilter<"follows"> | Date | string
    updatedAt?: DateTimeFilter<"follows"> | Date | string
    followType?: StringFilter<"follows"> | string
    accountId?: IntFilter<"follows"> | number
    account?: XOR<AccountsScalarRelationFilter, accountsWhereInput>
  }, "id">

  export type followsOrderByWithAggregationInput = {
    id?: SortOrder
    siteName?: SortOrderInput | SortOrder
    siteUrl?: SortOrder
    siteAvatar?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    followType?: SortOrder
    accountId?: SortOrder
    _count?: followsCountOrderByAggregateInput
    _avg?: followsAvgOrderByAggregateInput
    _max?: followsMaxOrderByAggregateInput
    _min?: followsMinOrderByAggregateInput
    _sum?: followsSumOrderByAggregateInput
  }

  export type followsScalarWhereWithAggregatesInput = {
    AND?: followsScalarWhereWithAggregatesInput | followsScalarWhereWithAggregatesInput[]
    OR?: followsScalarWhereWithAggregatesInput[]
    NOT?: followsScalarWhereWithAggregatesInput | followsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"follows"> | number
    siteName?: StringNullableWithAggregatesFilter<"follows"> | string | null
    siteUrl?: StringWithAggregatesFilter<"follows"> | string
    siteAvatar?: StringNullableWithAggregatesFilter<"follows"> | string | null
    description?: StringNullableWithAggregatesFilter<"follows"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"follows"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"follows"> | Date | string
    followType?: StringWithAggregatesFilter<"follows"> | string
    accountId?: IntWithAggregatesFilter<"follows"> | number
  }

  export type notificationsWhereInput = {
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    id?: IntFilter<"notifications"> | number
    type?: StringFilter<"notifications"> | string
    title?: StringFilter<"notifications"> | string
    content?: StringFilter<"notifications"> | string
    metadata?: JsonNullableFilter<"notifications">
    isRead?: BoolFilter<"notifications"> | boolean
    accountId?: IntFilter<"notifications"> | number
    createdAt?: DateTimeFilter<"notifications"> | Date | string
    updatedAt?: DateTimeFilter<"notifications"> | Date | string
    account?: XOR<AccountsScalarRelationFilter, accountsWhereInput>
  }

  export type notificationsOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    metadata?: SortOrderInput | SortOrder
    isRead?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: accountsOrderByWithRelationInput
  }

  export type notificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    type?: StringFilter<"notifications"> | string
    title?: StringFilter<"notifications"> | string
    content?: StringFilter<"notifications"> | string
    metadata?: JsonNullableFilter<"notifications">
    isRead?: BoolFilter<"notifications"> | boolean
    accountId?: IntFilter<"notifications"> | number
    createdAt?: DateTimeFilter<"notifications"> | Date | string
    updatedAt?: DateTimeFilter<"notifications"> | Date | string
    account?: XOR<AccountsScalarRelationFilter, accountsWhereInput>
  }, "id">

  export type notificationsOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    metadata?: SortOrderInput | SortOrder
    isRead?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: notificationsCountOrderByAggregateInput
    _avg?: notificationsAvgOrderByAggregateInput
    _max?: notificationsMaxOrderByAggregateInput
    _min?: notificationsMinOrderByAggregateInput
    _sum?: notificationsSumOrderByAggregateInput
  }

  export type notificationsScalarWhereWithAggregatesInput = {
    AND?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    OR?: notificationsScalarWhereWithAggregatesInput[]
    NOT?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"notifications"> | number
    type?: StringWithAggregatesFilter<"notifications"> | string
    title?: StringWithAggregatesFilter<"notifications"> | string
    content?: StringWithAggregatesFilter<"notifications"> | string
    metadata?: JsonNullableWithAggregatesFilter<"notifications">
    isRead?: BoolWithAggregatesFilter<"notifications"> | boolean
    accountId?: IntWithAggregatesFilter<"notifications"> | number
    createdAt?: DateTimeWithAggregatesFilter<"notifications"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"notifications"> | Date | string
  }

  export type cacheWhereInput = {
    AND?: cacheWhereInput | cacheWhereInput[]
    OR?: cacheWhereInput[]
    NOT?: cacheWhereInput | cacheWhereInput[]
    id?: IntFilter<"cache"> | number
    key?: StringFilter<"cache"> | string
    value?: JsonFilter<"cache">
    createdAt?: DateTimeFilter<"cache"> | Date | string
    updatedAt?: DateTimeFilter<"cache"> | Date | string
  }

  export type cacheOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cacheWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    key?: string
    AND?: cacheWhereInput | cacheWhereInput[]
    OR?: cacheWhereInput[]
    NOT?: cacheWhereInput | cacheWhereInput[]
    value?: JsonFilter<"cache">
    createdAt?: DateTimeFilter<"cache"> | Date | string
    updatedAt?: DateTimeFilter<"cache"> | Date | string
  }, "id" | "key">

  export type cacheOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: cacheCountOrderByAggregateInput
    _avg?: cacheAvgOrderByAggregateInput
    _max?: cacheMaxOrderByAggregateInput
    _min?: cacheMinOrderByAggregateInput
    _sum?: cacheSumOrderByAggregateInput
  }

  export type cacheScalarWhereWithAggregatesInput = {
    AND?: cacheScalarWhereWithAggregatesInput | cacheScalarWhereWithAggregatesInput[]
    OR?: cacheScalarWhereWithAggregatesInput[]
    NOT?: cacheScalarWhereWithAggregatesInput | cacheScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"cache"> | number
    key?: StringWithAggregatesFilter<"cache"> | string
    value?: JsonWithAggregatesFilter<"cache">
    createdAt?: DateTimeWithAggregatesFilter<"cache"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"cache"> | Date | string
  }

  export type pluginWhereInput = {
    AND?: pluginWhereInput | pluginWhereInput[]
    OR?: pluginWhereInput[]
    NOT?: pluginWhereInput | pluginWhereInput[]
    id?: IntFilter<"plugin"> | number
    metadata?: JsonFilter<"plugin">
    path?: StringFilter<"plugin"> | string
    isUse?: BoolFilter<"plugin"> | boolean
    isDev?: BoolFilter<"plugin"> | boolean
    createdAt?: DateTimeFilter<"plugin"> | Date | string
    updatedAt?: DateTimeFilter<"plugin"> | Date | string
  }

  export type pluginOrderByWithRelationInput = {
    id?: SortOrder
    metadata?: SortOrder
    path?: SortOrder
    isUse?: SortOrder
    isDev?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pluginWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pluginWhereInput | pluginWhereInput[]
    OR?: pluginWhereInput[]
    NOT?: pluginWhereInput | pluginWhereInput[]
    metadata?: JsonFilter<"plugin">
    path?: StringFilter<"plugin"> | string
    isUse?: BoolFilter<"plugin"> | boolean
    isDev?: BoolFilter<"plugin"> | boolean
    createdAt?: DateTimeFilter<"plugin"> | Date | string
    updatedAt?: DateTimeFilter<"plugin"> | Date | string
  }, "id">

  export type pluginOrderByWithAggregationInput = {
    id?: SortOrder
    metadata?: SortOrder
    path?: SortOrder
    isUse?: SortOrder
    isDev?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: pluginCountOrderByAggregateInput
    _avg?: pluginAvgOrderByAggregateInput
    _max?: pluginMaxOrderByAggregateInput
    _min?: pluginMinOrderByAggregateInput
    _sum?: pluginSumOrderByAggregateInput
  }

  export type pluginScalarWhereWithAggregatesInput = {
    AND?: pluginScalarWhereWithAggregatesInput | pluginScalarWhereWithAggregatesInput[]
    OR?: pluginScalarWhereWithAggregatesInput[]
    NOT?: pluginScalarWhereWithAggregatesInput | pluginScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"plugin"> | number
    metadata?: JsonWithAggregatesFilter<"plugin">
    path?: StringWithAggregatesFilter<"plugin"> | string
    isUse?: BoolWithAggregatesFilter<"plugin"> | boolean
    isDev?: BoolWithAggregatesFilter<"plugin"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"plugin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"plugin"> | Date | string
  }

  export type conversationWhereInput = {
    AND?: conversationWhereInput | conversationWhereInput[]
    OR?: conversationWhereInput[]
    NOT?: conversationWhereInput | conversationWhereInput[]
    id?: IntFilter<"conversation"> | number
    title?: StringFilter<"conversation"> | string
    isShare?: BoolFilter<"conversation"> | boolean
    accountId?: IntFilter<"conversation"> | number
    createdAt?: DateTimeFilter<"conversation"> | Date | string
    updatedAt?: DateTimeFilter<"conversation"> | Date | string
    messages?: MessageListRelationFilter
    account?: XOR<AccountsScalarRelationFilter, accountsWhereInput>
  }

  export type conversationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    isShare?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    messages?: messageOrderByRelationAggregateInput
    account?: accountsOrderByWithRelationInput
  }

  export type conversationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: conversationWhereInput | conversationWhereInput[]
    OR?: conversationWhereInput[]
    NOT?: conversationWhereInput | conversationWhereInput[]
    title?: StringFilter<"conversation"> | string
    isShare?: BoolFilter<"conversation"> | boolean
    accountId?: IntFilter<"conversation"> | number
    createdAt?: DateTimeFilter<"conversation"> | Date | string
    updatedAt?: DateTimeFilter<"conversation"> | Date | string
    messages?: MessageListRelationFilter
    account?: XOR<AccountsScalarRelationFilter, accountsWhereInput>
  }, "id">

  export type conversationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    isShare?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: conversationCountOrderByAggregateInput
    _avg?: conversationAvgOrderByAggregateInput
    _max?: conversationMaxOrderByAggregateInput
    _min?: conversationMinOrderByAggregateInput
    _sum?: conversationSumOrderByAggregateInput
  }

  export type conversationScalarWhereWithAggregatesInput = {
    AND?: conversationScalarWhereWithAggregatesInput | conversationScalarWhereWithAggregatesInput[]
    OR?: conversationScalarWhereWithAggregatesInput[]
    NOT?: conversationScalarWhereWithAggregatesInput | conversationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"conversation"> | number
    title?: StringWithAggregatesFilter<"conversation"> | string
    isShare?: BoolWithAggregatesFilter<"conversation"> | boolean
    accountId?: IntWithAggregatesFilter<"conversation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"conversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"conversation"> | Date | string
  }

  export type messageWhereInput = {
    AND?: messageWhereInput | messageWhereInput[]
    OR?: messageWhereInput[]
    NOT?: messageWhereInput | messageWhereInput[]
    id?: IntFilter<"message"> | number
    content?: StringFilter<"message"> | string
    role?: StringFilter<"message"> | string
    conversationId?: IntFilter<"message"> | number
    createdAt?: DateTimeFilter<"message"> | Date | string
    updatedAt?: DateTimeFilter<"message"> | Date | string
    metadata?: JsonNullableFilter<"message">
    conversation?: XOR<ConversationScalarRelationFilter, conversationWhereInput>
  }

  export type messageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    role?: SortOrder
    conversationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    conversation?: conversationOrderByWithRelationInput
  }

  export type messageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: messageWhereInput | messageWhereInput[]
    OR?: messageWhereInput[]
    NOT?: messageWhereInput | messageWhereInput[]
    content?: StringFilter<"message"> | string
    role?: StringFilter<"message"> | string
    conversationId?: IntFilter<"message"> | number
    createdAt?: DateTimeFilter<"message"> | Date | string
    updatedAt?: DateTimeFilter<"message"> | Date | string
    metadata?: JsonNullableFilter<"message">
    conversation?: XOR<ConversationScalarRelationFilter, conversationWhereInput>
  }, "id">

  export type messageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    role?: SortOrder
    conversationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: messageCountOrderByAggregateInput
    _avg?: messageAvgOrderByAggregateInput
    _max?: messageMaxOrderByAggregateInput
    _min?: messageMinOrderByAggregateInput
    _sum?: messageSumOrderByAggregateInput
  }

  export type messageScalarWhereWithAggregatesInput = {
    AND?: messageScalarWhereWithAggregatesInput | messageScalarWhereWithAggregatesInput[]
    OR?: messageScalarWhereWithAggregatesInput[]
    NOT?: messageScalarWhereWithAggregatesInput | messageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"message"> | number
    content?: StringWithAggregatesFilter<"message"> | string
    role?: StringWithAggregatesFilter<"message"> | string
    conversationId?: IntWithAggregatesFilter<"message"> | number
    createdAt?: DateTimeWithAggregatesFilter<"message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"message"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"message">
  }

  export type noteHistoryWhereInput = {
    AND?: noteHistoryWhereInput | noteHistoryWhereInput[]
    OR?: noteHistoryWhereInput[]
    NOT?: noteHistoryWhereInput | noteHistoryWhereInput[]
    id?: IntFilter<"noteHistory"> | number
    noteId?: IntFilter<"noteHistory"> | number
    content?: StringFilter<"noteHistory"> | string
    metadata?: JsonNullableFilter<"noteHistory">
    version?: IntFilter<"noteHistory"> | number
    accountId?: IntNullableFilter<"noteHistory"> | number | null
    createdAt?: DateTimeFilter<"noteHistory"> | Date | string
    note?: XOR<NotesScalarRelationFilter, notesWhereInput>
  }

  export type noteHistoryOrderByWithRelationInput = {
    id?: SortOrder
    noteId?: SortOrder
    content?: SortOrder
    metadata?: SortOrderInput | SortOrder
    version?: SortOrder
    accountId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    note?: notesOrderByWithRelationInput
  }

  export type noteHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: noteHistoryWhereInput | noteHistoryWhereInput[]
    OR?: noteHistoryWhereInput[]
    NOT?: noteHistoryWhereInput | noteHistoryWhereInput[]
    noteId?: IntFilter<"noteHistory"> | number
    content?: StringFilter<"noteHistory"> | string
    metadata?: JsonNullableFilter<"noteHistory">
    version?: IntFilter<"noteHistory"> | number
    accountId?: IntNullableFilter<"noteHistory"> | number | null
    createdAt?: DateTimeFilter<"noteHistory"> | Date | string
    note?: XOR<NotesScalarRelationFilter, notesWhereInput>
  }, "id">

  export type noteHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    noteId?: SortOrder
    content?: SortOrder
    metadata?: SortOrderInput | SortOrder
    version?: SortOrder
    accountId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: noteHistoryCountOrderByAggregateInput
    _avg?: noteHistoryAvgOrderByAggregateInput
    _max?: noteHistoryMaxOrderByAggregateInput
    _min?: noteHistoryMinOrderByAggregateInput
    _sum?: noteHistorySumOrderByAggregateInput
  }

  export type noteHistoryScalarWhereWithAggregatesInput = {
    AND?: noteHistoryScalarWhereWithAggregatesInput | noteHistoryScalarWhereWithAggregatesInput[]
    OR?: noteHistoryScalarWhereWithAggregatesInput[]
    NOT?: noteHistoryScalarWhereWithAggregatesInput | noteHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"noteHistory"> | number
    noteId?: IntWithAggregatesFilter<"noteHistory"> | number
    content?: StringWithAggregatesFilter<"noteHistory"> | string
    metadata?: JsonNullableWithAggregatesFilter<"noteHistory">
    version?: IntWithAggregatesFilter<"noteHistory"> | number
    accountId?: IntNullableWithAggregatesFilter<"noteHistory"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"noteHistory"> | Date | string
  }

  export type noteInternalShareWhereInput = {
    AND?: noteInternalShareWhereInput | noteInternalShareWhereInput[]
    OR?: noteInternalShareWhereInput[]
    NOT?: noteInternalShareWhereInput | noteInternalShareWhereInput[]
    id?: IntFilter<"noteInternalShare"> | number
    noteId?: IntFilter<"noteInternalShare"> | number
    accountId?: IntFilter<"noteInternalShare"> | number
    canEdit?: BoolFilter<"noteInternalShare"> | boolean
    createdAt?: DateTimeFilter<"noteInternalShare"> | Date | string
    updatedAt?: DateTimeFilter<"noteInternalShare"> | Date | string
    note?: XOR<NotesScalarRelationFilter, notesWhereInput>
    account?: XOR<AccountsScalarRelationFilter, accountsWhereInput>
  }

  export type noteInternalShareOrderByWithRelationInput = {
    id?: SortOrder
    noteId?: SortOrder
    accountId?: SortOrder
    canEdit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    note?: notesOrderByWithRelationInput
    account?: accountsOrderByWithRelationInput
  }

  export type noteInternalShareWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    noteId_accountId?: noteInternalShareNoteIdAccountIdCompoundUniqueInput
    AND?: noteInternalShareWhereInput | noteInternalShareWhereInput[]
    OR?: noteInternalShareWhereInput[]
    NOT?: noteInternalShareWhereInput | noteInternalShareWhereInput[]
    noteId?: IntFilter<"noteInternalShare"> | number
    accountId?: IntFilter<"noteInternalShare"> | number
    canEdit?: BoolFilter<"noteInternalShare"> | boolean
    createdAt?: DateTimeFilter<"noteInternalShare"> | Date | string
    updatedAt?: DateTimeFilter<"noteInternalShare"> | Date | string
    note?: XOR<NotesScalarRelationFilter, notesWhereInput>
    account?: XOR<AccountsScalarRelationFilter, accountsWhereInput>
  }, "id" | "noteId_accountId">

  export type noteInternalShareOrderByWithAggregationInput = {
    id?: SortOrder
    noteId?: SortOrder
    accountId?: SortOrder
    canEdit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: noteInternalShareCountOrderByAggregateInput
    _avg?: noteInternalShareAvgOrderByAggregateInput
    _max?: noteInternalShareMaxOrderByAggregateInput
    _min?: noteInternalShareMinOrderByAggregateInput
    _sum?: noteInternalShareSumOrderByAggregateInput
  }

  export type noteInternalShareScalarWhereWithAggregatesInput = {
    AND?: noteInternalShareScalarWhereWithAggregatesInput | noteInternalShareScalarWhereWithAggregatesInput[]
    OR?: noteInternalShareScalarWhereWithAggregatesInput[]
    NOT?: noteInternalShareScalarWhereWithAggregatesInput | noteInternalShareScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"noteInternalShare"> | number
    noteId?: IntWithAggregatesFilter<"noteInternalShare"> | number
    accountId?: IntWithAggregatesFilter<"noteInternalShare"> | number
    canEdit?: BoolWithAggregatesFilter<"noteInternalShare"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"noteInternalShare"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"noteInternalShare"> | Date | string
  }

  export type sessionWhereInput = {
    AND?: sessionWhereInput | sessionWhereInput[]
    OR?: sessionWhereInput[]
    NOT?: sessionWhereInput | sessionWhereInput[]
    id?: StringFilter<"session"> | string
    sid?: StringFilter<"session"> | string
    data?: StringFilter<"session"> | string
    expiresAt?: DateTimeFilter<"session"> | Date | string
    createdAt?: DateTimeFilter<"session"> | Date | string
    updatedAt?: DateTimeFilter<"session"> | Date | string
  }

  export type sessionOrderByWithRelationInput = {
    id?: SortOrder
    sid?: SortOrder
    data?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type sessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sid?: string
    AND?: sessionWhereInput | sessionWhereInput[]
    OR?: sessionWhereInput[]
    NOT?: sessionWhereInput | sessionWhereInput[]
    data?: StringFilter<"session"> | string
    expiresAt?: DateTimeFilter<"session"> | Date | string
    createdAt?: DateTimeFilter<"session"> | Date | string
    updatedAt?: DateTimeFilter<"session"> | Date | string
  }, "id" | "sid">

  export type sessionOrderByWithAggregationInput = {
    id?: SortOrder
    sid?: SortOrder
    data?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: sessionCountOrderByAggregateInput
    _max?: sessionMaxOrderByAggregateInput
    _min?: sessionMinOrderByAggregateInput
  }

  export type sessionScalarWhereWithAggregatesInput = {
    AND?: sessionScalarWhereWithAggregatesInput | sessionScalarWhereWithAggregatesInput[]
    OR?: sessionScalarWhereWithAggregatesInput[]
    NOT?: sessionScalarWhereWithAggregatesInput | sessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"session"> | string
    sid?: StringWithAggregatesFilter<"session"> | string
    data?: StringWithAggregatesFilter<"session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"session"> | Date | string
  }

  export type aiProvidersWhereInput = {
    AND?: aiProvidersWhereInput | aiProvidersWhereInput[]
    OR?: aiProvidersWhereInput[]
    NOT?: aiProvidersWhereInput | aiProvidersWhereInput[]
    id?: IntFilter<"aiProviders"> | number
    title?: StringFilter<"aiProviders"> | string
    provider?: StringFilter<"aiProviders"> | string
    baseURL?: StringNullableFilter<"aiProviders"> | string | null
    apiKey?: StringNullableFilter<"aiProviders"> | string | null
    config?: JsonNullableFilter<"aiProviders">
    sortOrder?: IntFilter<"aiProviders"> | number
    createdAt?: DateTimeFilter<"aiProviders"> | Date | string
    updatedAt?: DateTimeFilter<"aiProviders"> | Date | string
    models?: AiModelsListRelationFilter
  }

  export type aiProvidersOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    provider?: SortOrder
    baseURL?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    config?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    models?: aiModelsOrderByRelationAggregateInput
  }

  export type aiProvidersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: aiProvidersWhereInput | aiProvidersWhereInput[]
    OR?: aiProvidersWhereInput[]
    NOT?: aiProvidersWhereInput | aiProvidersWhereInput[]
    title?: StringFilter<"aiProviders"> | string
    provider?: StringFilter<"aiProviders"> | string
    baseURL?: StringNullableFilter<"aiProviders"> | string | null
    apiKey?: StringNullableFilter<"aiProviders"> | string | null
    config?: JsonNullableFilter<"aiProviders">
    sortOrder?: IntFilter<"aiProviders"> | number
    createdAt?: DateTimeFilter<"aiProviders"> | Date | string
    updatedAt?: DateTimeFilter<"aiProviders"> | Date | string
    models?: AiModelsListRelationFilter
  }, "id">

  export type aiProvidersOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    provider?: SortOrder
    baseURL?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    config?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: aiProvidersCountOrderByAggregateInput
    _avg?: aiProvidersAvgOrderByAggregateInput
    _max?: aiProvidersMaxOrderByAggregateInput
    _min?: aiProvidersMinOrderByAggregateInput
    _sum?: aiProvidersSumOrderByAggregateInput
  }

  export type aiProvidersScalarWhereWithAggregatesInput = {
    AND?: aiProvidersScalarWhereWithAggregatesInput | aiProvidersScalarWhereWithAggregatesInput[]
    OR?: aiProvidersScalarWhereWithAggregatesInput[]
    NOT?: aiProvidersScalarWhereWithAggregatesInput | aiProvidersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"aiProviders"> | number
    title?: StringWithAggregatesFilter<"aiProviders"> | string
    provider?: StringWithAggregatesFilter<"aiProviders"> | string
    baseURL?: StringNullableWithAggregatesFilter<"aiProviders"> | string | null
    apiKey?: StringNullableWithAggregatesFilter<"aiProviders"> | string | null
    config?: JsonNullableWithAggregatesFilter<"aiProviders">
    sortOrder?: IntWithAggregatesFilter<"aiProviders"> | number
    createdAt?: DateTimeWithAggregatesFilter<"aiProviders"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"aiProviders"> | Date | string
  }

  export type aiModelsWhereInput = {
    AND?: aiModelsWhereInput | aiModelsWhereInput[]
    OR?: aiModelsWhereInput[]
    NOT?: aiModelsWhereInput | aiModelsWhereInput[]
    id?: IntFilter<"aiModels"> | number
    providerId?: IntFilter<"aiModels"> | number
    title?: StringFilter<"aiModels"> | string
    modelKey?: StringFilter<"aiModels"> | string
    capabilities?: JsonFilter<"aiModels">
    config?: JsonNullableFilter<"aiModels">
    sortOrder?: IntFilter<"aiModels"> | number
    createdAt?: DateTimeFilter<"aiModels"> | Date | string
    updatedAt?: DateTimeFilter<"aiModels"> | Date | string
    provider?: XOR<AiProvidersScalarRelationFilter, aiProvidersWhereInput>
  }

  export type aiModelsOrderByWithRelationInput = {
    id?: SortOrder
    providerId?: SortOrder
    title?: SortOrder
    modelKey?: SortOrder
    capabilities?: SortOrder
    config?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider?: aiProvidersOrderByWithRelationInput
  }

  export type aiModelsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: aiModelsWhereInput | aiModelsWhereInput[]
    OR?: aiModelsWhereInput[]
    NOT?: aiModelsWhereInput | aiModelsWhereInput[]
    providerId?: IntFilter<"aiModels"> | number
    title?: StringFilter<"aiModels"> | string
    modelKey?: StringFilter<"aiModels"> | string
    capabilities?: JsonFilter<"aiModels">
    config?: JsonNullableFilter<"aiModels">
    sortOrder?: IntFilter<"aiModels"> | number
    createdAt?: DateTimeFilter<"aiModels"> | Date | string
    updatedAt?: DateTimeFilter<"aiModels"> | Date | string
    provider?: XOR<AiProvidersScalarRelationFilter, aiProvidersWhereInput>
  }, "id">

  export type aiModelsOrderByWithAggregationInput = {
    id?: SortOrder
    providerId?: SortOrder
    title?: SortOrder
    modelKey?: SortOrder
    capabilities?: SortOrder
    config?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: aiModelsCountOrderByAggregateInput
    _avg?: aiModelsAvgOrderByAggregateInput
    _max?: aiModelsMaxOrderByAggregateInput
    _min?: aiModelsMinOrderByAggregateInput
    _sum?: aiModelsSumOrderByAggregateInput
  }

  export type aiModelsScalarWhereWithAggregatesInput = {
    AND?: aiModelsScalarWhereWithAggregatesInput | aiModelsScalarWhereWithAggregatesInput[]
    OR?: aiModelsScalarWhereWithAggregatesInput[]
    NOT?: aiModelsScalarWhereWithAggregatesInput | aiModelsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"aiModels"> | number
    providerId?: IntWithAggregatesFilter<"aiModels"> | number
    title?: StringWithAggregatesFilter<"aiModels"> | string
    modelKey?: StringWithAggregatesFilter<"aiModels"> | string
    capabilities?: JsonWithAggregatesFilter<"aiModels">
    config?: JsonNullableWithAggregatesFilter<"aiModels">
    sortOrder?: IntWithAggregatesFilter<"aiModels"> | number
    createdAt?: DateTimeWithAggregatesFilter<"aiModels"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"aiModels"> | Date | string
  }

  export type aiScheduledTaskWhereInput = {
    AND?: aiScheduledTaskWhereInput | aiScheduledTaskWhereInput[]
    OR?: aiScheduledTaskWhereInput[]
    NOT?: aiScheduledTaskWhereInput | aiScheduledTaskWhereInput[]
    id?: IntFilter<"aiScheduledTask"> | number
    name?: StringFilter<"aiScheduledTask"> | string
    prompt?: StringFilter<"aiScheduledTask"> | string
    schedule?: StringFilter<"aiScheduledTask"> | string
    isEnabled?: BoolFilter<"aiScheduledTask"> | boolean
    lastRun?: DateTimeNullableFilter<"aiScheduledTask"> | Date | string | null
    lastResult?: JsonNullableFilter<"aiScheduledTask">
    accountId?: IntFilter<"aiScheduledTask"> | number
    createdAt?: DateTimeFilter<"aiScheduledTask"> | Date | string
    updatedAt?: DateTimeFilter<"aiScheduledTask"> | Date | string
    account?: XOR<AccountsScalarRelationFilter, accountsWhereInput>
  }

  export type aiScheduledTaskOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    prompt?: SortOrder
    schedule?: SortOrder
    isEnabled?: SortOrder
    lastRun?: SortOrderInput | SortOrder
    lastResult?: SortOrderInput | SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: accountsOrderByWithRelationInput
  }

  export type aiScheduledTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: aiScheduledTaskWhereInput | aiScheduledTaskWhereInput[]
    OR?: aiScheduledTaskWhereInput[]
    NOT?: aiScheduledTaskWhereInput | aiScheduledTaskWhereInput[]
    name?: StringFilter<"aiScheduledTask"> | string
    prompt?: StringFilter<"aiScheduledTask"> | string
    schedule?: StringFilter<"aiScheduledTask"> | string
    isEnabled?: BoolFilter<"aiScheduledTask"> | boolean
    lastRun?: DateTimeNullableFilter<"aiScheduledTask"> | Date | string | null
    lastResult?: JsonNullableFilter<"aiScheduledTask">
    accountId?: IntFilter<"aiScheduledTask"> | number
    createdAt?: DateTimeFilter<"aiScheduledTask"> | Date | string
    updatedAt?: DateTimeFilter<"aiScheduledTask"> | Date | string
    account?: XOR<AccountsScalarRelationFilter, accountsWhereInput>
  }, "id">

  export type aiScheduledTaskOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    prompt?: SortOrder
    schedule?: SortOrder
    isEnabled?: SortOrder
    lastRun?: SortOrderInput | SortOrder
    lastResult?: SortOrderInput | SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: aiScheduledTaskCountOrderByAggregateInput
    _avg?: aiScheduledTaskAvgOrderByAggregateInput
    _max?: aiScheduledTaskMaxOrderByAggregateInput
    _min?: aiScheduledTaskMinOrderByAggregateInput
    _sum?: aiScheduledTaskSumOrderByAggregateInput
  }

  export type aiScheduledTaskScalarWhereWithAggregatesInput = {
    AND?: aiScheduledTaskScalarWhereWithAggregatesInput | aiScheduledTaskScalarWhereWithAggregatesInput[]
    OR?: aiScheduledTaskScalarWhereWithAggregatesInput[]
    NOT?: aiScheduledTaskScalarWhereWithAggregatesInput | aiScheduledTaskScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"aiScheduledTask"> | number
    name?: StringWithAggregatesFilter<"aiScheduledTask"> | string
    prompt?: StringWithAggregatesFilter<"aiScheduledTask"> | string
    schedule?: StringWithAggregatesFilter<"aiScheduledTask"> | string
    isEnabled?: BoolWithAggregatesFilter<"aiScheduledTask"> | boolean
    lastRun?: DateTimeNullableWithAggregatesFilter<"aiScheduledTask"> | Date | string | null
    lastResult?: JsonNullableWithAggregatesFilter<"aiScheduledTask">
    accountId?: IntWithAggregatesFilter<"aiScheduledTask"> | number
    createdAt?: DateTimeWithAggregatesFilter<"aiScheduledTask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"aiScheduledTask"> | Date | string
  }

  export type mcpServersWhereInput = {
    AND?: mcpServersWhereInput | mcpServersWhereInput[]
    OR?: mcpServersWhereInput[]
    NOT?: mcpServersWhereInput | mcpServersWhereInput[]
    id?: IntFilter<"mcpServers"> | number
    name?: StringFilter<"mcpServers"> | string
    description?: StringNullableFilter<"mcpServers"> | string | null
    type?: StringFilter<"mcpServers"> | string
    command?: StringNullableFilter<"mcpServers"> | string | null
    args?: JsonNullableFilter<"mcpServers">
    url?: StringNullableFilter<"mcpServers"> | string | null
    env?: JsonNullableFilter<"mcpServers">
    headers?: JsonNullableFilter<"mcpServers">
    isEnabled?: BoolFilter<"mcpServers"> | boolean
    createdAt?: DateTimeFilter<"mcpServers"> | Date | string
    updatedAt?: DateTimeFilter<"mcpServers"> | Date | string
  }

  export type mcpServersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    command?: SortOrderInput | SortOrder
    args?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    env?: SortOrderInput | SortOrder
    headers?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type mcpServersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: mcpServersWhereInput | mcpServersWhereInput[]
    OR?: mcpServersWhereInput[]
    NOT?: mcpServersWhereInput | mcpServersWhereInput[]
    name?: StringFilter<"mcpServers"> | string
    description?: StringNullableFilter<"mcpServers"> | string | null
    type?: StringFilter<"mcpServers"> | string
    command?: StringNullableFilter<"mcpServers"> | string | null
    args?: JsonNullableFilter<"mcpServers">
    url?: StringNullableFilter<"mcpServers"> | string | null
    env?: JsonNullableFilter<"mcpServers">
    headers?: JsonNullableFilter<"mcpServers">
    isEnabled?: BoolFilter<"mcpServers"> | boolean
    createdAt?: DateTimeFilter<"mcpServers"> | Date | string
    updatedAt?: DateTimeFilter<"mcpServers"> | Date | string
  }, "id">

  export type mcpServersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    command?: SortOrderInput | SortOrder
    args?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    env?: SortOrderInput | SortOrder
    headers?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: mcpServersCountOrderByAggregateInput
    _avg?: mcpServersAvgOrderByAggregateInput
    _max?: mcpServersMaxOrderByAggregateInput
    _min?: mcpServersMinOrderByAggregateInput
    _sum?: mcpServersSumOrderByAggregateInput
  }

  export type mcpServersScalarWhereWithAggregatesInput = {
    AND?: mcpServersScalarWhereWithAggregatesInput | mcpServersScalarWhereWithAggregatesInput[]
    OR?: mcpServersScalarWhereWithAggregatesInput[]
    NOT?: mcpServersScalarWhereWithAggregatesInput | mcpServersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"mcpServers"> | number
    name?: StringWithAggregatesFilter<"mcpServers"> | string
    description?: StringNullableWithAggregatesFilter<"mcpServers"> | string | null
    type?: StringWithAggregatesFilter<"mcpServers"> | string
    command?: StringNullableWithAggregatesFilter<"mcpServers"> | string | null
    args?: JsonNullableWithAggregatesFilter<"mcpServers">
    url?: StringNullableWithAggregatesFilter<"mcpServers"> | string | null
    env?: JsonNullableWithAggregatesFilter<"mcpServers">
    headers?: JsonNullableWithAggregatesFilter<"mcpServers">
    isEnabled?: BoolWithAggregatesFilter<"mcpServers"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"mcpServers"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"mcpServers"> | Date | string
  }

  export type fontsWhereInput = {
    AND?: fontsWhereInput | fontsWhereInput[]
    OR?: fontsWhereInput[]
    NOT?: fontsWhereInput | fontsWhereInput[]
    id?: IntFilter<"fonts"> | number
    name?: StringFilter<"fonts"> | string
    displayName?: StringFilter<"fonts"> | string
    url?: StringNullableFilter<"fonts"> | string | null
    fileData?: BytesNullableFilter<"fonts"> | Bytes | null
    isLocal?: BoolFilter<"fonts"> | boolean
    isSystem?: BoolFilter<"fonts"> | boolean
    weights?: JsonFilter<"fonts">
    category?: StringFilter<"fonts"> | string
    sortOrder?: IntFilter<"fonts"> | number
    createdAt?: DateTimeFilter<"fonts"> | Date | string
    updatedAt?: DateTimeFilter<"fonts"> | Date | string
  }

  export type fontsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    url?: SortOrderInput | SortOrder
    fileData?: SortOrderInput | SortOrder
    isLocal?: SortOrder
    isSystem?: SortOrder
    weights?: SortOrder
    category?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type fontsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: fontsWhereInput | fontsWhereInput[]
    OR?: fontsWhereInput[]
    NOT?: fontsWhereInput | fontsWhereInput[]
    displayName?: StringFilter<"fonts"> | string
    url?: StringNullableFilter<"fonts"> | string | null
    fileData?: BytesNullableFilter<"fonts"> | Bytes | null
    isLocal?: BoolFilter<"fonts"> | boolean
    isSystem?: BoolFilter<"fonts"> | boolean
    weights?: JsonFilter<"fonts">
    category?: StringFilter<"fonts"> | string
    sortOrder?: IntFilter<"fonts"> | number
    createdAt?: DateTimeFilter<"fonts"> | Date | string
    updatedAt?: DateTimeFilter<"fonts"> | Date | string
  }, "id" | "name">

  export type fontsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    url?: SortOrderInput | SortOrder
    fileData?: SortOrderInput | SortOrder
    isLocal?: SortOrder
    isSystem?: SortOrder
    weights?: SortOrder
    category?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: fontsCountOrderByAggregateInput
    _avg?: fontsAvgOrderByAggregateInput
    _max?: fontsMaxOrderByAggregateInput
    _min?: fontsMinOrderByAggregateInput
    _sum?: fontsSumOrderByAggregateInput
  }

  export type fontsScalarWhereWithAggregatesInput = {
    AND?: fontsScalarWhereWithAggregatesInput | fontsScalarWhereWithAggregatesInput[]
    OR?: fontsScalarWhereWithAggregatesInput[]
    NOT?: fontsScalarWhereWithAggregatesInput | fontsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"fonts"> | number
    name?: StringWithAggregatesFilter<"fonts"> | string
    displayName?: StringWithAggregatesFilter<"fonts"> | string
    url?: StringNullableWithAggregatesFilter<"fonts"> | string | null
    fileData?: BytesNullableWithAggregatesFilter<"fonts"> | Bytes | null
    isLocal?: BoolWithAggregatesFilter<"fonts"> | boolean
    isSystem?: BoolWithAggregatesFilter<"fonts"> | boolean
    weights?: JsonWithAggregatesFilter<"fonts">
    category?: StringWithAggregatesFilter<"fonts"> | string
    sortOrder?: IntWithAggregatesFilter<"fonts"> | number
    createdAt?: DateTimeWithAggregatesFilter<"fonts"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"fonts"> | Date | string
  }

  export type accountsCreateInput = {
    name?: string
    nickname?: string
    password?: string
    image?: string
    apiToken?: string
    description?: string
    note?: number
    role?: string
    loginType?: string
    linkAccountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: notesCreateNestedManyWithoutAccountInput
    configs?: configCreateNestedManyWithoutUserInput
    tags?: tagCreateNestedManyWithoutAccountInput
    comments?: commentsCreateNestedManyWithoutAccountInput
    attachments?: attachmentsCreateNestedManyWithoutAccountInput
    follows?: followsCreateNestedManyWithoutAccountInput
    notifications?: notificationsCreateNestedManyWithoutAccountInput
    conversations?: conversationCreateNestedManyWithoutAccountInput
    sharedNotes?: noteInternalShareCreateNestedManyWithoutAccountInput
    aiScheduledTasks?: aiScheduledTaskCreateNestedManyWithoutAccountInput
  }

  export type accountsUncheckedCreateInput = {
    id?: number
    name?: string
    nickname?: string
    password?: string
    image?: string
    apiToken?: string
    description?: string
    note?: number
    role?: string
    loginType?: string
    linkAccountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: notesUncheckedCreateNestedManyWithoutAccountInput
    configs?: configUncheckedCreateNestedManyWithoutUserInput
    tags?: tagUncheckedCreateNestedManyWithoutAccountInput
    comments?: commentsUncheckedCreateNestedManyWithoutAccountInput
    attachments?: attachmentsUncheckedCreateNestedManyWithoutAccountInput
    follows?: followsUncheckedCreateNestedManyWithoutAccountInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutAccountInput
    conversations?: conversationUncheckedCreateNestedManyWithoutAccountInput
    sharedNotes?: noteInternalShareUncheckedCreateNestedManyWithoutAccountInput
    aiScheduledTasks?: aiScheduledTaskUncheckedCreateNestedManyWithoutAccountInput
  }

  export type accountsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    apiToken?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    note?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    loginType?: StringFieldUpdateOperationsInput | string
    linkAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: notesUpdateManyWithoutAccountNestedInput
    configs?: configUpdateManyWithoutUserNestedInput
    tags?: tagUpdateManyWithoutAccountNestedInput
    comments?: commentsUpdateManyWithoutAccountNestedInput
    attachments?: attachmentsUpdateManyWithoutAccountNestedInput
    follows?: followsUpdateManyWithoutAccountNestedInput
    notifications?: notificationsUpdateManyWithoutAccountNestedInput
    conversations?: conversationUpdateManyWithoutAccountNestedInput
    sharedNotes?: noteInternalShareUpdateManyWithoutAccountNestedInput
    aiScheduledTasks?: aiScheduledTaskUpdateManyWithoutAccountNestedInput
  }

  export type accountsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    apiToken?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    note?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    loginType?: StringFieldUpdateOperationsInput | string
    linkAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: notesUncheckedUpdateManyWithoutAccountNestedInput
    configs?: configUncheckedUpdateManyWithoutUserNestedInput
    tags?: tagUncheckedUpdateManyWithoutAccountNestedInput
    comments?: commentsUncheckedUpdateManyWithoutAccountNestedInput
    attachments?: attachmentsUncheckedUpdateManyWithoutAccountNestedInput
    follows?: followsUncheckedUpdateManyWithoutAccountNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutAccountNestedInput
    conversations?: conversationUncheckedUpdateManyWithoutAccountNestedInput
    sharedNotes?: noteInternalShareUncheckedUpdateManyWithoutAccountNestedInput
    aiScheduledTasks?: aiScheduledTaskUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type accountsCreateManyInput = {
    id?: number
    name?: string
    nickname?: string
    password?: string
    image?: string
    apiToken?: string
    description?: string
    note?: number
    role?: string
    loginType?: string
    linkAccountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type accountsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    apiToken?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    note?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    loginType?: StringFieldUpdateOperationsInput | string
    linkAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type accountsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    apiToken?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    note?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    loginType?: StringFieldUpdateOperationsInput | string
    linkAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type attachmentsCreateInput = {
    isShare?: boolean
    sharePassword?: string
    name?: string
    path?: string
    size?: Decimal | DecimalJsLike | number | string
    type?: string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    perfixPath?: string | null
    depth?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    note?: notesCreateNestedOneWithoutAttachmentsInput
    account?: accountsCreateNestedOneWithoutAttachmentsInput
  }

  export type attachmentsUncheckedCreateInput = {
    id?: number
    isShare?: boolean
    sharePassword?: string
    name?: string
    path?: string
    size?: Decimal | DecimalJsLike | number | string
    type?: string
    noteId?: number | null
    accountId?: number | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    perfixPath?: string | null
    depth?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type attachmentsUpdateInput = {
    isShare?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perfixPath?: NullableStringFieldUpdateOperationsInput | string | null
    depth?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    note?: notesUpdateOneWithoutAttachmentsNestedInput
    account?: accountsUpdateOneWithoutAttachmentsNestedInput
  }

  export type attachmentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    isShare?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    noteId?: NullableIntFieldUpdateOperationsInput | number | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perfixPath?: NullableStringFieldUpdateOperationsInput | string | null
    depth?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type attachmentsCreateManyInput = {
    id?: number
    isShare?: boolean
    sharePassword?: string
    name?: string
    path?: string
    size?: Decimal | DecimalJsLike | number | string
    type?: string
    noteId?: number | null
    accountId?: number | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    perfixPath?: string | null
    depth?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type attachmentsUpdateManyMutationInput = {
    isShare?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perfixPath?: NullableStringFieldUpdateOperationsInput | string | null
    depth?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type attachmentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    isShare?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    noteId?: NullableIntFieldUpdateOperationsInput | number | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perfixPath?: NullableStringFieldUpdateOperationsInput | string | null
    depth?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type configCreateInput = {
    key?: string
    config?: NullableJsonNullValueInput | InputJsonValue
    user?: accountsCreateNestedOneWithoutConfigsInput
  }

  export type configUncheckedCreateInput = {
    id?: number
    key?: string
    config?: NullableJsonNullValueInput | InputJsonValue
    userId?: number | null
  }

  export type configUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    user?: accountsUpdateOneWithoutConfigsNestedInput
  }

  export type configUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type configCreateManyInput = {
    id?: number
    key?: string
    config?: NullableJsonNullValueInput | InputJsonValue
    userId?: number | null
  }

  export type configUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
  }

  export type configUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type notesCreateInput = {
    type?: number
    content?: string
    isArchived?: boolean
    isRecycle?: boolean
    isShare?: boolean
    isTop?: boolean
    isReviewed?: boolean
    sharePassword?: string
    shareEncryptedUrl?: string | null
    shareExpiryDate?: Date | string | null
    shareMaxView?: number | null
    shareViewCount?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: attachmentsCreateNestedManyWithoutNoteInput
    tags?: tagsToNoteCreateNestedManyWithoutNoteInput
    account?: accountsCreateNestedOneWithoutNotesInput
    referencedBy?: noteReferenceCreateNestedManyWithoutToNoteInput
    references?: noteReferenceCreateNestedManyWithoutFromNoteInput
    comments?: commentsCreateNestedManyWithoutNoteInput
    histories?: noteHistoryCreateNestedManyWithoutNoteInput
    internalShares?: noteInternalShareCreateNestedManyWithoutNoteInput
  }

  export type notesUncheckedCreateInput = {
    id?: number
    type?: number
    content?: string
    isArchived?: boolean
    isRecycle?: boolean
    isShare?: boolean
    isTop?: boolean
    isReviewed?: boolean
    sharePassword?: string
    shareEncryptedUrl?: string | null
    shareExpiryDate?: Date | string | null
    shareMaxView?: number | null
    shareViewCount?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId?: number | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: attachmentsUncheckedCreateNestedManyWithoutNoteInput
    tags?: tagsToNoteUncheckedCreateNestedManyWithoutNoteInput
    referencedBy?: noteReferenceUncheckedCreateNestedManyWithoutToNoteInput
    references?: noteReferenceUncheckedCreateNestedManyWithoutFromNoteInput
    comments?: commentsUncheckedCreateNestedManyWithoutNoteInput
    histories?: noteHistoryUncheckedCreateNestedManyWithoutNoteInput
    internalShares?: noteInternalShareUncheckedCreateNestedManyWithoutNoteInput
  }

  export type notesUpdateInput = {
    type?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isRecycle?: BoolFieldUpdateOperationsInput | boolean
    isShare?: BoolFieldUpdateOperationsInput | boolean
    isTop?: BoolFieldUpdateOperationsInput | boolean
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    shareEncryptedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shareExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareMaxView?: NullableIntFieldUpdateOperationsInput | number | null
    shareViewCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: attachmentsUpdateManyWithoutNoteNestedInput
    tags?: tagsToNoteUpdateManyWithoutNoteNestedInput
    account?: accountsUpdateOneWithoutNotesNestedInput
    referencedBy?: noteReferenceUpdateManyWithoutToNoteNestedInput
    references?: noteReferenceUpdateManyWithoutFromNoteNestedInput
    comments?: commentsUpdateManyWithoutNoteNestedInput
    histories?: noteHistoryUpdateManyWithoutNoteNestedInput
    internalShares?: noteInternalShareUpdateManyWithoutNoteNestedInput
  }

  export type notesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isRecycle?: BoolFieldUpdateOperationsInput | boolean
    isShare?: BoolFieldUpdateOperationsInput | boolean
    isTop?: BoolFieldUpdateOperationsInput | boolean
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    shareEncryptedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shareExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareMaxView?: NullableIntFieldUpdateOperationsInput | number | null
    shareViewCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: attachmentsUncheckedUpdateManyWithoutNoteNestedInput
    tags?: tagsToNoteUncheckedUpdateManyWithoutNoteNestedInput
    referencedBy?: noteReferenceUncheckedUpdateManyWithoutToNoteNestedInput
    references?: noteReferenceUncheckedUpdateManyWithoutFromNoteNestedInput
    comments?: commentsUncheckedUpdateManyWithoutNoteNestedInput
    histories?: noteHistoryUncheckedUpdateManyWithoutNoteNestedInput
    internalShares?: noteInternalShareUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type notesCreateManyInput = {
    id?: number
    type?: number
    content?: string
    isArchived?: boolean
    isRecycle?: boolean
    isShare?: boolean
    isTop?: boolean
    isReviewed?: boolean
    sharePassword?: string
    shareEncryptedUrl?: string | null
    shareExpiryDate?: Date | string | null
    shareMaxView?: number | null
    shareViewCount?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId?: number | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type notesUpdateManyMutationInput = {
    type?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isRecycle?: BoolFieldUpdateOperationsInput | boolean
    isShare?: BoolFieldUpdateOperationsInput | boolean
    isTop?: BoolFieldUpdateOperationsInput | boolean
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    shareEncryptedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shareExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareMaxView?: NullableIntFieldUpdateOperationsInput | number | null
    shareViewCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isRecycle?: BoolFieldUpdateOperationsInput | boolean
    isShare?: BoolFieldUpdateOperationsInput | boolean
    isTop?: BoolFieldUpdateOperationsInput | boolean
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    shareEncryptedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shareExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareMaxView?: NullableIntFieldUpdateOperationsInput | number | null
    shareViewCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type commentsCreateInput = {
    content: string
    guestName?: string | null
    guestIP?: string | null
    guestUA?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    note: notesCreateNestedOneWithoutCommentsInput
    account?: accountsCreateNestedOneWithoutCommentsInput
    parent?: commentsCreateNestedOneWithoutRepliesInput
    replies?: commentsCreateNestedManyWithoutParentInput
  }

  export type commentsUncheckedCreateInput = {
    id?: number
    content: string
    accountId?: number | null
    guestName?: string | null
    guestIP?: string | null
    guestUA?: string | null
    noteId: number
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: commentsUncheckedCreateNestedManyWithoutParentInput
  }

  export type commentsUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestIP?: NullableStringFieldUpdateOperationsInput | string | null
    guestUA?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: notesUpdateOneRequiredWithoutCommentsNestedInput
    account?: accountsUpdateOneWithoutCommentsNestedInput
    parent?: commentsUpdateOneWithoutRepliesNestedInput
    replies?: commentsUpdateManyWithoutParentNestedInput
  }

  export type commentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestIP?: NullableStringFieldUpdateOperationsInput | string | null
    guestUA?: NullableStringFieldUpdateOperationsInput | string | null
    noteId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: commentsUncheckedUpdateManyWithoutParentNestedInput
  }

  export type commentsCreateManyInput = {
    id?: number
    content: string
    accountId?: number | null
    guestName?: string | null
    guestIP?: string | null
    guestUA?: string | null
    noteId: number
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type commentsUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestIP?: NullableStringFieldUpdateOperationsInput | string | null
    guestUA?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type commentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestIP?: NullableStringFieldUpdateOperationsInput | string | null
    guestUA?: NullableStringFieldUpdateOperationsInput | string | null
    noteId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tagCreateInput = {
    name?: string
    icon?: string
    parent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sortOrder?: number
    tagsToNote?: tagsToNoteCreateNestedManyWithoutTagInput
    account?: accountsCreateNestedOneWithoutTagsInput
  }

  export type tagUncheckedCreateInput = {
    id?: number
    name?: string
    icon?: string
    parent?: number
    accountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sortOrder?: number
    tagsToNote?: tagsToNoteUncheckedCreateNestedManyWithoutTagInput
  }

  export type tagUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    parent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    tagsToNote?: tagsToNoteUpdateManyWithoutTagNestedInput
    account?: accountsUpdateOneWithoutTagsNestedInput
  }

  export type tagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    parent?: IntFieldUpdateOperationsInput | number
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    tagsToNote?: tagsToNoteUncheckedUpdateManyWithoutTagNestedInput
  }

  export type tagCreateManyInput = {
    id?: number
    name?: string
    icon?: string
    parent?: number
    accountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sortOrder?: number
  }

  export type tagUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    parent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type tagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    parent?: IntFieldUpdateOperationsInput | number
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type tagsToNoteCreateInput = {
    id?: number
    note?: notesCreateNestedOneWithoutTagsInput
    tag?: tagCreateNestedOneWithoutTagsToNoteInput
  }

  export type tagsToNoteUncheckedCreateInput = {
    id?: number
    noteId?: number
    tagId?: number
  }

  export type tagsToNoteUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    note?: notesUpdateOneRequiredWithoutTagsNestedInput
    tag?: tagUpdateOneRequiredWithoutTagsToNoteNestedInput
  }

  export type tagsToNoteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    noteId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type tagsToNoteCreateManyInput = {
    id?: number
    noteId?: number
    tagId?: number
  }

  export type tagsToNoteUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type tagsToNoteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    noteId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type noteReferenceCreateInput = {
    createdAt?: Date | string
    fromNote: notesCreateNestedOneWithoutReferencesInput
    toNote: notesCreateNestedOneWithoutReferencedByInput
  }

  export type noteReferenceUncheckedCreateInput = {
    id?: number
    fromNoteId: number
    toNoteId: number
    createdAt?: Date | string
  }

  export type noteReferenceUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromNote?: notesUpdateOneRequiredWithoutReferencesNestedInput
    toNote?: notesUpdateOneRequiredWithoutReferencedByNestedInput
  }

  export type noteReferenceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromNoteId?: IntFieldUpdateOperationsInput | number
    toNoteId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type noteReferenceCreateManyInput = {
    id?: number
    fromNoteId: number
    toNoteId: number
    createdAt?: Date | string
  }

  export type noteReferenceUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type noteReferenceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromNoteId?: IntFieldUpdateOperationsInput | number
    toNoteId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type followsCreateInput = {
    siteName?: string | null
    siteUrl: string
    siteAvatar?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    followType?: string
    account: accountsCreateNestedOneWithoutFollowsInput
  }

  export type followsUncheckedCreateInput = {
    id?: number
    siteName?: string | null
    siteUrl: string
    siteAvatar?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    followType?: string
    accountId: number
  }

  export type followsUpdateInput = {
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    siteUrl?: StringFieldUpdateOperationsInput | string
    siteAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followType?: StringFieldUpdateOperationsInput | string
    account?: accountsUpdateOneRequiredWithoutFollowsNestedInput
  }

  export type followsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    siteUrl?: StringFieldUpdateOperationsInput | string
    siteAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followType?: StringFieldUpdateOperationsInput | string
    accountId?: IntFieldUpdateOperationsInput | number
  }

  export type followsCreateManyInput = {
    id?: number
    siteName?: string | null
    siteUrl: string
    siteAvatar?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    followType?: string
    accountId: number
  }

  export type followsUpdateManyMutationInput = {
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    siteUrl?: StringFieldUpdateOperationsInput | string
    siteAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followType?: StringFieldUpdateOperationsInput | string
  }

  export type followsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    siteUrl?: StringFieldUpdateOperationsInput | string
    siteAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followType?: StringFieldUpdateOperationsInput | string
    accountId?: IntFieldUpdateOperationsInput | number
  }

  export type notificationsCreateInput = {
    type: string
    title: string
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    account: accountsCreateNestedOneWithoutNotificationsInput
  }

  export type notificationsUncheckedCreateInput = {
    id?: number
    type: string
    title: string
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean
    accountId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type notificationsUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: accountsUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type notificationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    accountId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsCreateManyInput = {
    id?: number
    type: string
    title: string
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean
    accountId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type notificationsUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    accountId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cacheCreateInput = {
    key: string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type cacheUncheckedCreateInput = {
    id?: number
    key: string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type cacheUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cacheUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cacheCreateManyInput = {
    id?: number
    key: string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type cacheUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cacheUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pluginCreateInput = {
    metadata: JsonNullValueInput | InputJsonValue
    path: string
    isUse?: boolean
    isDev?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pluginUncheckedCreateInput = {
    id?: number
    metadata: JsonNullValueInput | InputJsonValue
    path: string
    isUse?: boolean
    isDev?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pluginUpdateInput = {
    metadata?: JsonNullValueInput | InputJsonValue
    path?: StringFieldUpdateOperationsInput | string
    isUse?: BoolFieldUpdateOperationsInput | boolean
    isDev?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pluginUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    path?: StringFieldUpdateOperationsInput | string
    isUse?: BoolFieldUpdateOperationsInput | boolean
    isDev?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pluginCreateManyInput = {
    id?: number
    metadata: JsonNullValueInput | InputJsonValue
    path: string
    isUse?: boolean
    isDev?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pluginUpdateManyMutationInput = {
    metadata?: JsonNullValueInput | InputJsonValue
    path?: StringFieldUpdateOperationsInput | string
    isUse?: BoolFieldUpdateOperationsInput | boolean
    isDev?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pluginUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    path?: StringFieldUpdateOperationsInput | string
    isUse?: BoolFieldUpdateOperationsInput | boolean
    isDev?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type conversationCreateInput = {
    title?: string
    isShare?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: messageCreateNestedManyWithoutConversationInput
    account: accountsCreateNestedOneWithoutConversationsInput
  }

  export type conversationUncheckedCreateInput = {
    id?: number
    title?: string
    isShare?: boolean
    accountId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: messageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type conversationUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    isShare?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: messageUpdateManyWithoutConversationNestedInput
    account?: accountsUpdateOneRequiredWithoutConversationsNestedInput
  }

  export type conversationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    isShare?: BoolFieldUpdateOperationsInput | boolean
    accountId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: messageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type conversationCreateManyInput = {
    id?: number
    title?: string
    isShare?: boolean
    accountId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type conversationUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    isShare?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type conversationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    isShare?: BoolFieldUpdateOperationsInput | boolean
    accountId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type messageCreateInput = {
    content: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    conversation: conversationCreateNestedOneWithoutMessagesInput
  }

  export type messageUncheckedCreateInput = {
    id?: number
    content: string
    role: string
    conversationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type messageUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    conversation?: conversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type messageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    conversationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type messageCreateManyInput = {
    id?: number
    content: string
    role: string
    conversationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type messageUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type messageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    conversationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type noteHistoryCreateInput = {
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version: number
    accountId?: number | null
    createdAt?: Date | string
    note: notesCreateNestedOneWithoutHistoriesInput
  }

  export type noteHistoryUncheckedCreateInput = {
    id?: number
    noteId: number
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version: number
    accountId?: number | null
    createdAt?: Date | string
  }

  export type noteHistoryUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: notesUpdateOneRequiredWithoutHistoriesNestedInput
  }

  export type noteHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    noteId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type noteHistoryCreateManyInput = {
    id?: number
    noteId: number
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version: number
    accountId?: number | null
    createdAt?: Date | string
  }

  export type noteHistoryUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type noteHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    noteId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type noteInternalShareCreateInput = {
    canEdit?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    note: notesCreateNestedOneWithoutInternalSharesInput
    account: accountsCreateNestedOneWithoutSharedNotesInput
  }

  export type noteInternalShareUncheckedCreateInput = {
    id?: number
    noteId: number
    accountId: number
    canEdit?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type noteInternalShareUpdateInput = {
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: notesUpdateOneRequiredWithoutInternalSharesNestedInput
    account?: accountsUpdateOneRequiredWithoutSharedNotesNestedInput
  }

  export type noteInternalShareUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    noteId?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type noteInternalShareCreateManyInput = {
    id?: number
    noteId: number
    accountId: number
    canEdit?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type noteInternalShareUpdateManyMutationInput = {
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type noteInternalShareUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    noteId?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessionCreateInput = {
    id: string
    sid: string
    data: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type sessionUncheckedCreateInput = {
    id: string
    sid: string
    data: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type sessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessionCreateManyInput = {
    id: string
    sid: string
    data: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type sessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type aiProvidersCreateInput = {
    title: string
    provider: string
    baseURL?: string | null
    apiKey?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    models?: aiModelsCreateNestedManyWithoutProviderInput
  }

  export type aiProvidersUncheckedCreateInput = {
    id?: number
    title: string
    provider: string
    baseURL?: string | null
    apiKey?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    models?: aiModelsUncheckedCreateNestedManyWithoutProviderInput
  }

  export type aiProvidersUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    baseURL?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: aiModelsUpdateManyWithoutProviderNestedInput
  }

  export type aiProvidersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    baseURL?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: aiModelsUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type aiProvidersCreateManyInput = {
    id?: number
    title: string
    provider: string
    baseURL?: string | null
    apiKey?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type aiProvidersUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    baseURL?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type aiProvidersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    baseURL?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type aiModelsCreateInput = {
    title: string
    modelKey: string
    capabilities: JsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: aiProvidersCreateNestedOneWithoutModelsInput
  }

  export type aiModelsUncheckedCreateInput = {
    id?: number
    providerId: number
    title: string
    modelKey: string
    capabilities: JsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type aiModelsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    modelKey?: StringFieldUpdateOperationsInput | string
    capabilities?: JsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: aiProvidersUpdateOneRequiredWithoutModelsNestedInput
  }

  export type aiModelsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    providerId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    modelKey?: StringFieldUpdateOperationsInput | string
    capabilities?: JsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type aiModelsCreateManyInput = {
    id?: number
    providerId: number
    title: string
    modelKey: string
    capabilities: JsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type aiModelsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    modelKey?: StringFieldUpdateOperationsInput | string
    capabilities?: JsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type aiModelsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    providerId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    modelKey?: StringFieldUpdateOperationsInput | string
    capabilities?: JsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type aiScheduledTaskCreateInput = {
    name: string
    prompt: string
    schedule: string
    isEnabled?: boolean
    lastRun?: Date | string | null
    lastResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    account: accountsCreateNestedOneWithoutAiScheduledTasksInput
  }

  export type aiScheduledTaskUncheckedCreateInput = {
    id?: number
    name: string
    prompt: string
    schedule: string
    isEnabled?: boolean
    lastRun?: Date | string | null
    lastResult?: NullableJsonNullValueInput | InputJsonValue
    accountId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type aiScheduledTaskUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: accountsUpdateOneRequiredWithoutAiScheduledTasksNestedInput
  }

  export type aiScheduledTaskUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastResult?: NullableJsonNullValueInput | InputJsonValue
    accountId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type aiScheduledTaskCreateManyInput = {
    id?: number
    name: string
    prompt: string
    schedule: string
    isEnabled?: boolean
    lastRun?: Date | string | null
    lastResult?: NullableJsonNullValueInput | InputJsonValue
    accountId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type aiScheduledTaskUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type aiScheduledTaskUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastResult?: NullableJsonNullValueInput | InputJsonValue
    accountId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type mcpServersCreateInput = {
    name: string
    description?: string | null
    type: string
    command?: string | null
    args?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    env?: NullableJsonNullValueInput | InputJsonValue
    headers?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type mcpServersUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    type: string
    command?: string | null
    args?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    env?: NullableJsonNullValueInput | InputJsonValue
    headers?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type mcpServersUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    command?: NullableStringFieldUpdateOperationsInput | string | null
    args?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    env?: NullableJsonNullValueInput | InputJsonValue
    headers?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type mcpServersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    command?: NullableStringFieldUpdateOperationsInput | string | null
    args?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    env?: NullableJsonNullValueInput | InputJsonValue
    headers?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type mcpServersCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    type: string
    command?: string | null
    args?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    env?: NullableJsonNullValueInput | InputJsonValue
    headers?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type mcpServersUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    command?: NullableStringFieldUpdateOperationsInput | string | null
    args?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    env?: NullableJsonNullValueInput | InputJsonValue
    headers?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type mcpServersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    command?: NullableStringFieldUpdateOperationsInput | string | null
    args?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    env?: NullableJsonNullValueInput | InputJsonValue
    headers?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fontsCreateInput = {
    name: string
    displayName: string
    url?: string | null
    fileData?: Bytes | null
    isLocal?: boolean
    isSystem?: boolean
    weights: JsonNullValueInput | InputJsonValue
    category?: string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type fontsUncheckedCreateInput = {
    id?: number
    name: string
    displayName: string
    url?: string | null
    fileData?: Bytes | null
    isLocal?: boolean
    isSystem?: boolean
    weights: JsonNullValueInput | InputJsonValue
    category?: string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type fontsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    fileData?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    isLocal?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    weights?: JsonNullValueInput | InputJsonValue
    category?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fontsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    fileData?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    isLocal?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    weights?: JsonNullValueInput | InputJsonValue
    category?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fontsCreateManyInput = {
    id?: number
    name: string
    displayName: string
    url?: string | null
    fileData?: Bytes | null
    isLocal?: boolean
    isSystem?: boolean
    weights: JsonNullValueInput | InputJsonValue
    category?: string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type fontsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    fileData?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    isLocal?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    weights?: JsonNullValueInput | InputJsonValue
    category?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fontsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    fileData?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    isLocal?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    weights?: JsonNullValueInput | InputJsonValue
    category?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NotesListRelationFilter = {
    every?: notesWhereInput
    some?: notesWhereInput
    none?: notesWhereInput
  }

  export type ConfigListRelationFilter = {
    every?: configWhereInput
    some?: configWhereInput
    none?: configWhereInput
  }

  export type TagListRelationFilter = {
    every?: tagWhereInput
    some?: tagWhereInput
    none?: tagWhereInput
  }

  export type CommentsListRelationFilter = {
    every?: commentsWhereInput
    some?: commentsWhereInput
    none?: commentsWhereInput
  }

  export type AttachmentsListRelationFilter = {
    every?: attachmentsWhereInput
    some?: attachmentsWhereInput
    none?: attachmentsWhereInput
  }

  export type FollowsListRelationFilter = {
    every?: followsWhereInput
    some?: followsWhereInput
    none?: followsWhereInput
  }

  export type NotificationsListRelationFilter = {
    every?: notificationsWhereInput
    some?: notificationsWhereInput
    none?: notificationsWhereInput
  }

  export type ConversationListRelationFilter = {
    every?: conversationWhereInput
    some?: conversationWhereInput
    none?: conversationWhereInput
  }

  export type NoteInternalShareListRelationFilter = {
    every?: noteInternalShareWhereInput
    some?: noteInternalShareWhereInput
    none?: noteInternalShareWhereInput
  }

  export type AiScheduledTaskListRelationFilter = {
    every?: aiScheduledTaskWhereInput
    some?: aiScheduledTaskWhereInput
    none?: aiScheduledTaskWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type notesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type configOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type commentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type attachmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type followsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type conversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type noteInternalShareOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type aiScheduledTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type accountsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nickname?: SortOrder
    password?: SortOrder
    image?: SortOrder
    apiToken?: SortOrder
    description?: SortOrder
    note?: SortOrder
    role?: SortOrder
    loginType?: SortOrder
    linkAccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type accountsAvgOrderByAggregateInput = {
    id?: SortOrder
    note?: SortOrder
    linkAccountId?: SortOrder
  }

  export type accountsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nickname?: SortOrder
    password?: SortOrder
    image?: SortOrder
    apiToken?: SortOrder
    description?: SortOrder
    note?: SortOrder
    role?: SortOrder
    loginType?: SortOrder
    linkAccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type accountsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nickname?: SortOrder
    password?: SortOrder
    image?: SortOrder
    apiToken?: SortOrder
    description?: SortOrder
    note?: SortOrder
    role?: SortOrder
    loginType?: SortOrder
    linkAccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type accountsSumOrderByAggregateInput = {
    id?: SortOrder
    note?: SortOrder
    linkAccountId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NotesNullableScalarRelationFilter = {
    is?: notesWhereInput | null
    isNot?: notesWhereInput | null
  }

  export type AccountsNullableScalarRelationFilter = {
    is?: accountsWhereInput | null
    isNot?: accountsWhereInput | null
  }

  export type attachmentsCountOrderByAggregateInput = {
    id?: SortOrder
    isShare?: SortOrder
    sharePassword?: SortOrder
    name?: SortOrder
    path?: SortOrder
    size?: SortOrder
    type?: SortOrder
    noteId?: SortOrder
    accountId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    perfixPath?: SortOrder
    depth?: SortOrder
    metadata?: SortOrder
  }

  export type attachmentsAvgOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
    noteId?: SortOrder
    accountId?: SortOrder
    sortOrder?: SortOrder
    depth?: SortOrder
  }

  export type attachmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    isShare?: SortOrder
    sharePassword?: SortOrder
    name?: SortOrder
    path?: SortOrder
    size?: SortOrder
    type?: SortOrder
    noteId?: SortOrder
    accountId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    perfixPath?: SortOrder
    depth?: SortOrder
  }

  export type attachmentsMinOrderByAggregateInput = {
    id?: SortOrder
    isShare?: SortOrder
    sharePassword?: SortOrder
    name?: SortOrder
    path?: SortOrder
    size?: SortOrder
    type?: SortOrder
    noteId?: SortOrder
    accountId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    perfixPath?: SortOrder
    depth?: SortOrder
  }

  export type attachmentsSumOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
    noteId?: SortOrder
    accountId?: SortOrder
    sortOrder?: SortOrder
    depth?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type configCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    config?: SortOrder
    userId?: SortOrder
  }

  export type configAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type configMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    userId?: SortOrder
  }

  export type configMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    userId?: SortOrder
  }

  export type configSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type TagsToNoteListRelationFilter = {
    every?: tagsToNoteWhereInput
    some?: tagsToNoteWhereInput
    none?: tagsToNoteWhereInput
  }

  export type NoteReferenceListRelationFilter = {
    every?: noteReferenceWhereInput
    some?: noteReferenceWhereInput
    none?: noteReferenceWhereInput
  }

  export type NoteHistoryListRelationFilter = {
    every?: noteHistoryWhereInput
    some?: noteHistoryWhereInput
    none?: noteHistoryWhereInput
  }

  export type tagsToNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type noteReferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type noteHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notesCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    isArchived?: SortOrder
    isRecycle?: SortOrder
    isShare?: SortOrder
    isTop?: SortOrder
    isReviewed?: SortOrder
    sharePassword?: SortOrder
    shareEncryptedUrl?: SortOrder
    shareExpiryDate?: SortOrder
    shareMaxView?: SortOrder
    shareViewCount?: SortOrder
    metadata?: SortOrder
    accountId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type notesAvgOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    shareMaxView?: SortOrder
    shareViewCount?: SortOrder
    accountId?: SortOrder
    sortOrder?: SortOrder
  }

  export type notesMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    isArchived?: SortOrder
    isRecycle?: SortOrder
    isShare?: SortOrder
    isTop?: SortOrder
    isReviewed?: SortOrder
    sharePassword?: SortOrder
    shareEncryptedUrl?: SortOrder
    shareExpiryDate?: SortOrder
    shareMaxView?: SortOrder
    shareViewCount?: SortOrder
    accountId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type notesMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    isArchived?: SortOrder
    isRecycle?: SortOrder
    isShare?: SortOrder
    isTop?: SortOrder
    isReviewed?: SortOrder
    sharePassword?: SortOrder
    shareEncryptedUrl?: SortOrder
    shareExpiryDate?: SortOrder
    shareMaxView?: SortOrder
    shareViewCount?: SortOrder
    accountId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type notesSumOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    shareMaxView?: SortOrder
    shareViewCount?: SortOrder
    accountId?: SortOrder
    sortOrder?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NotesScalarRelationFilter = {
    is?: notesWhereInput
    isNot?: notesWhereInput
  }

  export type CommentsNullableScalarRelationFilter = {
    is?: commentsWhereInput | null
    isNot?: commentsWhereInput | null
  }

  export type commentsCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    accountId?: SortOrder
    guestName?: SortOrder
    guestIP?: SortOrder
    guestUA?: SortOrder
    noteId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type commentsAvgOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    noteId?: SortOrder
    parentId?: SortOrder
  }

  export type commentsMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    accountId?: SortOrder
    guestName?: SortOrder
    guestIP?: SortOrder
    guestUA?: SortOrder
    noteId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type commentsMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    accountId?: SortOrder
    guestName?: SortOrder
    guestIP?: SortOrder
    guestUA?: SortOrder
    noteId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type commentsSumOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    noteId?: SortOrder
    parentId?: SortOrder
  }

  export type tagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    parent?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sortOrder?: SortOrder
  }

  export type tagAvgOrderByAggregateInput = {
    id?: SortOrder
    parent?: SortOrder
    accountId?: SortOrder
    sortOrder?: SortOrder
  }

  export type tagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    parent?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sortOrder?: SortOrder
  }

  export type tagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    parent?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sortOrder?: SortOrder
  }

  export type tagSumOrderByAggregateInput = {
    id?: SortOrder
    parent?: SortOrder
    accountId?: SortOrder
    sortOrder?: SortOrder
  }

  export type TagScalarRelationFilter = {
    is?: tagWhereInput
    isNot?: tagWhereInput
  }

  export type tagsToNoteNoteIdTagIdCompoundUniqueInput = {
    noteId: number
    tagId: number
  }

  export type tagsToNoteCountOrderByAggregateInput = {
    id?: SortOrder
    noteId?: SortOrder
    tagId?: SortOrder
  }

  export type tagsToNoteAvgOrderByAggregateInput = {
    id?: SortOrder
    noteId?: SortOrder
    tagId?: SortOrder
  }

  export type tagsToNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    noteId?: SortOrder
    tagId?: SortOrder
  }

  export type tagsToNoteMinOrderByAggregateInput = {
    id?: SortOrder
    noteId?: SortOrder
    tagId?: SortOrder
  }

  export type tagsToNoteSumOrderByAggregateInput = {
    id?: SortOrder
    noteId?: SortOrder
    tagId?: SortOrder
  }

  export type noteReferenceFromNoteIdToNoteIdCompoundUniqueInput = {
    fromNoteId: number
    toNoteId: number
  }

  export type noteReferenceCountOrderByAggregateInput = {
    id?: SortOrder
    fromNoteId?: SortOrder
    toNoteId?: SortOrder
    createdAt?: SortOrder
  }

  export type noteReferenceAvgOrderByAggregateInput = {
    id?: SortOrder
    fromNoteId?: SortOrder
    toNoteId?: SortOrder
  }

  export type noteReferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    fromNoteId?: SortOrder
    toNoteId?: SortOrder
    createdAt?: SortOrder
  }

  export type noteReferenceMinOrderByAggregateInput = {
    id?: SortOrder
    fromNoteId?: SortOrder
    toNoteId?: SortOrder
    createdAt?: SortOrder
  }

  export type noteReferenceSumOrderByAggregateInput = {
    id?: SortOrder
    fromNoteId?: SortOrder
    toNoteId?: SortOrder
  }

  export type AccountsScalarRelationFilter = {
    is?: accountsWhereInput
    isNot?: accountsWhereInput
  }

  export type followsCountOrderByAggregateInput = {
    id?: SortOrder
    siteName?: SortOrder
    siteUrl?: SortOrder
    siteAvatar?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    followType?: SortOrder
    accountId?: SortOrder
  }

  export type followsAvgOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
  }

  export type followsMaxOrderByAggregateInput = {
    id?: SortOrder
    siteName?: SortOrder
    siteUrl?: SortOrder
    siteAvatar?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    followType?: SortOrder
    accountId?: SortOrder
  }

  export type followsMinOrderByAggregateInput = {
    id?: SortOrder
    siteName?: SortOrder
    siteUrl?: SortOrder
    siteAvatar?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    followType?: SortOrder
    accountId?: SortOrder
  }

  export type followsSumOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
  }

  export type notificationsCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    metadata?: SortOrder
    isRead?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type notificationsAvgOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
  }

  export type notificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type notificationsMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type notificationsSumOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type cacheCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cacheAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type cacheMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cacheMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type cacheSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type pluginCountOrderByAggregateInput = {
    id?: SortOrder
    metadata?: SortOrder
    path?: SortOrder
    isUse?: SortOrder
    isDev?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pluginAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type pluginMaxOrderByAggregateInput = {
    id?: SortOrder
    path?: SortOrder
    isUse?: SortOrder
    isDev?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pluginMinOrderByAggregateInput = {
    id?: SortOrder
    path?: SortOrder
    isUse?: SortOrder
    isDev?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pluginSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MessageListRelationFilter = {
    every?: messageWhereInput
    some?: messageWhereInput
    none?: messageWhereInput
  }

  export type messageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type conversationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isShare?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type conversationAvgOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
  }

  export type conversationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isShare?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type conversationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isShare?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type conversationSumOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
  }

  export type ConversationScalarRelationFilter = {
    is?: conversationWhereInput
    isNot?: conversationWhereInput
  }

  export type messageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    role?: SortOrder
    conversationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrder
  }

  export type messageAvgOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
  }

  export type messageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    role?: SortOrder
    conversationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type messageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    role?: SortOrder
    conversationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type messageSumOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
  }

  export type noteHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    noteId?: SortOrder
    content?: SortOrder
    metadata?: SortOrder
    version?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
  }

  export type noteHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    noteId?: SortOrder
    version?: SortOrder
    accountId?: SortOrder
  }

  export type noteHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    noteId?: SortOrder
    content?: SortOrder
    version?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
  }

  export type noteHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    noteId?: SortOrder
    content?: SortOrder
    version?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
  }

  export type noteHistorySumOrderByAggregateInput = {
    id?: SortOrder
    noteId?: SortOrder
    version?: SortOrder
    accountId?: SortOrder
  }

  export type noteInternalShareNoteIdAccountIdCompoundUniqueInput = {
    noteId: number
    accountId: number
  }

  export type noteInternalShareCountOrderByAggregateInput = {
    id?: SortOrder
    noteId?: SortOrder
    accountId?: SortOrder
    canEdit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type noteInternalShareAvgOrderByAggregateInput = {
    id?: SortOrder
    noteId?: SortOrder
    accountId?: SortOrder
  }

  export type noteInternalShareMaxOrderByAggregateInput = {
    id?: SortOrder
    noteId?: SortOrder
    accountId?: SortOrder
    canEdit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type noteInternalShareMinOrderByAggregateInput = {
    id?: SortOrder
    noteId?: SortOrder
    accountId?: SortOrder
    canEdit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type noteInternalShareSumOrderByAggregateInput = {
    id?: SortOrder
    noteId?: SortOrder
    accountId?: SortOrder
  }

  export type sessionCountOrderByAggregateInput = {
    id?: SortOrder
    sid?: SortOrder
    data?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type sessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sid?: SortOrder
    data?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type sessionMinOrderByAggregateInput = {
    id?: SortOrder
    sid?: SortOrder
    data?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiModelsListRelationFilter = {
    every?: aiModelsWhereInput
    some?: aiModelsWhereInput
    none?: aiModelsWhereInput
  }

  export type aiModelsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type aiProvidersCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    provider?: SortOrder
    baseURL?: SortOrder
    apiKey?: SortOrder
    config?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type aiProvidersAvgOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
  }

  export type aiProvidersMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    provider?: SortOrder
    baseURL?: SortOrder
    apiKey?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type aiProvidersMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    provider?: SortOrder
    baseURL?: SortOrder
    apiKey?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type aiProvidersSumOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
  }

  export type AiProvidersScalarRelationFilter = {
    is?: aiProvidersWhereInput
    isNot?: aiProvidersWhereInput
  }

  export type aiModelsCountOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    title?: SortOrder
    modelKey?: SortOrder
    capabilities?: SortOrder
    config?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type aiModelsAvgOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    sortOrder?: SortOrder
  }

  export type aiModelsMaxOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    title?: SortOrder
    modelKey?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type aiModelsMinOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    title?: SortOrder
    modelKey?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type aiModelsSumOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    sortOrder?: SortOrder
  }

  export type aiScheduledTaskCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    prompt?: SortOrder
    schedule?: SortOrder
    isEnabled?: SortOrder
    lastRun?: SortOrder
    lastResult?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type aiScheduledTaskAvgOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
  }

  export type aiScheduledTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    prompt?: SortOrder
    schedule?: SortOrder
    isEnabled?: SortOrder
    lastRun?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type aiScheduledTaskMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    prompt?: SortOrder
    schedule?: SortOrder
    isEnabled?: SortOrder
    lastRun?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type aiScheduledTaskSumOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
  }

  export type mcpServersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    command?: SortOrder
    args?: SortOrder
    url?: SortOrder
    env?: SortOrder
    headers?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type mcpServersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type mcpServersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    command?: SortOrder
    url?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type mcpServersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    command?: SortOrder
    url?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type mcpServersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Bytes | null
  }

  export type fontsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    url?: SortOrder
    fileData?: SortOrder
    isLocal?: SortOrder
    isSystem?: SortOrder
    weights?: SortOrder
    category?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type fontsAvgOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
  }

  export type fontsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    url?: SortOrder
    fileData?: SortOrder
    isLocal?: SortOrder
    isSystem?: SortOrder
    category?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type fontsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    url?: SortOrder
    fileData?: SortOrder
    isLocal?: SortOrder
    isSystem?: SortOrder
    category?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type fontsSumOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Bytes | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type notesCreateNestedManyWithoutAccountInput = {
    create?: XOR<notesCreateWithoutAccountInput, notesUncheckedCreateWithoutAccountInput> | notesCreateWithoutAccountInput[] | notesUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: notesCreateOrConnectWithoutAccountInput | notesCreateOrConnectWithoutAccountInput[]
    createMany?: notesCreateManyAccountInputEnvelope
    connect?: notesWhereUniqueInput | notesWhereUniqueInput[]
  }

  export type configCreateNestedManyWithoutUserInput = {
    create?: XOR<configCreateWithoutUserInput, configUncheckedCreateWithoutUserInput> | configCreateWithoutUserInput[] | configUncheckedCreateWithoutUserInput[]
    connectOrCreate?: configCreateOrConnectWithoutUserInput | configCreateOrConnectWithoutUserInput[]
    createMany?: configCreateManyUserInputEnvelope
    connect?: configWhereUniqueInput | configWhereUniqueInput[]
  }

  export type tagCreateNestedManyWithoutAccountInput = {
    create?: XOR<tagCreateWithoutAccountInput, tagUncheckedCreateWithoutAccountInput> | tagCreateWithoutAccountInput[] | tagUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: tagCreateOrConnectWithoutAccountInput | tagCreateOrConnectWithoutAccountInput[]
    createMany?: tagCreateManyAccountInputEnvelope
    connect?: tagWhereUniqueInput | tagWhereUniqueInput[]
  }

  export type commentsCreateNestedManyWithoutAccountInput = {
    create?: XOR<commentsCreateWithoutAccountInput, commentsUncheckedCreateWithoutAccountInput> | commentsCreateWithoutAccountInput[] | commentsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutAccountInput | commentsCreateOrConnectWithoutAccountInput[]
    createMany?: commentsCreateManyAccountInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type attachmentsCreateNestedManyWithoutAccountInput = {
    create?: XOR<attachmentsCreateWithoutAccountInput, attachmentsUncheckedCreateWithoutAccountInput> | attachmentsCreateWithoutAccountInput[] | attachmentsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: attachmentsCreateOrConnectWithoutAccountInput | attachmentsCreateOrConnectWithoutAccountInput[]
    createMany?: attachmentsCreateManyAccountInputEnvelope
    connect?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
  }

  export type followsCreateNestedManyWithoutAccountInput = {
    create?: XOR<followsCreateWithoutAccountInput, followsUncheckedCreateWithoutAccountInput> | followsCreateWithoutAccountInput[] | followsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: followsCreateOrConnectWithoutAccountInput | followsCreateOrConnectWithoutAccountInput[]
    createMany?: followsCreateManyAccountInputEnvelope
    connect?: followsWhereUniqueInput | followsWhereUniqueInput[]
  }

  export type notificationsCreateNestedManyWithoutAccountInput = {
    create?: XOR<notificationsCreateWithoutAccountInput, notificationsUncheckedCreateWithoutAccountInput> | notificationsCreateWithoutAccountInput[] | notificationsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutAccountInput | notificationsCreateOrConnectWithoutAccountInput[]
    createMany?: notificationsCreateManyAccountInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type conversationCreateNestedManyWithoutAccountInput = {
    create?: XOR<conversationCreateWithoutAccountInput, conversationUncheckedCreateWithoutAccountInput> | conversationCreateWithoutAccountInput[] | conversationUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: conversationCreateOrConnectWithoutAccountInput | conversationCreateOrConnectWithoutAccountInput[]
    createMany?: conversationCreateManyAccountInputEnvelope
    connect?: conversationWhereUniqueInput | conversationWhereUniqueInput[]
  }

  export type noteInternalShareCreateNestedManyWithoutAccountInput = {
    create?: XOR<noteInternalShareCreateWithoutAccountInput, noteInternalShareUncheckedCreateWithoutAccountInput> | noteInternalShareCreateWithoutAccountInput[] | noteInternalShareUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: noteInternalShareCreateOrConnectWithoutAccountInput | noteInternalShareCreateOrConnectWithoutAccountInput[]
    createMany?: noteInternalShareCreateManyAccountInputEnvelope
    connect?: noteInternalShareWhereUniqueInput | noteInternalShareWhereUniqueInput[]
  }

  export type aiScheduledTaskCreateNestedManyWithoutAccountInput = {
    create?: XOR<aiScheduledTaskCreateWithoutAccountInput, aiScheduledTaskUncheckedCreateWithoutAccountInput> | aiScheduledTaskCreateWithoutAccountInput[] | aiScheduledTaskUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: aiScheduledTaskCreateOrConnectWithoutAccountInput | aiScheduledTaskCreateOrConnectWithoutAccountInput[]
    createMany?: aiScheduledTaskCreateManyAccountInputEnvelope
    connect?: aiScheduledTaskWhereUniqueInput | aiScheduledTaskWhereUniqueInput[]
  }

  export type notesUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<notesCreateWithoutAccountInput, notesUncheckedCreateWithoutAccountInput> | notesCreateWithoutAccountInput[] | notesUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: notesCreateOrConnectWithoutAccountInput | notesCreateOrConnectWithoutAccountInput[]
    createMany?: notesCreateManyAccountInputEnvelope
    connect?: notesWhereUniqueInput | notesWhereUniqueInput[]
  }

  export type configUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<configCreateWithoutUserInput, configUncheckedCreateWithoutUserInput> | configCreateWithoutUserInput[] | configUncheckedCreateWithoutUserInput[]
    connectOrCreate?: configCreateOrConnectWithoutUserInput | configCreateOrConnectWithoutUserInput[]
    createMany?: configCreateManyUserInputEnvelope
    connect?: configWhereUniqueInput | configWhereUniqueInput[]
  }

  export type tagUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<tagCreateWithoutAccountInput, tagUncheckedCreateWithoutAccountInput> | tagCreateWithoutAccountInput[] | tagUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: tagCreateOrConnectWithoutAccountInput | tagCreateOrConnectWithoutAccountInput[]
    createMany?: tagCreateManyAccountInputEnvelope
    connect?: tagWhereUniqueInput | tagWhereUniqueInput[]
  }

  export type commentsUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<commentsCreateWithoutAccountInput, commentsUncheckedCreateWithoutAccountInput> | commentsCreateWithoutAccountInput[] | commentsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutAccountInput | commentsCreateOrConnectWithoutAccountInput[]
    createMany?: commentsCreateManyAccountInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type attachmentsUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<attachmentsCreateWithoutAccountInput, attachmentsUncheckedCreateWithoutAccountInput> | attachmentsCreateWithoutAccountInput[] | attachmentsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: attachmentsCreateOrConnectWithoutAccountInput | attachmentsCreateOrConnectWithoutAccountInput[]
    createMany?: attachmentsCreateManyAccountInputEnvelope
    connect?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
  }

  export type followsUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<followsCreateWithoutAccountInput, followsUncheckedCreateWithoutAccountInput> | followsCreateWithoutAccountInput[] | followsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: followsCreateOrConnectWithoutAccountInput | followsCreateOrConnectWithoutAccountInput[]
    createMany?: followsCreateManyAccountInputEnvelope
    connect?: followsWhereUniqueInput | followsWhereUniqueInput[]
  }

  export type notificationsUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<notificationsCreateWithoutAccountInput, notificationsUncheckedCreateWithoutAccountInput> | notificationsCreateWithoutAccountInput[] | notificationsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutAccountInput | notificationsCreateOrConnectWithoutAccountInput[]
    createMany?: notificationsCreateManyAccountInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type conversationUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<conversationCreateWithoutAccountInput, conversationUncheckedCreateWithoutAccountInput> | conversationCreateWithoutAccountInput[] | conversationUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: conversationCreateOrConnectWithoutAccountInput | conversationCreateOrConnectWithoutAccountInput[]
    createMany?: conversationCreateManyAccountInputEnvelope
    connect?: conversationWhereUniqueInput | conversationWhereUniqueInput[]
  }

  export type noteInternalShareUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<noteInternalShareCreateWithoutAccountInput, noteInternalShareUncheckedCreateWithoutAccountInput> | noteInternalShareCreateWithoutAccountInput[] | noteInternalShareUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: noteInternalShareCreateOrConnectWithoutAccountInput | noteInternalShareCreateOrConnectWithoutAccountInput[]
    createMany?: noteInternalShareCreateManyAccountInputEnvelope
    connect?: noteInternalShareWhereUniqueInput | noteInternalShareWhereUniqueInput[]
  }

  export type aiScheduledTaskUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<aiScheduledTaskCreateWithoutAccountInput, aiScheduledTaskUncheckedCreateWithoutAccountInput> | aiScheduledTaskCreateWithoutAccountInput[] | aiScheduledTaskUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: aiScheduledTaskCreateOrConnectWithoutAccountInput | aiScheduledTaskCreateOrConnectWithoutAccountInput[]
    createMany?: aiScheduledTaskCreateManyAccountInputEnvelope
    connect?: aiScheduledTaskWhereUniqueInput | aiScheduledTaskWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type notesUpdateManyWithoutAccountNestedInput = {
    create?: XOR<notesCreateWithoutAccountInput, notesUncheckedCreateWithoutAccountInput> | notesCreateWithoutAccountInput[] | notesUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: notesCreateOrConnectWithoutAccountInput | notesCreateOrConnectWithoutAccountInput[]
    upsert?: notesUpsertWithWhereUniqueWithoutAccountInput | notesUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: notesCreateManyAccountInputEnvelope
    set?: notesWhereUniqueInput | notesWhereUniqueInput[]
    disconnect?: notesWhereUniqueInput | notesWhereUniqueInput[]
    delete?: notesWhereUniqueInput | notesWhereUniqueInput[]
    connect?: notesWhereUniqueInput | notesWhereUniqueInput[]
    update?: notesUpdateWithWhereUniqueWithoutAccountInput | notesUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: notesUpdateManyWithWhereWithoutAccountInput | notesUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: notesScalarWhereInput | notesScalarWhereInput[]
  }

  export type configUpdateManyWithoutUserNestedInput = {
    create?: XOR<configCreateWithoutUserInput, configUncheckedCreateWithoutUserInput> | configCreateWithoutUserInput[] | configUncheckedCreateWithoutUserInput[]
    connectOrCreate?: configCreateOrConnectWithoutUserInput | configCreateOrConnectWithoutUserInput[]
    upsert?: configUpsertWithWhereUniqueWithoutUserInput | configUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: configCreateManyUserInputEnvelope
    set?: configWhereUniqueInput | configWhereUniqueInput[]
    disconnect?: configWhereUniqueInput | configWhereUniqueInput[]
    delete?: configWhereUniqueInput | configWhereUniqueInput[]
    connect?: configWhereUniqueInput | configWhereUniqueInput[]
    update?: configUpdateWithWhereUniqueWithoutUserInput | configUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: configUpdateManyWithWhereWithoutUserInput | configUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: configScalarWhereInput | configScalarWhereInput[]
  }

  export type tagUpdateManyWithoutAccountNestedInput = {
    create?: XOR<tagCreateWithoutAccountInput, tagUncheckedCreateWithoutAccountInput> | tagCreateWithoutAccountInput[] | tagUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: tagCreateOrConnectWithoutAccountInput | tagCreateOrConnectWithoutAccountInput[]
    upsert?: tagUpsertWithWhereUniqueWithoutAccountInput | tagUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: tagCreateManyAccountInputEnvelope
    set?: tagWhereUniqueInput | tagWhereUniqueInput[]
    disconnect?: tagWhereUniqueInput | tagWhereUniqueInput[]
    delete?: tagWhereUniqueInput | tagWhereUniqueInput[]
    connect?: tagWhereUniqueInput | tagWhereUniqueInput[]
    update?: tagUpdateWithWhereUniqueWithoutAccountInput | tagUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: tagUpdateManyWithWhereWithoutAccountInput | tagUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: tagScalarWhereInput | tagScalarWhereInput[]
  }

  export type commentsUpdateManyWithoutAccountNestedInput = {
    create?: XOR<commentsCreateWithoutAccountInput, commentsUncheckedCreateWithoutAccountInput> | commentsCreateWithoutAccountInput[] | commentsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutAccountInput | commentsCreateOrConnectWithoutAccountInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutAccountInput | commentsUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: commentsCreateManyAccountInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutAccountInput | commentsUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutAccountInput | commentsUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type attachmentsUpdateManyWithoutAccountNestedInput = {
    create?: XOR<attachmentsCreateWithoutAccountInput, attachmentsUncheckedCreateWithoutAccountInput> | attachmentsCreateWithoutAccountInput[] | attachmentsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: attachmentsCreateOrConnectWithoutAccountInput | attachmentsCreateOrConnectWithoutAccountInput[]
    upsert?: attachmentsUpsertWithWhereUniqueWithoutAccountInput | attachmentsUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: attachmentsCreateManyAccountInputEnvelope
    set?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
    disconnect?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
    delete?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
    connect?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
    update?: attachmentsUpdateWithWhereUniqueWithoutAccountInput | attachmentsUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: attachmentsUpdateManyWithWhereWithoutAccountInput | attachmentsUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: attachmentsScalarWhereInput | attachmentsScalarWhereInput[]
  }

  export type followsUpdateManyWithoutAccountNestedInput = {
    create?: XOR<followsCreateWithoutAccountInput, followsUncheckedCreateWithoutAccountInput> | followsCreateWithoutAccountInput[] | followsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: followsCreateOrConnectWithoutAccountInput | followsCreateOrConnectWithoutAccountInput[]
    upsert?: followsUpsertWithWhereUniqueWithoutAccountInput | followsUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: followsCreateManyAccountInputEnvelope
    set?: followsWhereUniqueInput | followsWhereUniqueInput[]
    disconnect?: followsWhereUniqueInput | followsWhereUniqueInput[]
    delete?: followsWhereUniqueInput | followsWhereUniqueInput[]
    connect?: followsWhereUniqueInput | followsWhereUniqueInput[]
    update?: followsUpdateWithWhereUniqueWithoutAccountInput | followsUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: followsUpdateManyWithWhereWithoutAccountInput | followsUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: followsScalarWhereInput | followsScalarWhereInput[]
  }

  export type notificationsUpdateManyWithoutAccountNestedInput = {
    create?: XOR<notificationsCreateWithoutAccountInput, notificationsUncheckedCreateWithoutAccountInput> | notificationsCreateWithoutAccountInput[] | notificationsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutAccountInput | notificationsCreateOrConnectWithoutAccountInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutAccountInput | notificationsUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: notificationsCreateManyAccountInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutAccountInput | notificationsUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutAccountInput | notificationsUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type conversationUpdateManyWithoutAccountNestedInput = {
    create?: XOR<conversationCreateWithoutAccountInput, conversationUncheckedCreateWithoutAccountInput> | conversationCreateWithoutAccountInput[] | conversationUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: conversationCreateOrConnectWithoutAccountInput | conversationCreateOrConnectWithoutAccountInput[]
    upsert?: conversationUpsertWithWhereUniqueWithoutAccountInput | conversationUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: conversationCreateManyAccountInputEnvelope
    set?: conversationWhereUniqueInput | conversationWhereUniqueInput[]
    disconnect?: conversationWhereUniqueInput | conversationWhereUniqueInput[]
    delete?: conversationWhereUniqueInput | conversationWhereUniqueInput[]
    connect?: conversationWhereUniqueInput | conversationWhereUniqueInput[]
    update?: conversationUpdateWithWhereUniqueWithoutAccountInput | conversationUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: conversationUpdateManyWithWhereWithoutAccountInput | conversationUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: conversationScalarWhereInput | conversationScalarWhereInput[]
  }

  export type noteInternalShareUpdateManyWithoutAccountNestedInput = {
    create?: XOR<noteInternalShareCreateWithoutAccountInput, noteInternalShareUncheckedCreateWithoutAccountInput> | noteInternalShareCreateWithoutAccountInput[] | noteInternalShareUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: noteInternalShareCreateOrConnectWithoutAccountInput | noteInternalShareCreateOrConnectWithoutAccountInput[]
    upsert?: noteInternalShareUpsertWithWhereUniqueWithoutAccountInput | noteInternalShareUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: noteInternalShareCreateManyAccountInputEnvelope
    set?: noteInternalShareWhereUniqueInput | noteInternalShareWhereUniqueInput[]
    disconnect?: noteInternalShareWhereUniqueInput | noteInternalShareWhereUniqueInput[]
    delete?: noteInternalShareWhereUniqueInput | noteInternalShareWhereUniqueInput[]
    connect?: noteInternalShareWhereUniqueInput | noteInternalShareWhereUniqueInput[]
    update?: noteInternalShareUpdateWithWhereUniqueWithoutAccountInput | noteInternalShareUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: noteInternalShareUpdateManyWithWhereWithoutAccountInput | noteInternalShareUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: noteInternalShareScalarWhereInput | noteInternalShareScalarWhereInput[]
  }

  export type aiScheduledTaskUpdateManyWithoutAccountNestedInput = {
    create?: XOR<aiScheduledTaskCreateWithoutAccountInput, aiScheduledTaskUncheckedCreateWithoutAccountInput> | aiScheduledTaskCreateWithoutAccountInput[] | aiScheduledTaskUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: aiScheduledTaskCreateOrConnectWithoutAccountInput | aiScheduledTaskCreateOrConnectWithoutAccountInput[]
    upsert?: aiScheduledTaskUpsertWithWhereUniqueWithoutAccountInput | aiScheduledTaskUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: aiScheduledTaskCreateManyAccountInputEnvelope
    set?: aiScheduledTaskWhereUniqueInput | aiScheduledTaskWhereUniqueInput[]
    disconnect?: aiScheduledTaskWhereUniqueInput | aiScheduledTaskWhereUniqueInput[]
    delete?: aiScheduledTaskWhereUniqueInput | aiScheduledTaskWhereUniqueInput[]
    connect?: aiScheduledTaskWhereUniqueInput | aiScheduledTaskWhereUniqueInput[]
    update?: aiScheduledTaskUpdateWithWhereUniqueWithoutAccountInput | aiScheduledTaskUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: aiScheduledTaskUpdateManyWithWhereWithoutAccountInput | aiScheduledTaskUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: aiScheduledTaskScalarWhereInput | aiScheduledTaskScalarWhereInput[]
  }

  export type notesUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<notesCreateWithoutAccountInput, notesUncheckedCreateWithoutAccountInput> | notesCreateWithoutAccountInput[] | notesUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: notesCreateOrConnectWithoutAccountInput | notesCreateOrConnectWithoutAccountInput[]
    upsert?: notesUpsertWithWhereUniqueWithoutAccountInput | notesUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: notesCreateManyAccountInputEnvelope
    set?: notesWhereUniqueInput | notesWhereUniqueInput[]
    disconnect?: notesWhereUniqueInput | notesWhereUniqueInput[]
    delete?: notesWhereUniqueInput | notesWhereUniqueInput[]
    connect?: notesWhereUniqueInput | notesWhereUniqueInput[]
    update?: notesUpdateWithWhereUniqueWithoutAccountInput | notesUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: notesUpdateManyWithWhereWithoutAccountInput | notesUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: notesScalarWhereInput | notesScalarWhereInput[]
  }

  export type configUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<configCreateWithoutUserInput, configUncheckedCreateWithoutUserInput> | configCreateWithoutUserInput[] | configUncheckedCreateWithoutUserInput[]
    connectOrCreate?: configCreateOrConnectWithoutUserInput | configCreateOrConnectWithoutUserInput[]
    upsert?: configUpsertWithWhereUniqueWithoutUserInput | configUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: configCreateManyUserInputEnvelope
    set?: configWhereUniqueInput | configWhereUniqueInput[]
    disconnect?: configWhereUniqueInput | configWhereUniqueInput[]
    delete?: configWhereUniqueInput | configWhereUniqueInput[]
    connect?: configWhereUniqueInput | configWhereUniqueInput[]
    update?: configUpdateWithWhereUniqueWithoutUserInput | configUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: configUpdateManyWithWhereWithoutUserInput | configUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: configScalarWhereInput | configScalarWhereInput[]
  }

  export type tagUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<tagCreateWithoutAccountInput, tagUncheckedCreateWithoutAccountInput> | tagCreateWithoutAccountInput[] | tagUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: tagCreateOrConnectWithoutAccountInput | tagCreateOrConnectWithoutAccountInput[]
    upsert?: tagUpsertWithWhereUniqueWithoutAccountInput | tagUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: tagCreateManyAccountInputEnvelope
    set?: tagWhereUniqueInput | tagWhereUniqueInput[]
    disconnect?: tagWhereUniqueInput | tagWhereUniqueInput[]
    delete?: tagWhereUniqueInput | tagWhereUniqueInput[]
    connect?: tagWhereUniqueInput | tagWhereUniqueInput[]
    update?: tagUpdateWithWhereUniqueWithoutAccountInput | tagUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: tagUpdateManyWithWhereWithoutAccountInput | tagUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: tagScalarWhereInput | tagScalarWhereInput[]
  }

  export type commentsUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<commentsCreateWithoutAccountInput, commentsUncheckedCreateWithoutAccountInput> | commentsCreateWithoutAccountInput[] | commentsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutAccountInput | commentsCreateOrConnectWithoutAccountInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutAccountInput | commentsUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: commentsCreateManyAccountInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutAccountInput | commentsUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutAccountInput | commentsUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type attachmentsUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<attachmentsCreateWithoutAccountInput, attachmentsUncheckedCreateWithoutAccountInput> | attachmentsCreateWithoutAccountInput[] | attachmentsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: attachmentsCreateOrConnectWithoutAccountInput | attachmentsCreateOrConnectWithoutAccountInput[]
    upsert?: attachmentsUpsertWithWhereUniqueWithoutAccountInput | attachmentsUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: attachmentsCreateManyAccountInputEnvelope
    set?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
    disconnect?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
    delete?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
    connect?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
    update?: attachmentsUpdateWithWhereUniqueWithoutAccountInput | attachmentsUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: attachmentsUpdateManyWithWhereWithoutAccountInput | attachmentsUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: attachmentsScalarWhereInput | attachmentsScalarWhereInput[]
  }

  export type followsUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<followsCreateWithoutAccountInput, followsUncheckedCreateWithoutAccountInput> | followsCreateWithoutAccountInput[] | followsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: followsCreateOrConnectWithoutAccountInput | followsCreateOrConnectWithoutAccountInput[]
    upsert?: followsUpsertWithWhereUniqueWithoutAccountInput | followsUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: followsCreateManyAccountInputEnvelope
    set?: followsWhereUniqueInput | followsWhereUniqueInput[]
    disconnect?: followsWhereUniqueInput | followsWhereUniqueInput[]
    delete?: followsWhereUniqueInput | followsWhereUniqueInput[]
    connect?: followsWhereUniqueInput | followsWhereUniqueInput[]
    update?: followsUpdateWithWhereUniqueWithoutAccountInput | followsUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: followsUpdateManyWithWhereWithoutAccountInput | followsUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: followsScalarWhereInput | followsScalarWhereInput[]
  }

  export type notificationsUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<notificationsCreateWithoutAccountInput, notificationsUncheckedCreateWithoutAccountInput> | notificationsCreateWithoutAccountInput[] | notificationsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutAccountInput | notificationsCreateOrConnectWithoutAccountInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutAccountInput | notificationsUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: notificationsCreateManyAccountInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutAccountInput | notificationsUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutAccountInput | notificationsUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type conversationUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<conversationCreateWithoutAccountInput, conversationUncheckedCreateWithoutAccountInput> | conversationCreateWithoutAccountInput[] | conversationUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: conversationCreateOrConnectWithoutAccountInput | conversationCreateOrConnectWithoutAccountInput[]
    upsert?: conversationUpsertWithWhereUniqueWithoutAccountInput | conversationUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: conversationCreateManyAccountInputEnvelope
    set?: conversationWhereUniqueInput | conversationWhereUniqueInput[]
    disconnect?: conversationWhereUniqueInput | conversationWhereUniqueInput[]
    delete?: conversationWhereUniqueInput | conversationWhereUniqueInput[]
    connect?: conversationWhereUniqueInput | conversationWhereUniqueInput[]
    update?: conversationUpdateWithWhereUniqueWithoutAccountInput | conversationUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: conversationUpdateManyWithWhereWithoutAccountInput | conversationUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: conversationScalarWhereInput | conversationScalarWhereInput[]
  }

  export type noteInternalShareUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<noteInternalShareCreateWithoutAccountInput, noteInternalShareUncheckedCreateWithoutAccountInput> | noteInternalShareCreateWithoutAccountInput[] | noteInternalShareUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: noteInternalShareCreateOrConnectWithoutAccountInput | noteInternalShareCreateOrConnectWithoutAccountInput[]
    upsert?: noteInternalShareUpsertWithWhereUniqueWithoutAccountInput | noteInternalShareUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: noteInternalShareCreateManyAccountInputEnvelope
    set?: noteInternalShareWhereUniqueInput | noteInternalShareWhereUniqueInput[]
    disconnect?: noteInternalShareWhereUniqueInput | noteInternalShareWhereUniqueInput[]
    delete?: noteInternalShareWhereUniqueInput | noteInternalShareWhereUniqueInput[]
    connect?: noteInternalShareWhereUniqueInput | noteInternalShareWhereUniqueInput[]
    update?: noteInternalShareUpdateWithWhereUniqueWithoutAccountInput | noteInternalShareUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: noteInternalShareUpdateManyWithWhereWithoutAccountInput | noteInternalShareUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: noteInternalShareScalarWhereInput | noteInternalShareScalarWhereInput[]
  }

  export type aiScheduledTaskUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<aiScheduledTaskCreateWithoutAccountInput, aiScheduledTaskUncheckedCreateWithoutAccountInput> | aiScheduledTaskCreateWithoutAccountInput[] | aiScheduledTaskUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: aiScheduledTaskCreateOrConnectWithoutAccountInput | aiScheduledTaskCreateOrConnectWithoutAccountInput[]
    upsert?: aiScheduledTaskUpsertWithWhereUniqueWithoutAccountInput | aiScheduledTaskUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: aiScheduledTaskCreateManyAccountInputEnvelope
    set?: aiScheduledTaskWhereUniqueInput | aiScheduledTaskWhereUniqueInput[]
    disconnect?: aiScheduledTaskWhereUniqueInput | aiScheduledTaskWhereUniqueInput[]
    delete?: aiScheduledTaskWhereUniqueInput | aiScheduledTaskWhereUniqueInput[]
    connect?: aiScheduledTaskWhereUniqueInput | aiScheduledTaskWhereUniqueInput[]
    update?: aiScheduledTaskUpdateWithWhereUniqueWithoutAccountInput | aiScheduledTaskUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: aiScheduledTaskUpdateManyWithWhereWithoutAccountInput | aiScheduledTaskUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: aiScheduledTaskScalarWhereInput | aiScheduledTaskScalarWhereInput[]
  }

  export type notesCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<notesCreateWithoutAttachmentsInput, notesUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: notesCreateOrConnectWithoutAttachmentsInput
    connect?: notesWhereUniqueInput
  }

  export type accountsCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<accountsCreateWithoutAttachmentsInput, accountsUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: accountsCreateOrConnectWithoutAttachmentsInput
    connect?: accountsWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type notesUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<notesCreateWithoutAttachmentsInput, notesUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: notesCreateOrConnectWithoutAttachmentsInput
    upsert?: notesUpsertWithoutAttachmentsInput
    disconnect?: notesWhereInput | boolean
    delete?: notesWhereInput | boolean
    connect?: notesWhereUniqueInput
    update?: XOR<XOR<notesUpdateToOneWithWhereWithoutAttachmentsInput, notesUpdateWithoutAttachmentsInput>, notesUncheckedUpdateWithoutAttachmentsInput>
  }

  export type accountsUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<accountsCreateWithoutAttachmentsInput, accountsUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: accountsCreateOrConnectWithoutAttachmentsInput
    upsert?: accountsUpsertWithoutAttachmentsInput
    disconnect?: accountsWhereInput | boolean
    delete?: accountsWhereInput | boolean
    connect?: accountsWhereUniqueInput
    update?: XOR<XOR<accountsUpdateToOneWithWhereWithoutAttachmentsInput, accountsUpdateWithoutAttachmentsInput>, accountsUncheckedUpdateWithoutAttachmentsInput>
  }

  export type accountsCreateNestedOneWithoutConfigsInput = {
    create?: XOR<accountsCreateWithoutConfigsInput, accountsUncheckedCreateWithoutConfigsInput>
    connectOrCreate?: accountsCreateOrConnectWithoutConfigsInput
    connect?: accountsWhereUniqueInput
  }

  export type accountsUpdateOneWithoutConfigsNestedInput = {
    create?: XOR<accountsCreateWithoutConfigsInput, accountsUncheckedCreateWithoutConfigsInput>
    connectOrCreate?: accountsCreateOrConnectWithoutConfigsInput
    upsert?: accountsUpsertWithoutConfigsInput
    disconnect?: accountsWhereInput | boolean
    delete?: accountsWhereInput | boolean
    connect?: accountsWhereUniqueInput
    update?: XOR<XOR<accountsUpdateToOneWithWhereWithoutConfigsInput, accountsUpdateWithoutConfigsInput>, accountsUncheckedUpdateWithoutConfigsInput>
  }

  export type attachmentsCreateNestedManyWithoutNoteInput = {
    create?: XOR<attachmentsCreateWithoutNoteInput, attachmentsUncheckedCreateWithoutNoteInput> | attachmentsCreateWithoutNoteInput[] | attachmentsUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: attachmentsCreateOrConnectWithoutNoteInput | attachmentsCreateOrConnectWithoutNoteInput[]
    createMany?: attachmentsCreateManyNoteInputEnvelope
    connect?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
  }

  export type tagsToNoteCreateNestedManyWithoutNoteInput = {
    create?: XOR<tagsToNoteCreateWithoutNoteInput, tagsToNoteUncheckedCreateWithoutNoteInput> | tagsToNoteCreateWithoutNoteInput[] | tagsToNoteUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: tagsToNoteCreateOrConnectWithoutNoteInput | tagsToNoteCreateOrConnectWithoutNoteInput[]
    createMany?: tagsToNoteCreateManyNoteInputEnvelope
    connect?: tagsToNoteWhereUniqueInput | tagsToNoteWhereUniqueInput[]
  }

  export type accountsCreateNestedOneWithoutNotesInput = {
    create?: XOR<accountsCreateWithoutNotesInput, accountsUncheckedCreateWithoutNotesInput>
    connectOrCreate?: accountsCreateOrConnectWithoutNotesInput
    connect?: accountsWhereUniqueInput
  }

  export type noteReferenceCreateNestedManyWithoutToNoteInput = {
    create?: XOR<noteReferenceCreateWithoutToNoteInput, noteReferenceUncheckedCreateWithoutToNoteInput> | noteReferenceCreateWithoutToNoteInput[] | noteReferenceUncheckedCreateWithoutToNoteInput[]
    connectOrCreate?: noteReferenceCreateOrConnectWithoutToNoteInput | noteReferenceCreateOrConnectWithoutToNoteInput[]
    createMany?: noteReferenceCreateManyToNoteInputEnvelope
    connect?: noteReferenceWhereUniqueInput | noteReferenceWhereUniqueInput[]
  }

  export type noteReferenceCreateNestedManyWithoutFromNoteInput = {
    create?: XOR<noteReferenceCreateWithoutFromNoteInput, noteReferenceUncheckedCreateWithoutFromNoteInput> | noteReferenceCreateWithoutFromNoteInput[] | noteReferenceUncheckedCreateWithoutFromNoteInput[]
    connectOrCreate?: noteReferenceCreateOrConnectWithoutFromNoteInput | noteReferenceCreateOrConnectWithoutFromNoteInput[]
    createMany?: noteReferenceCreateManyFromNoteInputEnvelope
    connect?: noteReferenceWhereUniqueInput | noteReferenceWhereUniqueInput[]
  }

  export type commentsCreateNestedManyWithoutNoteInput = {
    create?: XOR<commentsCreateWithoutNoteInput, commentsUncheckedCreateWithoutNoteInput> | commentsCreateWithoutNoteInput[] | commentsUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutNoteInput | commentsCreateOrConnectWithoutNoteInput[]
    createMany?: commentsCreateManyNoteInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type noteHistoryCreateNestedManyWithoutNoteInput = {
    create?: XOR<noteHistoryCreateWithoutNoteInput, noteHistoryUncheckedCreateWithoutNoteInput> | noteHistoryCreateWithoutNoteInput[] | noteHistoryUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: noteHistoryCreateOrConnectWithoutNoteInput | noteHistoryCreateOrConnectWithoutNoteInput[]
    createMany?: noteHistoryCreateManyNoteInputEnvelope
    connect?: noteHistoryWhereUniqueInput | noteHistoryWhereUniqueInput[]
  }

  export type noteInternalShareCreateNestedManyWithoutNoteInput = {
    create?: XOR<noteInternalShareCreateWithoutNoteInput, noteInternalShareUncheckedCreateWithoutNoteInput> | noteInternalShareCreateWithoutNoteInput[] | noteInternalShareUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: noteInternalShareCreateOrConnectWithoutNoteInput | noteInternalShareCreateOrConnectWithoutNoteInput[]
    createMany?: noteInternalShareCreateManyNoteInputEnvelope
    connect?: noteInternalShareWhereUniqueInput | noteInternalShareWhereUniqueInput[]
  }

  export type attachmentsUncheckedCreateNestedManyWithoutNoteInput = {
    create?: XOR<attachmentsCreateWithoutNoteInput, attachmentsUncheckedCreateWithoutNoteInput> | attachmentsCreateWithoutNoteInput[] | attachmentsUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: attachmentsCreateOrConnectWithoutNoteInput | attachmentsCreateOrConnectWithoutNoteInput[]
    createMany?: attachmentsCreateManyNoteInputEnvelope
    connect?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
  }

  export type tagsToNoteUncheckedCreateNestedManyWithoutNoteInput = {
    create?: XOR<tagsToNoteCreateWithoutNoteInput, tagsToNoteUncheckedCreateWithoutNoteInput> | tagsToNoteCreateWithoutNoteInput[] | tagsToNoteUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: tagsToNoteCreateOrConnectWithoutNoteInput | tagsToNoteCreateOrConnectWithoutNoteInput[]
    createMany?: tagsToNoteCreateManyNoteInputEnvelope
    connect?: tagsToNoteWhereUniqueInput | tagsToNoteWhereUniqueInput[]
  }

  export type noteReferenceUncheckedCreateNestedManyWithoutToNoteInput = {
    create?: XOR<noteReferenceCreateWithoutToNoteInput, noteReferenceUncheckedCreateWithoutToNoteInput> | noteReferenceCreateWithoutToNoteInput[] | noteReferenceUncheckedCreateWithoutToNoteInput[]
    connectOrCreate?: noteReferenceCreateOrConnectWithoutToNoteInput | noteReferenceCreateOrConnectWithoutToNoteInput[]
    createMany?: noteReferenceCreateManyToNoteInputEnvelope
    connect?: noteReferenceWhereUniqueInput | noteReferenceWhereUniqueInput[]
  }

  export type noteReferenceUncheckedCreateNestedManyWithoutFromNoteInput = {
    create?: XOR<noteReferenceCreateWithoutFromNoteInput, noteReferenceUncheckedCreateWithoutFromNoteInput> | noteReferenceCreateWithoutFromNoteInput[] | noteReferenceUncheckedCreateWithoutFromNoteInput[]
    connectOrCreate?: noteReferenceCreateOrConnectWithoutFromNoteInput | noteReferenceCreateOrConnectWithoutFromNoteInput[]
    createMany?: noteReferenceCreateManyFromNoteInputEnvelope
    connect?: noteReferenceWhereUniqueInput | noteReferenceWhereUniqueInput[]
  }

  export type commentsUncheckedCreateNestedManyWithoutNoteInput = {
    create?: XOR<commentsCreateWithoutNoteInput, commentsUncheckedCreateWithoutNoteInput> | commentsCreateWithoutNoteInput[] | commentsUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutNoteInput | commentsCreateOrConnectWithoutNoteInput[]
    createMany?: commentsCreateManyNoteInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type noteHistoryUncheckedCreateNestedManyWithoutNoteInput = {
    create?: XOR<noteHistoryCreateWithoutNoteInput, noteHistoryUncheckedCreateWithoutNoteInput> | noteHistoryCreateWithoutNoteInput[] | noteHistoryUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: noteHistoryCreateOrConnectWithoutNoteInput | noteHistoryCreateOrConnectWithoutNoteInput[]
    createMany?: noteHistoryCreateManyNoteInputEnvelope
    connect?: noteHistoryWhereUniqueInput | noteHistoryWhereUniqueInput[]
  }

  export type noteInternalShareUncheckedCreateNestedManyWithoutNoteInput = {
    create?: XOR<noteInternalShareCreateWithoutNoteInput, noteInternalShareUncheckedCreateWithoutNoteInput> | noteInternalShareCreateWithoutNoteInput[] | noteInternalShareUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: noteInternalShareCreateOrConnectWithoutNoteInput | noteInternalShareCreateOrConnectWithoutNoteInput[]
    createMany?: noteInternalShareCreateManyNoteInputEnvelope
    connect?: noteInternalShareWhereUniqueInput | noteInternalShareWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type attachmentsUpdateManyWithoutNoteNestedInput = {
    create?: XOR<attachmentsCreateWithoutNoteInput, attachmentsUncheckedCreateWithoutNoteInput> | attachmentsCreateWithoutNoteInput[] | attachmentsUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: attachmentsCreateOrConnectWithoutNoteInput | attachmentsCreateOrConnectWithoutNoteInput[]
    upsert?: attachmentsUpsertWithWhereUniqueWithoutNoteInput | attachmentsUpsertWithWhereUniqueWithoutNoteInput[]
    createMany?: attachmentsCreateManyNoteInputEnvelope
    set?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
    disconnect?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
    delete?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
    connect?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
    update?: attachmentsUpdateWithWhereUniqueWithoutNoteInput | attachmentsUpdateWithWhereUniqueWithoutNoteInput[]
    updateMany?: attachmentsUpdateManyWithWhereWithoutNoteInput | attachmentsUpdateManyWithWhereWithoutNoteInput[]
    deleteMany?: attachmentsScalarWhereInput | attachmentsScalarWhereInput[]
  }

  export type tagsToNoteUpdateManyWithoutNoteNestedInput = {
    create?: XOR<tagsToNoteCreateWithoutNoteInput, tagsToNoteUncheckedCreateWithoutNoteInput> | tagsToNoteCreateWithoutNoteInput[] | tagsToNoteUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: tagsToNoteCreateOrConnectWithoutNoteInput | tagsToNoteCreateOrConnectWithoutNoteInput[]
    upsert?: tagsToNoteUpsertWithWhereUniqueWithoutNoteInput | tagsToNoteUpsertWithWhereUniqueWithoutNoteInput[]
    createMany?: tagsToNoteCreateManyNoteInputEnvelope
    set?: tagsToNoteWhereUniqueInput | tagsToNoteWhereUniqueInput[]
    disconnect?: tagsToNoteWhereUniqueInput | tagsToNoteWhereUniqueInput[]
    delete?: tagsToNoteWhereUniqueInput | tagsToNoteWhereUniqueInput[]
    connect?: tagsToNoteWhereUniqueInput | tagsToNoteWhereUniqueInput[]
    update?: tagsToNoteUpdateWithWhereUniqueWithoutNoteInput | tagsToNoteUpdateWithWhereUniqueWithoutNoteInput[]
    updateMany?: tagsToNoteUpdateManyWithWhereWithoutNoteInput | tagsToNoteUpdateManyWithWhereWithoutNoteInput[]
    deleteMany?: tagsToNoteScalarWhereInput | tagsToNoteScalarWhereInput[]
  }

  export type accountsUpdateOneWithoutNotesNestedInput = {
    create?: XOR<accountsCreateWithoutNotesInput, accountsUncheckedCreateWithoutNotesInput>
    connectOrCreate?: accountsCreateOrConnectWithoutNotesInput
    upsert?: accountsUpsertWithoutNotesInput
    disconnect?: accountsWhereInput | boolean
    delete?: accountsWhereInput | boolean
    connect?: accountsWhereUniqueInput
    update?: XOR<XOR<accountsUpdateToOneWithWhereWithoutNotesInput, accountsUpdateWithoutNotesInput>, accountsUncheckedUpdateWithoutNotesInput>
  }

  export type noteReferenceUpdateManyWithoutToNoteNestedInput = {
    create?: XOR<noteReferenceCreateWithoutToNoteInput, noteReferenceUncheckedCreateWithoutToNoteInput> | noteReferenceCreateWithoutToNoteInput[] | noteReferenceUncheckedCreateWithoutToNoteInput[]
    connectOrCreate?: noteReferenceCreateOrConnectWithoutToNoteInput | noteReferenceCreateOrConnectWithoutToNoteInput[]
    upsert?: noteReferenceUpsertWithWhereUniqueWithoutToNoteInput | noteReferenceUpsertWithWhereUniqueWithoutToNoteInput[]
    createMany?: noteReferenceCreateManyToNoteInputEnvelope
    set?: noteReferenceWhereUniqueInput | noteReferenceWhereUniqueInput[]
    disconnect?: noteReferenceWhereUniqueInput | noteReferenceWhereUniqueInput[]
    delete?: noteReferenceWhereUniqueInput | noteReferenceWhereUniqueInput[]
    connect?: noteReferenceWhereUniqueInput | noteReferenceWhereUniqueInput[]
    update?: noteReferenceUpdateWithWhereUniqueWithoutToNoteInput | noteReferenceUpdateWithWhereUniqueWithoutToNoteInput[]
    updateMany?: noteReferenceUpdateManyWithWhereWithoutToNoteInput | noteReferenceUpdateManyWithWhereWithoutToNoteInput[]
    deleteMany?: noteReferenceScalarWhereInput | noteReferenceScalarWhereInput[]
  }

  export type noteReferenceUpdateManyWithoutFromNoteNestedInput = {
    create?: XOR<noteReferenceCreateWithoutFromNoteInput, noteReferenceUncheckedCreateWithoutFromNoteInput> | noteReferenceCreateWithoutFromNoteInput[] | noteReferenceUncheckedCreateWithoutFromNoteInput[]
    connectOrCreate?: noteReferenceCreateOrConnectWithoutFromNoteInput | noteReferenceCreateOrConnectWithoutFromNoteInput[]
    upsert?: noteReferenceUpsertWithWhereUniqueWithoutFromNoteInput | noteReferenceUpsertWithWhereUniqueWithoutFromNoteInput[]
    createMany?: noteReferenceCreateManyFromNoteInputEnvelope
    set?: noteReferenceWhereUniqueInput | noteReferenceWhereUniqueInput[]
    disconnect?: noteReferenceWhereUniqueInput | noteReferenceWhereUniqueInput[]
    delete?: noteReferenceWhereUniqueInput | noteReferenceWhereUniqueInput[]
    connect?: noteReferenceWhereUniqueInput | noteReferenceWhereUniqueInput[]
    update?: noteReferenceUpdateWithWhereUniqueWithoutFromNoteInput | noteReferenceUpdateWithWhereUniqueWithoutFromNoteInput[]
    updateMany?: noteReferenceUpdateManyWithWhereWithoutFromNoteInput | noteReferenceUpdateManyWithWhereWithoutFromNoteInput[]
    deleteMany?: noteReferenceScalarWhereInput | noteReferenceScalarWhereInput[]
  }

  export type commentsUpdateManyWithoutNoteNestedInput = {
    create?: XOR<commentsCreateWithoutNoteInput, commentsUncheckedCreateWithoutNoteInput> | commentsCreateWithoutNoteInput[] | commentsUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutNoteInput | commentsCreateOrConnectWithoutNoteInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutNoteInput | commentsUpsertWithWhereUniqueWithoutNoteInput[]
    createMany?: commentsCreateManyNoteInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutNoteInput | commentsUpdateWithWhereUniqueWithoutNoteInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutNoteInput | commentsUpdateManyWithWhereWithoutNoteInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type noteHistoryUpdateManyWithoutNoteNestedInput = {
    create?: XOR<noteHistoryCreateWithoutNoteInput, noteHistoryUncheckedCreateWithoutNoteInput> | noteHistoryCreateWithoutNoteInput[] | noteHistoryUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: noteHistoryCreateOrConnectWithoutNoteInput | noteHistoryCreateOrConnectWithoutNoteInput[]
    upsert?: noteHistoryUpsertWithWhereUniqueWithoutNoteInput | noteHistoryUpsertWithWhereUniqueWithoutNoteInput[]
    createMany?: noteHistoryCreateManyNoteInputEnvelope
    set?: noteHistoryWhereUniqueInput | noteHistoryWhereUniqueInput[]
    disconnect?: noteHistoryWhereUniqueInput | noteHistoryWhereUniqueInput[]
    delete?: noteHistoryWhereUniqueInput | noteHistoryWhereUniqueInput[]
    connect?: noteHistoryWhereUniqueInput | noteHistoryWhereUniqueInput[]
    update?: noteHistoryUpdateWithWhereUniqueWithoutNoteInput | noteHistoryUpdateWithWhereUniqueWithoutNoteInput[]
    updateMany?: noteHistoryUpdateManyWithWhereWithoutNoteInput | noteHistoryUpdateManyWithWhereWithoutNoteInput[]
    deleteMany?: noteHistoryScalarWhereInput | noteHistoryScalarWhereInput[]
  }

  export type noteInternalShareUpdateManyWithoutNoteNestedInput = {
    create?: XOR<noteInternalShareCreateWithoutNoteInput, noteInternalShareUncheckedCreateWithoutNoteInput> | noteInternalShareCreateWithoutNoteInput[] | noteInternalShareUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: noteInternalShareCreateOrConnectWithoutNoteInput | noteInternalShareCreateOrConnectWithoutNoteInput[]
    upsert?: noteInternalShareUpsertWithWhereUniqueWithoutNoteInput | noteInternalShareUpsertWithWhereUniqueWithoutNoteInput[]
    createMany?: noteInternalShareCreateManyNoteInputEnvelope
    set?: noteInternalShareWhereUniqueInput | noteInternalShareWhereUniqueInput[]
    disconnect?: noteInternalShareWhereUniqueInput | noteInternalShareWhereUniqueInput[]
    delete?: noteInternalShareWhereUniqueInput | noteInternalShareWhereUniqueInput[]
    connect?: noteInternalShareWhereUniqueInput | noteInternalShareWhereUniqueInput[]
    update?: noteInternalShareUpdateWithWhereUniqueWithoutNoteInput | noteInternalShareUpdateWithWhereUniqueWithoutNoteInput[]
    updateMany?: noteInternalShareUpdateManyWithWhereWithoutNoteInput | noteInternalShareUpdateManyWithWhereWithoutNoteInput[]
    deleteMany?: noteInternalShareScalarWhereInput | noteInternalShareScalarWhereInput[]
  }

  export type attachmentsUncheckedUpdateManyWithoutNoteNestedInput = {
    create?: XOR<attachmentsCreateWithoutNoteInput, attachmentsUncheckedCreateWithoutNoteInput> | attachmentsCreateWithoutNoteInput[] | attachmentsUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: attachmentsCreateOrConnectWithoutNoteInput | attachmentsCreateOrConnectWithoutNoteInput[]
    upsert?: attachmentsUpsertWithWhereUniqueWithoutNoteInput | attachmentsUpsertWithWhereUniqueWithoutNoteInput[]
    createMany?: attachmentsCreateManyNoteInputEnvelope
    set?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
    disconnect?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
    delete?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
    connect?: attachmentsWhereUniqueInput | attachmentsWhereUniqueInput[]
    update?: attachmentsUpdateWithWhereUniqueWithoutNoteInput | attachmentsUpdateWithWhereUniqueWithoutNoteInput[]
    updateMany?: attachmentsUpdateManyWithWhereWithoutNoteInput | attachmentsUpdateManyWithWhereWithoutNoteInput[]
    deleteMany?: attachmentsScalarWhereInput | attachmentsScalarWhereInput[]
  }

  export type tagsToNoteUncheckedUpdateManyWithoutNoteNestedInput = {
    create?: XOR<tagsToNoteCreateWithoutNoteInput, tagsToNoteUncheckedCreateWithoutNoteInput> | tagsToNoteCreateWithoutNoteInput[] | tagsToNoteUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: tagsToNoteCreateOrConnectWithoutNoteInput | tagsToNoteCreateOrConnectWithoutNoteInput[]
    upsert?: tagsToNoteUpsertWithWhereUniqueWithoutNoteInput | tagsToNoteUpsertWithWhereUniqueWithoutNoteInput[]
    createMany?: tagsToNoteCreateManyNoteInputEnvelope
    set?: tagsToNoteWhereUniqueInput | tagsToNoteWhereUniqueInput[]
    disconnect?: tagsToNoteWhereUniqueInput | tagsToNoteWhereUniqueInput[]
    delete?: tagsToNoteWhereUniqueInput | tagsToNoteWhereUniqueInput[]
    connect?: tagsToNoteWhereUniqueInput | tagsToNoteWhereUniqueInput[]
    update?: tagsToNoteUpdateWithWhereUniqueWithoutNoteInput | tagsToNoteUpdateWithWhereUniqueWithoutNoteInput[]
    updateMany?: tagsToNoteUpdateManyWithWhereWithoutNoteInput | tagsToNoteUpdateManyWithWhereWithoutNoteInput[]
    deleteMany?: tagsToNoteScalarWhereInput | tagsToNoteScalarWhereInput[]
  }

  export type noteReferenceUncheckedUpdateManyWithoutToNoteNestedInput = {
    create?: XOR<noteReferenceCreateWithoutToNoteInput, noteReferenceUncheckedCreateWithoutToNoteInput> | noteReferenceCreateWithoutToNoteInput[] | noteReferenceUncheckedCreateWithoutToNoteInput[]
    connectOrCreate?: noteReferenceCreateOrConnectWithoutToNoteInput | noteReferenceCreateOrConnectWithoutToNoteInput[]
    upsert?: noteReferenceUpsertWithWhereUniqueWithoutToNoteInput | noteReferenceUpsertWithWhereUniqueWithoutToNoteInput[]
    createMany?: noteReferenceCreateManyToNoteInputEnvelope
    set?: noteReferenceWhereUniqueInput | noteReferenceWhereUniqueInput[]
    disconnect?: noteReferenceWhereUniqueInput | noteReferenceWhereUniqueInput[]
    delete?: noteReferenceWhereUniqueInput | noteReferenceWhereUniqueInput[]
    connect?: noteReferenceWhereUniqueInput | noteReferenceWhereUniqueInput[]
    update?: noteReferenceUpdateWithWhereUniqueWithoutToNoteInput | noteReferenceUpdateWithWhereUniqueWithoutToNoteInput[]
    updateMany?: noteReferenceUpdateManyWithWhereWithoutToNoteInput | noteReferenceUpdateManyWithWhereWithoutToNoteInput[]
    deleteMany?: noteReferenceScalarWhereInput | noteReferenceScalarWhereInput[]
  }

  export type noteReferenceUncheckedUpdateManyWithoutFromNoteNestedInput = {
    create?: XOR<noteReferenceCreateWithoutFromNoteInput, noteReferenceUncheckedCreateWithoutFromNoteInput> | noteReferenceCreateWithoutFromNoteInput[] | noteReferenceUncheckedCreateWithoutFromNoteInput[]
    connectOrCreate?: noteReferenceCreateOrConnectWithoutFromNoteInput | noteReferenceCreateOrConnectWithoutFromNoteInput[]
    upsert?: noteReferenceUpsertWithWhereUniqueWithoutFromNoteInput | noteReferenceUpsertWithWhereUniqueWithoutFromNoteInput[]
    createMany?: noteReferenceCreateManyFromNoteInputEnvelope
    set?: noteReferenceWhereUniqueInput | noteReferenceWhereUniqueInput[]
    disconnect?: noteReferenceWhereUniqueInput | noteReferenceWhereUniqueInput[]
    delete?: noteReferenceWhereUniqueInput | noteReferenceWhereUniqueInput[]
    connect?: noteReferenceWhereUniqueInput | noteReferenceWhereUniqueInput[]
    update?: noteReferenceUpdateWithWhereUniqueWithoutFromNoteInput | noteReferenceUpdateWithWhereUniqueWithoutFromNoteInput[]
    updateMany?: noteReferenceUpdateManyWithWhereWithoutFromNoteInput | noteReferenceUpdateManyWithWhereWithoutFromNoteInput[]
    deleteMany?: noteReferenceScalarWhereInput | noteReferenceScalarWhereInput[]
  }

  export type commentsUncheckedUpdateManyWithoutNoteNestedInput = {
    create?: XOR<commentsCreateWithoutNoteInput, commentsUncheckedCreateWithoutNoteInput> | commentsCreateWithoutNoteInput[] | commentsUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutNoteInput | commentsCreateOrConnectWithoutNoteInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutNoteInput | commentsUpsertWithWhereUniqueWithoutNoteInput[]
    createMany?: commentsCreateManyNoteInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutNoteInput | commentsUpdateWithWhereUniqueWithoutNoteInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutNoteInput | commentsUpdateManyWithWhereWithoutNoteInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type noteHistoryUncheckedUpdateManyWithoutNoteNestedInput = {
    create?: XOR<noteHistoryCreateWithoutNoteInput, noteHistoryUncheckedCreateWithoutNoteInput> | noteHistoryCreateWithoutNoteInput[] | noteHistoryUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: noteHistoryCreateOrConnectWithoutNoteInput | noteHistoryCreateOrConnectWithoutNoteInput[]
    upsert?: noteHistoryUpsertWithWhereUniqueWithoutNoteInput | noteHistoryUpsertWithWhereUniqueWithoutNoteInput[]
    createMany?: noteHistoryCreateManyNoteInputEnvelope
    set?: noteHistoryWhereUniqueInput | noteHistoryWhereUniqueInput[]
    disconnect?: noteHistoryWhereUniqueInput | noteHistoryWhereUniqueInput[]
    delete?: noteHistoryWhereUniqueInput | noteHistoryWhereUniqueInput[]
    connect?: noteHistoryWhereUniqueInput | noteHistoryWhereUniqueInput[]
    update?: noteHistoryUpdateWithWhereUniqueWithoutNoteInput | noteHistoryUpdateWithWhereUniqueWithoutNoteInput[]
    updateMany?: noteHistoryUpdateManyWithWhereWithoutNoteInput | noteHistoryUpdateManyWithWhereWithoutNoteInput[]
    deleteMany?: noteHistoryScalarWhereInput | noteHistoryScalarWhereInput[]
  }

  export type noteInternalShareUncheckedUpdateManyWithoutNoteNestedInput = {
    create?: XOR<noteInternalShareCreateWithoutNoteInput, noteInternalShareUncheckedCreateWithoutNoteInput> | noteInternalShareCreateWithoutNoteInput[] | noteInternalShareUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: noteInternalShareCreateOrConnectWithoutNoteInput | noteInternalShareCreateOrConnectWithoutNoteInput[]
    upsert?: noteInternalShareUpsertWithWhereUniqueWithoutNoteInput | noteInternalShareUpsertWithWhereUniqueWithoutNoteInput[]
    createMany?: noteInternalShareCreateManyNoteInputEnvelope
    set?: noteInternalShareWhereUniqueInput | noteInternalShareWhereUniqueInput[]
    disconnect?: noteInternalShareWhereUniqueInput | noteInternalShareWhereUniqueInput[]
    delete?: noteInternalShareWhereUniqueInput | noteInternalShareWhereUniqueInput[]
    connect?: noteInternalShareWhereUniqueInput | noteInternalShareWhereUniqueInput[]
    update?: noteInternalShareUpdateWithWhereUniqueWithoutNoteInput | noteInternalShareUpdateWithWhereUniqueWithoutNoteInput[]
    updateMany?: noteInternalShareUpdateManyWithWhereWithoutNoteInput | noteInternalShareUpdateManyWithWhereWithoutNoteInput[]
    deleteMany?: noteInternalShareScalarWhereInput | noteInternalShareScalarWhereInput[]
  }

  export type notesCreateNestedOneWithoutCommentsInput = {
    create?: XOR<notesCreateWithoutCommentsInput, notesUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: notesCreateOrConnectWithoutCommentsInput
    connect?: notesWhereUniqueInput
  }

  export type accountsCreateNestedOneWithoutCommentsInput = {
    create?: XOR<accountsCreateWithoutCommentsInput, accountsUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: accountsCreateOrConnectWithoutCommentsInput
    connect?: accountsWhereUniqueInput
  }

  export type commentsCreateNestedOneWithoutRepliesInput = {
    create?: XOR<commentsCreateWithoutRepliesInput, commentsUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: commentsCreateOrConnectWithoutRepliesInput
    connect?: commentsWhereUniqueInput
  }

  export type commentsCreateNestedManyWithoutParentInput = {
    create?: XOR<commentsCreateWithoutParentInput, commentsUncheckedCreateWithoutParentInput> | commentsCreateWithoutParentInput[] | commentsUncheckedCreateWithoutParentInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutParentInput | commentsCreateOrConnectWithoutParentInput[]
    createMany?: commentsCreateManyParentInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type commentsUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<commentsCreateWithoutParentInput, commentsUncheckedCreateWithoutParentInput> | commentsCreateWithoutParentInput[] | commentsUncheckedCreateWithoutParentInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutParentInput | commentsCreateOrConnectWithoutParentInput[]
    createMany?: commentsCreateManyParentInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type notesUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<notesCreateWithoutCommentsInput, notesUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: notesCreateOrConnectWithoutCommentsInput
    upsert?: notesUpsertWithoutCommentsInput
    connect?: notesWhereUniqueInput
    update?: XOR<XOR<notesUpdateToOneWithWhereWithoutCommentsInput, notesUpdateWithoutCommentsInput>, notesUncheckedUpdateWithoutCommentsInput>
  }

  export type accountsUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<accountsCreateWithoutCommentsInput, accountsUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: accountsCreateOrConnectWithoutCommentsInput
    upsert?: accountsUpsertWithoutCommentsInput
    disconnect?: accountsWhereInput | boolean
    delete?: accountsWhereInput | boolean
    connect?: accountsWhereUniqueInput
    update?: XOR<XOR<accountsUpdateToOneWithWhereWithoutCommentsInput, accountsUpdateWithoutCommentsInput>, accountsUncheckedUpdateWithoutCommentsInput>
  }

  export type commentsUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<commentsCreateWithoutRepliesInput, commentsUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: commentsCreateOrConnectWithoutRepliesInput
    upsert?: commentsUpsertWithoutRepliesInput
    disconnect?: commentsWhereInput | boolean
    delete?: commentsWhereInput | boolean
    connect?: commentsWhereUniqueInput
    update?: XOR<XOR<commentsUpdateToOneWithWhereWithoutRepliesInput, commentsUpdateWithoutRepliesInput>, commentsUncheckedUpdateWithoutRepliesInput>
  }

  export type commentsUpdateManyWithoutParentNestedInput = {
    create?: XOR<commentsCreateWithoutParentInput, commentsUncheckedCreateWithoutParentInput> | commentsCreateWithoutParentInput[] | commentsUncheckedCreateWithoutParentInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutParentInput | commentsCreateOrConnectWithoutParentInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutParentInput | commentsUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: commentsCreateManyParentInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutParentInput | commentsUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutParentInput | commentsUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type commentsUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<commentsCreateWithoutParentInput, commentsUncheckedCreateWithoutParentInput> | commentsCreateWithoutParentInput[] | commentsUncheckedCreateWithoutParentInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutParentInput | commentsCreateOrConnectWithoutParentInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutParentInput | commentsUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: commentsCreateManyParentInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutParentInput | commentsUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutParentInput | commentsUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type tagsToNoteCreateNestedManyWithoutTagInput = {
    create?: XOR<tagsToNoteCreateWithoutTagInput, tagsToNoteUncheckedCreateWithoutTagInput> | tagsToNoteCreateWithoutTagInput[] | tagsToNoteUncheckedCreateWithoutTagInput[]
    connectOrCreate?: tagsToNoteCreateOrConnectWithoutTagInput | tagsToNoteCreateOrConnectWithoutTagInput[]
    createMany?: tagsToNoteCreateManyTagInputEnvelope
    connect?: tagsToNoteWhereUniqueInput | tagsToNoteWhereUniqueInput[]
  }

  export type accountsCreateNestedOneWithoutTagsInput = {
    create?: XOR<accountsCreateWithoutTagsInput, accountsUncheckedCreateWithoutTagsInput>
    connectOrCreate?: accountsCreateOrConnectWithoutTagsInput
    connect?: accountsWhereUniqueInput
  }

  export type tagsToNoteUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<tagsToNoteCreateWithoutTagInput, tagsToNoteUncheckedCreateWithoutTagInput> | tagsToNoteCreateWithoutTagInput[] | tagsToNoteUncheckedCreateWithoutTagInput[]
    connectOrCreate?: tagsToNoteCreateOrConnectWithoutTagInput | tagsToNoteCreateOrConnectWithoutTagInput[]
    createMany?: tagsToNoteCreateManyTagInputEnvelope
    connect?: tagsToNoteWhereUniqueInput | tagsToNoteWhereUniqueInput[]
  }

  export type tagsToNoteUpdateManyWithoutTagNestedInput = {
    create?: XOR<tagsToNoteCreateWithoutTagInput, tagsToNoteUncheckedCreateWithoutTagInput> | tagsToNoteCreateWithoutTagInput[] | tagsToNoteUncheckedCreateWithoutTagInput[]
    connectOrCreate?: tagsToNoteCreateOrConnectWithoutTagInput | tagsToNoteCreateOrConnectWithoutTagInput[]
    upsert?: tagsToNoteUpsertWithWhereUniqueWithoutTagInput | tagsToNoteUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: tagsToNoteCreateManyTagInputEnvelope
    set?: tagsToNoteWhereUniqueInput | tagsToNoteWhereUniqueInput[]
    disconnect?: tagsToNoteWhereUniqueInput | tagsToNoteWhereUniqueInput[]
    delete?: tagsToNoteWhereUniqueInput | tagsToNoteWhereUniqueInput[]
    connect?: tagsToNoteWhereUniqueInput | tagsToNoteWhereUniqueInput[]
    update?: tagsToNoteUpdateWithWhereUniqueWithoutTagInput | tagsToNoteUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: tagsToNoteUpdateManyWithWhereWithoutTagInput | tagsToNoteUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: tagsToNoteScalarWhereInput | tagsToNoteScalarWhereInput[]
  }

  export type accountsUpdateOneWithoutTagsNestedInput = {
    create?: XOR<accountsCreateWithoutTagsInput, accountsUncheckedCreateWithoutTagsInput>
    connectOrCreate?: accountsCreateOrConnectWithoutTagsInput
    upsert?: accountsUpsertWithoutTagsInput
    disconnect?: accountsWhereInput | boolean
    delete?: accountsWhereInput | boolean
    connect?: accountsWhereUniqueInput
    update?: XOR<XOR<accountsUpdateToOneWithWhereWithoutTagsInput, accountsUpdateWithoutTagsInput>, accountsUncheckedUpdateWithoutTagsInput>
  }

  export type tagsToNoteUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<tagsToNoteCreateWithoutTagInput, tagsToNoteUncheckedCreateWithoutTagInput> | tagsToNoteCreateWithoutTagInput[] | tagsToNoteUncheckedCreateWithoutTagInput[]
    connectOrCreate?: tagsToNoteCreateOrConnectWithoutTagInput | tagsToNoteCreateOrConnectWithoutTagInput[]
    upsert?: tagsToNoteUpsertWithWhereUniqueWithoutTagInput | tagsToNoteUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: tagsToNoteCreateManyTagInputEnvelope
    set?: tagsToNoteWhereUniqueInput | tagsToNoteWhereUniqueInput[]
    disconnect?: tagsToNoteWhereUniqueInput | tagsToNoteWhereUniqueInput[]
    delete?: tagsToNoteWhereUniqueInput | tagsToNoteWhereUniqueInput[]
    connect?: tagsToNoteWhereUniqueInput | tagsToNoteWhereUniqueInput[]
    update?: tagsToNoteUpdateWithWhereUniqueWithoutTagInput | tagsToNoteUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: tagsToNoteUpdateManyWithWhereWithoutTagInput | tagsToNoteUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: tagsToNoteScalarWhereInput | tagsToNoteScalarWhereInput[]
  }

  export type notesCreateNestedOneWithoutTagsInput = {
    create?: XOR<notesCreateWithoutTagsInput, notesUncheckedCreateWithoutTagsInput>
    connectOrCreate?: notesCreateOrConnectWithoutTagsInput
    connect?: notesWhereUniqueInput
  }

  export type tagCreateNestedOneWithoutTagsToNoteInput = {
    create?: XOR<tagCreateWithoutTagsToNoteInput, tagUncheckedCreateWithoutTagsToNoteInput>
    connectOrCreate?: tagCreateOrConnectWithoutTagsToNoteInput
    connect?: tagWhereUniqueInput
  }

  export type notesUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<notesCreateWithoutTagsInput, notesUncheckedCreateWithoutTagsInput>
    connectOrCreate?: notesCreateOrConnectWithoutTagsInput
    upsert?: notesUpsertWithoutTagsInput
    connect?: notesWhereUniqueInput
    update?: XOR<XOR<notesUpdateToOneWithWhereWithoutTagsInput, notesUpdateWithoutTagsInput>, notesUncheckedUpdateWithoutTagsInput>
  }

  export type tagUpdateOneRequiredWithoutTagsToNoteNestedInput = {
    create?: XOR<tagCreateWithoutTagsToNoteInput, tagUncheckedCreateWithoutTagsToNoteInput>
    connectOrCreate?: tagCreateOrConnectWithoutTagsToNoteInput
    upsert?: tagUpsertWithoutTagsToNoteInput
    connect?: tagWhereUniqueInput
    update?: XOR<XOR<tagUpdateToOneWithWhereWithoutTagsToNoteInput, tagUpdateWithoutTagsToNoteInput>, tagUncheckedUpdateWithoutTagsToNoteInput>
  }

  export type notesCreateNestedOneWithoutReferencesInput = {
    create?: XOR<notesCreateWithoutReferencesInput, notesUncheckedCreateWithoutReferencesInput>
    connectOrCreate?: notesCreateOrConnectWithoutReferencesInput
    connect?: notesWhereUniqueInput
  }

  export type notesCreateNestedOneWithoutReferencedByInput = {
    create?: XOR<notesCreateWithoutReferencedByInput, notesUncheckedCreateWithoutReferencedByInput>
    connectOrCreate?: notesCreateOrConnectWithoutReferencedByInput
    connect?: notesWhereUniqueInput
  }

  export type notesUpdateOneRequiredWithoutReferencesNestedInput = {
    create?: XOR<notesCreateWithoutReferencesInput, notesUncheckedCreateWithoutReferencesInput>
    connectOrCreate?: notesCreateOrConnectWithoutReferencesInput
    upsert?: notesUpsertWithoutReferencesInput
    connect?: notesWhereUniqueInput
    update?: XOR<XOR<notesUpdateToOneWithWhereWithoutReferencesInput, notesUpdateWithoutReferencesInput>, notesUncheckedUpdateWithoutReferencesInput>
  }

  export type notesUpdateOneRequiredWithoutReferencedByNestedInput = {
    create?: XOR<notesCreateWithoutReferencedByInput, notesUncheckedCreateWithoutReferencedByInput>
    connectOrCreate?: notesCreateOrConnectWithoutReferencedByInput
    upsert?: notesUpsertWithoutReferencedByInput
    connect?: notesWhereUniqueInput
    update?: XOR<XOR<notesUpdateToOneWithWhereWithoutReferencedByInput, notesUpdateWithoutReferencedByInput>, notesUncheckedUpdateWithoutReferencedByInput>
  }

  export type accountsCreateNestedOneWithoutFollowsInput = {
    create?: XOR<accountsCreateWithoutFollowsInput, accountsUncheckedCreateWithoutFollowsInput>
    connectOrCreate?: accountsCreateOrConnectWithoutFollowsInput
    connect?: accountsWhereUniqueInput
  }

  export type accountsUpdateOneRequiredWithoutFollowsNestedInput = {
    create?: XOR<accountsCreateWithoutFollowsInput, accountsUncheckedCreateWithoutFollowsInput>
    connectOrCreate?: accountsCreateOrConnectWithoutFollowsInput
    upsert?: accountsUpsertWithoutFollowsInput
    connect?: accountsWhereUniqueInput
    update?: XOR<XOR<accountsUpdateToOneWithWhereWithoutFollowsInput, accountsUpdateWithoutFollowsInput>, accountsUncheckedUpdateWithoutFollowsInput>
  }

  export type accountsCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<accountsCreateWithoutNotificationsInput, accountsUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: accountsCreateOrConnectWithoutNotificationsInput
    connect?: accountsWhereUniqueInput
  }

  export type accountsUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<accountsCreateWithoutNotificationsInput, accountsUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: accountsCreateOrConnectWithoutNotificationsInput
    upsert?: accountsUpsertWithoutNotificationsInput
    connect?: accountsWhereUniqueInput
    update?: XOR<XOR<accountsUpdateToOneWithWhereWithoutNotificationsInput, accountsUpdateWithoutNotificationsInput>, accountsUncheckedUpdateWithoutNotificationsInput>
  }

  export type messageCreateNestedManyWithoutConversationInput = {
    create?: XOR<messageCreateWithoutConversationInput, messageUncheckedCreateWithoutConversationInput> | messageCreateWithoutConversationInput[] | messageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: messageCreateOrConnectWithoutConversationInput | messageCreateOrConnectWithoutConversationInput[]
    createMany?: messageCreateManyConversationInputEnvelope
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
  }

  export type accountsCreateNestedOneWithoutConversationsInput = {
    create?: XOR<accountsCreateWithoutConversationsInput, accountsUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: accountsCreateOrConnectWithoutConversationsInput
    connect?: accountsWhereUniqueInput
  }

  export type messageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<messageCreateWithoutConversationInput, messageUncheckedCreateWithoutConversationInput> | messageCreateWithoutConversationInput[] | messageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: messageCreateOrConnectWithoutConversationInput | messageCreateOrConnectWithoutConversationInput[]
    createMany?: messageCreateManyConversationInputEnvelope
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
  }

  export type messageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<messageCreateWithoutConversationInput, messageUncheckedCreateWithoutConversationInput> | messageCreateWithoutConversationInput[] | messageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: messageCreateOrConnectWithoutConversationInput | messageCreateOrConnectWithoutConversationInput[]
    upsert?: messageUpsertWithWhereUniqueWithoutConversationInput | messageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: messageCreateManyConversationInputEnvelope
    set?: messageWhereUniqueInput | messageWhereUniqueInput[]
    disconnect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    delete?: messageWhereUniqueInput | messageWhereUniqueInput[]
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    update?: messageUpdateWithWhereUniqueWithoutConversationInput | messageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: messageUpdateManyWithWhereWithoutConversationInput | messageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: messageScalarWhereInput | messageScalarWhereInput[]
  }

  export type accountsUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<accountsCreateWithoutConversationsInput, accountsUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: accountsCreateOrConnectWithoutConversationsInput
    upsert?: accountsUpsertWithoutConversationsInput
    connect?: accountsWhereUniqueInput
    update?: XOR<XOR<accountsUpdateToOneWithWhereWithoutConversationsInput, accountsUpdateWithoutConversationsInput>, accountsUncheckedUpdateWithoutConversationsInput>
  }

  export type messageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<messageCreateWithoutConversationInput, messageUncheckedCreateWithoutConversationInput> | messageCreateWithoutConversationInput[] | messageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: messageCreateOrConnectWithoutConversationInput | messageCreateOrConnectWithoutConversationInput[]
    upsert?: messageUpsertWithWhereUniqueWithoutConversationInput | messageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: messageCreateManyConversationInputEnvelope
    set?: messageWhereUniqueInput | messageWhereUniqueInput[]
    disconnect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    delete?: messageWhereUniqueInput | messageWhereUniqueInput[]
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    update?: messageUpdateWithWhereUniqueWithoutConversationInput | messageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: messageUpdateManyWithWhereWithoutConversationInput | messageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: messageScalarWhereInput | messageScalarWhereInput[]
  }

  export type conversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<conversationCreateWithoutMessagesInput, conversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: conversationCreateOrConnectWithoutMessagesInput
    connect?: conversationWhereUniqueInput
  }

  export type conversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<conversationCreateWithoutMessagesInput, conversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: conversationCreateOrConnectWithoutMessagesInput
    upsert?: conversationUpsertWithoutMessagesInput
    connect?: conversationWhereUniqueInput
    update?: XOR<XOR<conversationUpdateToOneWithWhereWithoutMessagesInput, conversationUpdateWithoutMessagesInput>, conversationUncheckedUpdateWithoutMessagesInput>
  }

  export type notesCreateNestedOneWithoutHistoriesInput = {
    create?: XOR<notesCreateWithoutHistoriesInput, notesUncheckedCreateWithoutHistoriesInput>
    connectOrCreate?: notesCreateOrConnectWithoutHistoriesInput
    connect?: notesWhereUniqueInput
  }

  export type notesUpdateOneRequiredWithoutHistoriesNestedInput = {
    create?: XOR<notesCreateWithoutHistoriesInput, notesUncheckedCreateWithoutHistoriesInput>
    connectOrCreate?: notesCreateOrConnectWithoutHistoriesInput
    upsert?: notesUpsertWithoutHistoriesInput
    connect?: notesWhereUniqueInput
    update?: XOR<XOR<notesUpdateToOneWithWhereWithoutHistoriesInput, notesUpdateWithoutHistoriesInput>, notesUncheckedUpdateWithoutHistoriesInput>
  }

  export type notesCreateNestedOneWithoutInternalSharesInput = {
    create?: XOR<notesCreateWithoutInternalSharesInput, notesUncheckedCreateWithoutInternalSharesInput>
    connectOrCreate?: notesCreateOrConnectWithoutInternalSharesInput
    connect?: notesWhereUniqueInput
  }

  export type accountsCreateNestedOneWithoutSharedNotesInput = {
    create?: XOR<accountsCreateWithoutSharedNotesInput, accountsUncheckedCreateWithoutSharedNotesInput>
    connectOrCreate?: accountsCreateOrConnectWithoutSharedNotesInput
    connect?: accountsWhereUniqueInput
  }

  export type notesUpdateOneRequiredWithoutInternalSharesNestedInput = {
    create?: XOR<notesCreateWithoutInternalSharesInput, notesUncheckedCreateWithoutInternalSharesInput>
    connectOrCreate?: notesCreateOrConnectWithoutInternalSharesInput
    upsert?: notesUpsertWithoutInternalSharesInput
    connect?: notesWhereUniqueInput
    update?: XOR<XOR<notesUpdateToOneWithWhereWithoutInternalSharesInput, notesUpdateWithoutInternalSharesInput>, notesUncheckedUpdateWithoutInternalSharesInput>
  }

  export type accountsUpdateOneRequiredWithoutSharedNotesNestedInput = {
    create?: XOR<accountsCreateWithoutSharedNotesInput, accountsUncheckedCreateWithoutSharedNotesInput>
    connectOrCreate?: accountsCreateOrConnectWithoutSharedNotesInput
    upsert?: accountsUpsertWithoutSharedNotesInput
    connect?: accountsWhereUniqueInput
    update?: XOR<XOR<accountsUpdateToOneWithWhereWithoutSharedNotesInput, accountsUpdateWithoutSharedNotesInput>, accountsUncheckedUpdateWithoutSharedNotesInput>
  }

  export type aiModelsCreateNestedManyWithoutProviderInput = {
    create?: XOR<aiModelsCreateWithoutProviderInput, aiModelsUncheckedCreateWithoutProviderInput> | aiModelsCreateWithoutProviderInput[] | aiModelsUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: aiModelsCreateOrConnectWithoutProviderInput | aiModelsCreateOrConnectWithoutProviderInput[]
    createMany?: aiModelsCreateManyProviderInputEnvelope
    connect?: aiModelsWhereUniqueInput | aiModelsWhereUniqueInput[]
  }

  export type aiModelsUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<aiModelsCreateWithoutProviderInput, aiModelsUncheckedCreateWithoutProviderInput> | aiModelsCreateWithoutProviderInput[] | aiModelsUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: aiModelsCreateOrConnectWithoutProviderInput | aiModelsCreateOrConnectWithoutProviderInput[]
    createMany?: aiModelsCreateManyProviderInputEnvelope
    connect?: aiModelsWhereUniqueInput | aiModelsWhereUniqueInput[]
  }

  export type aiModelsUpdateManyWithoutProviderNestedInput = {
    create?: XOR<aiModelsCreateWithoutProviderInput, aiModelsUncheckedCreateWithoutProviderInput> | aiModelsCreateWithoutProviderInput[] | aiModelsUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: aiModelsCreateOrConnectWithoutProviderInput | aiModelsCreateOrConnectWithoutProviderInput[]
    upsert?: aiModelsUpsertWithWhereUniqueWithoutProviderInput | aiModelsUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: aiModelsCreateManyProviderInputEnvelope
    set?: aiModelsWhereUniqueInput | aiModelsWhereUniqueInput[]
    disconnect?: aiModelsWhereUniqueInput | aiModelsWhereUniqueInput[]
    delete?: aiModelsWhereUniqueInput | aiModelsWhereUniqueInput[]
    connect?: aiModelsWhereUniqueInput | aiModelsWhereUniqueInput[]
    update?: aiModelsUpdateWithWhereUniqueWithoutProviderInput | aiModelsUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: aiModelsUpdateManyWithWhereWithoutProviderInput | aiModelsUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: aiModelsScalarWhereInput | aiModelsScalarWhereInput[]
  }

  export type aiModelsUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<aiModelsCreateWithoutProviderInput, aiModelsUncheckedCreateWithoutProviderInput> | aiModelsCreateWithoutProviderInput[] | aiModelsUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: aiModelsCreateOrConnectWithoutProviderInput | aiModelsCreateOrConnectWithoutProviderInput[]
    upsert?: aiModelsUpsertWithWhereUniqueWithoutProviderInput | aiModelsUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: aiModelsCreateManyProviderInputEnvelope
    set?: aiModelsWhereUniqueInput | aiModelsWhereUniqueInput[]
    disconnect?: aiModelsWhereUniqueInput | aiModelsWhereUniqueInput[]
    delete?: aiModelsWhereUniqueInput | aiModelsWhereUniqueInput[]
    connect?: aiModelsWhereUniqueInput | aiModelsWhereUniqueInput[]
    update?: aiModelsUpdateWithWhereUniqueWithoutProviderInput | aiModelsUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: aiModelsUpdateManyWithWhereWithoutProviderInput | aiModelsUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: aiModelsScalarWhereInput | aiModelsScalarWhereInput[]
  }

  export type aiProvidersCreateNestedOneWithoutModelsInput = {
    create?: XOR<aiProvidersCreateWithoutModelsInput, aiProvidersUncheckedCreateWithoutModelsInput>
    connectOrCreate?: aiProvidersCreateOrConnectWithoutModelsInput
    connect?: aiProvidersWhereUniqueInput
  }

  export type aiProvidersUpdateOneRequiredWithoutModelsNestedInput = {
    create?: XOR<aiProvidersCreateWithoutModelsInput, aiProvidersUncheckedCreateWithoutModelsInput>
    connectOrCreate?: aiProvidersCreateOrConnectWithoutModelsInput
    upsert?: aiProvidersUpsertWithoutModelsInput
    connect?: aiProvidersWhereUniqueInput
    update?: XOR<XOR<aiProvidersUpdateToOneWithWhereWithoutModelsInput, aiProvidersUpdateWithoutModelsInput>, aiProvidersUncheckedUpdateWithoutModelsInput>
  }

  export type accountsCreateNestedOneWithoutAiScheduledTasksInput = {
    create?: XOR<accountsCreateWithoutAiScheduledTasksInput, accountsUncheckedCreateWithoutAiScheduledTasksInput>
    connectOrCreate?: accountsCreateOrConnectWithoutAiScheduledTasksInput
    connect?: accountsWhereUniqueInput
  }

  export type accountsUpdateOneRequiredWithoutAiScheduledTasksNestedInput = {
    create?: XOR<accountsCreateWithoutAiScheduledTasksInput, accountsUncheckedCreateWithoutAiScheduledTasksInput>
    connectOrCreate?: accountsCreateOrConnectWithoutAiScheduledTasksInput
    upsert?: accountsUpsertWithoutAiScheduledTasksInput
    connect?: accountsWhereUniqueInput
    update?: XOR<XOR<accountsUpdateToOneWithWhereWithoutAiScheduledTasksInput, accountsUpdateWithoutAiScheduledTasksInput>, accountsUncheckedUpdateWithoutAiScheduledTasksInput>
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Bytes | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Bytes | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Bytes | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type notesCreateWithoutAccountInput = {
    type?: number
    content?: string
    isArchived?: boolean
    isRecycle?: boolean
    isShare?: boolean
    isTop?: boolean
    isReviewed?: boolean
    sharePassword?: string
    shareEncryptedUrl?: string | null
    shareExpiryDate?: Date | string | null
    shareMaxView?: number | null
    shareViewCount?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: attachmentsCreateNestedManyWithoutNoteInput
    tags?: tagsToNoteCreateNestedManyWithoutNoteInput
    referencedBy?: noteReferenceCreateNestedManyWithoutToNoteInput
    references?: noteReferenceCreateNestedManyWithoutFromNoteInput
    comments?: commentsCreateNestedManyWithoutNoteInput
    histories?: noteHistoryCreateNestedManyWithoutNoteInput
    internalShares?: noteInternalShareCreateNestedManyWithoutNoteInput
  }

  export type notesUncheckedCreateWithoutAccountInput = {
    id?: number
    type?: number
    content?: string
    isArchived?: boolean
    isRecycle?: boolean
    isShare?: boolean
    isTop?: boolean
    isReviewed?: boolean
    sharePassword?: string
    shareEncryptedUrl?: string | null
    shareExpiryDate?: Date | string | null
    shareMaxView?: number | null
    shareViewCount?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: attachmentsUncheckedCreateNestedManyWithoutNoteInput
    tags?: tagsToNoteUncheckedCreateNestedManyWithoutNoteInput
    referencedBy?: noteReferenceUncheckedCreateNestedManyWithoutToNoteInput
    references?: noteReferenceUncheckedCreateNestedManyWithoutFromNoteInput
    comments?: commentsUncheckedCreateNestedManyWithoutNoteInput
    histories?: noteHistoryUncheckedCreateNestedManyWithoutNoteInput
    internalShares?: noteInternalShareUncheckedCreateNestedManyWithoutNoteInput
  }

  export type notesCreateOrConnectWithoutAccountInput = {
    where: notesWhereUniqueInput
    create: XOR<notesCreateWithoutAccountInput, notesUncheckedCreateWithoutAccountInput>
  }

  export type notesCreateManyAccountInputEnvelope = {
    data: notesCreateManyAccountInput | notesCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type configCreateWithoutUserInput = {
    key?: string
    config?: NullableJsonNullValueInput | InputJsonValue
  }

  export type configUncheckedCreateWithoutUserInput = {
    id?: number
    key?: string
    config?: NullableJsonNullValueInput | InputJsonValue
  }

  export type configCreateOrConnectWithoutUserInput = {
    where: configWhereUniqueInput
    create: XOR<configCreateWithoutUserInput, configUncheckedCreateWithoutUserInput>
  }

  export type configCreateManyUserInputEnvelope = {
    data: configCreateManyUserInput | configCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type tagCreateWithoutAccountInput = {
    name?: string
    icon?: string
    parent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sortOrder?: number
    tagsToNote?: tagsToNoteCreateNestedManyWithoutTagInput
  }

  export type tagUncheckedCreateWithoutAccountInput = {
    id?: number
    name?: string
    icon?: string
    parent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sortOrder?: number
    tagsToNote?: tagsToNoteUncheckedCreateNestedManyWithoutTagInput
  }

  export type tagCreateOrConnectWithoutAccountInput = {
    where: tagWhereUniqueInput
    create: XOR<tagCreateWithoutAccountInput, tagUncheckedCreateWithoutAccountInput>
  }

  export type tagCreateManyAccountInputEnvelope = {
    data: tagCreateManyAccountInput | tagCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type commentsCreateWithoutAccountInput = {
    content: string
    guestName?: string | null
    guestIP?: string | null
    guestUA?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    note: notesCreateNestedOneWithoutCommentsInput
    parent?: commentsCreateNestedOneWithoutRepliesInput
    replies?: commentsCreateNestedManyWithoutParentInput
  }

  export type commentsUncheckedCreateWithoutAccountInput = {
    id?: number
    content: string
    guestName?: string | null
    guestIP?: string | null
    guestUA?: string | null
    noteId: number
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: commentsUncheckedCreateNestedManyWithoutParentInput
  }

  export type commentsCreateOrConnectWithoutAccountInput = {
    where: commentsWhereUniqueInput
    create: XOR<commentsCreateWithoutAccountInput, commentsUncheckedCreateWithoutAccountInput>
  }

  export type commentsCreateManyAccountInputEnvelope = {
    data: commentsCreateManyAccountInput | commentsCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type attachmentsCreateWithoutAccountInput = {
    isShare?: boolean
    sharePassword?: string
    name?: string
    path?: string
    size?: Decimal | DecimalJsLike | number | string
    type?: string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    perfixPath?: string | null
    depth?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    note?: notesCreateNestedOneWithoutAttachmentsInput
  }

  export type attachmentsUncheckedCreateWithoutAccountInput = {
    id?: number
    isShare?: boolean
    sharePassword?: string
    name?: string
    path?: string
    size?: Decimal | DecimalJsLike | number | string
    type?: string
    noteId?: number | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    perfixPath?: string | null
    depth?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type attachmentsCreateOrConnectWithoutAccountInput = {
    where: attachmentsWhereUniqueInput
    create: XOR<attachmentsCreateWithoutAccountInput, attachmentsUncheckedCreateWithoutAccountInput>
  }

  export type attachmentsCreateManyAccountInputEnvelope = {
    data: attachmentsCreateManyAccountInput | attachmentsCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type followsCreateWithoutAccountInput = {
    siteName?: string | null
    siteUrl: string
    siteAvatar?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    followType?: string
  }

  export type followsUncheckedCreateWithoutAccountInput = {
    id?: number
    siteName?: string | null
    siteUrl: string
    siteAvatar?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    followType?: string
  }

  export type followsCreateOrConnectWithoutAccountInput = {
    where: followsWhereUniqueInput
    create: XOR<followsCreateWithoutAccountInput, followsUncheckedCreateWithoutAccountInput>
  }

  export type followsCreateManyAccountInputEnvelope = {
    data: followsCreateManyAccountInput | followsCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type notificationsCreateWithoutAccountInput = {
    type: string
    title: string
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type notificationsUncheckedCreateWithoutAccountInput = {
    id?: number
    type: string
    title: string
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type notificationsCreateOrConnectWithoutAccountInput = {
    where: notificationsWhereUniqueInput
    create: XOR<notificationsCreateWithoutAccountInput, notificationsUncheckedCreateWithoutAccountInput>
  }

  export type notificationsCreateManyAccountInputEnvelope = {
    data: notificationsCreateManyAccountInput | notificationsCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type conversationCreateWithoutAccountInput = {
    title?: string
    isShare?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: messageCreateNestedManyWithoutConversationInput
  }

  export type conversationUncheckedCreateWithoutAccountInput = {
    id?: number
    title?: string
    isShare?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: messageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type conversationCreateOrConnectWithoutAccountInput = {
    where: conversationWhereUniqueInput
    create: XOR<conversationCreateWithoutAccountInput, conversationUncheckedCreateWithoutAccountInput>
  }

  export type conversationCreateManyAccountInputEnvelope = {
    data: conversationCreateManyAccountInput | conversationCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type noteInternalShareCreateWithoutAccountInput = {
    canEdit?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    note: notesCreateNestedOneWithoutInternalSharesInput
  }

  export type noteInternalShareUncheckedCreateWithoutAccountInput = {
    id?: number
    noteId: number
    canEdit?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type noteInternalShareCreateOrConnectWithoutAccountInput = {
    where: noteInternalShareWhereUniqueInput
    create: XOR<noteInternalShareCreateWithoutAccountInput, noteInternalShareUncheckedCreateWithoutAccountInput>
  }

  export type noteInternalShareCreateManyAccountInputEnvelope = {
    data: noteInternalShareCreateManyAccountInput | noteInternalShareCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type aiScheduledTaskCreateWithoutAccountInput = {
    name: string
    prompt: string
    schedule: string
    isEnabled?: boolean
    lastRun?: Date | string | null
    lastResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type aiScheduledTaskUncheckedCreateWithoutAccountInput = {
    id?: number
    name: string
    prompt: string
    schedule: string
    isEnabled?: boolean
    lastRun?: Date | string | null
    lastResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type aiScheduledTaskCreateOrConnectWithoutAccountInput = {
    where: aiScheduledTaskWhereUniqueInput
    create: XOR<aiScheduledTaskCreateWithoutAccountInput, aiScheduledTaskUncheckedCreateWithoutAccountInput>
  }

  export type aiScheduledTaskCreateManyAccountInputEnvelope = {
    data: aiScheduledTaskCreateManyAccountInput | aiScheduledTaskCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type notesUpsertWithWhereUniqueWithoutAccountInput = {
    where: notesWhereUniqueInput
    update: XOR<notesUpdateWithoutAccountInput, notesUncheckedUpdateWithoutAccountInput>
    create: XOR<notesCreateWithoutAccountInput, notesUncheckedCreateWithoutAccountInput>
  }

  export type notesUpdateWithWhereUniqueWithoutAccountInput = {
    where: notesWhereUniqueInput
    data: XOR<notesUpdateWithoutAccountInput, notesUncheckedUpdateWithoutAccountInput>
  }

  export type notesUpdateManyWithWhereWithoutAccountInput = {
    where: notesScalarWhereInput
    data: XOR<notesUpdateManyMutationInput, notesUncheckedUpdateManyWithoutAccountInput>
  }

  export type notesScalarWhereInput = {
    AND?: notesScalarWhereInput | notesScalarWhereInput[]
    OR?: notesScalarWhereInput[]
    NOT?: notesScalarWhereInput | notesScalarWhereInput[]
    id?: IntFilter<"notes"> | number
    type?: IntFilter<"notes"> | number
    content?: StringFilter<"notes"> | string
    isArchived?: BoolFilter<"notes"> | boolean
    isRecycle?: BoolFilter<"notes"> | boolean
    isShare?: BoolFilter<"notes"> | boolean
    isTop?: BoolFilter<"notes"> | boolean
    isReviewed?: BoolFilter<"notes"> | boolean
    sharePassword?: StringFilter<"notes"> | string
    shareEncryptedUrl?: StringNullableFilter<"notes"> | string | null
    shareExpiryDate?: DateTimeNullableFilter<"notes"> | Date | string | null
    shareMaxView?: IntNullableFilter<"notes"> | number | null
    shareViewCount?: IntNullableFilter<"notes"> | number | null
    metadata?: JsonNullableFilter<"notes">
    accountId?: IntNullableFilter<"notes"> | number | null
    sortOrder?: IntFilter<"notes"> | number
    createdAt?: DateTimeFilter<"notes"> | Date | string
    updatedAt?: DateTimeFilter<"notes"> | Date | string
  }

  export type configUpsertWithWhereUniqueWithoutUserInput = {
    where: configWhereUniqueInput
    update: XOR<configUpdateWithoutUserInput, configUncheckedUpdateWithoutUserInput>
    create: XOR<configCreateWithoutUserInput, configUncheckedCreateWithoutUserInput>
  }

  export type configUpdateWithWhereUniqueWithoutUserInput = {
    where: configWhereUniqueInput
    data: XOR<configUpdateWithoutUserInput, configUncheckedUpdateWithoutUserInput>
  }

  export type configUpdateManyWithWhereWithoutUserInput = {
    where: configScalarWhereInput
    data: XOR<configUpdateManyMutationInput, configUncheckedUpdateManyWithoutUserInput>
  }

  export type configScalarWhereInput = {
    AND?: configScalarWhereInput | configScalarWhereInput[]
    OR?: configScalarWhereInput[]
    NOT?: configScalarWhereInput | configScalarWhereInput[]
    id?: IntFilter<"config"> | number
    key?: StringFilter<"config"> | string
    config?: JsonNullableFilter<"config">
    userId?: IntNullableFilter<"config"> | number | null
  }

  export type tagUpsertWithWhereUniqueWithoutAccountInput = {
    where: tagWhereUniqueInput
    update: XOR<tagUpdateWithoutAccountInput, tagUncheckedUpdateWithoutAccountInput>
    create: XOR<tagCreateWithoutAccountInput, tagUncheckedCreateWithoutAccountInput>
  }

  export type tagUpdateWithWhereUniqueWithoutAccountInput = {
    where: tagWhereUniqueInput
    data: XOR<tagUpdateWithoutAccountInput, tagUncheckedUpdateWithoutAccountInput>
  }

  export type tagUpdateManyWithWhereWithoutAccountInput = {
    where: tagScalarWhereInput
    data: XOR<tagUpdateManyMutationInput, tagUncheckedUpdateManyWithoutAccountInput>
  }

  export type tagScalarWhereInput = {
    AND?: tagScalarWhereInput | tagScalarWhereInput[]
    OR?: tagScalarWhereInput[]
    NOT?: tagScalarWhereInput | tagScalarWhereInput[]
    id?: IntFilter<"tag"> | number
    name?: StringFilter<"tag"> | string
    icon?: StringFilter<"tag"> | string
    parent?: IntFilter<"tag"> | number
    accountId?: IntNullableFilter<"tag"> | number | null
    createdAt?: DateTimeFilter<"tag"> | Date | string
    updatedAt?: DateTimeFilter<"tag"> | Date | string
    sortOrder?: IntFilter<"tag"> | number
  }

  export type commentsUpsertWithWhereUniqueWithoutAccountInput = {
    where: commentsWhereUniqueInput
    update: XOR<commentsUpdateWithoutAccountInput, commentsUncheckedUpdateWithoutAccountInput>
    create: XOR<commentsCreateWithoutAccountInput, commentsUncheckedCreateWithoutAccountInput>
  }

  export type commentsUpdateWithWhereUniqueWithoutAccountInput = {
    where: commentsWhereUniqueInput
    data: XOR<commentsUpdateWithoutAccountInput, commentsUncheckedUpdateWithoutAccountInput>
  }

  export type commentsUpdateManyWithWhereWithoutAccountInput = {
    where: commentsScalarWhereInput
    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyWithoutAccountInput>
  }

  export type commentsScalarWhereInput = {
    AND?: commentsScalarWhereInput | commentsScalarWhereInput[]
    OR?: commentsScalarWhereInput[]
    NOT?: commentsScalarWhereInput | commentsScalarWhereInput[]
    id?: IntFilter<"comments"> | number
    content?: StringFilter<"comments"> | string
    accountId?: IntNullableFilter<"comments"> | number | null
    guestName?: StringNullableFilter<"comments"> | string | null
    guestIP?: StringNullableFilter<"comments"> | string | null
    guestUA?: StringNullableFilter<"comments"> | string | null
    noteId?: IntFilter<"comments"> | number
    parentId?: IntNullableFilter<"comments"> | number | null
    createdAt?: DateTimeFilter<"comments"> | Date | string
    updatedAt?: DateTimeFilter<"comments"> | Date | string
  }

  export type attachmentsUpsertWithWhereUniqueWithoutAccountInput = {
    where: attachmentsWhereUniqueInput
    update: XOR<attachmentsUpdateWithoutAccountInput, attachmentsUncheckedUpdateWithoutAccountInput>
    create: XOR<attachmentsCreateWithoutAccountInput, attachmentsUncheckedCreateWithoutAccountInput>
  }

  export type attachmentsUpdateWithWhereUniqueWithoutAccountInput = {
    where: attachmentsWhereUniqueInput
    data: XOR<attachmentsUpdateWithoutAccountInput, attachmentsUncheckedUpdateWithoutAccountInput>
  }

  export type attachmentsUpdateManyWithWhereWithoutAccountInput = {
    where: attachmentsScalarWhereInput
    data: XOR<attachmentsUpdateManyMutationInput, attachmentsUncheckedUpdateManyWithoutAccountInput>
  }

  export type attachmentsScalarWhereInput = {
    AND?: attachmentsScalarWhereInput | attachmentsScalarWhereInput[]
    OR?: attachmentsScalarWhereInput[]
    NOT?: attachmentsScalarWhereInput | attachmentsScalarWhereInput[]
    id?: IntFilter<"attachments"> | number
    isShare?: BoolFilter<"attachments"> | boolean
    sharePassword?: StringFilter<"attachments"> | string
    name?: StringFilter<"attachments"> | string
    path?: StringFilter<"attachments"> | string
    size?: DecimalFilter<"attachments"> | Decimal | DecimalJsLike | number | string
    type?: StringFilter<"attachments"> | string
    noteId?: IntNullableFilter<"attachments"> | number | null
    accountId?: IntNullableFilter<"attachments"> | number | null
    sortOrder?: IntFilter<"attachments"> | number
    createdAt?: DateTimeFilter<"attachments"> | Date | string
    updatedAt?: DateTimeFilter<"attachments"> | Date | string
    perfixPath?: StringNullableFilter<"attachments"> | string | null
    depth?: IntNullableFilter<"attachments"> | number | null
    metadata?: JsonNullableFilter<"attachments">
  }

  export type followsUpsertWithWhereUniqueWithoutAccountInput = {
    where: followsWhereUniqueInput
    update: XOR<followsUpdateWithoutAccountInput, followsUncheckedUpdateWithoutAccountInput>
    create: XOR<followsCreateWithoutAccountInput, followsUncheckedCreateWithoutAccountInput>
  }

  export type followsUpdateWithWhereUniqueWithoutAccountInput = {
    where: followsWhereUniqueInput
    data: XOR<followsUpdateWithoutAccountInput, followsUncheckedUpdateWithoutAccountInput>
  }

  export type followsUpdateManyWithWhereWithoutAccountInput = {
    where: followsScalarWhereInput
    data: XOR<followsUpdateManyMutationInput, followsUncheckedUpdateManyWithoutAccountInput>
  }

  export type followsScalarWhereInput = {
    AND?: followsScalarWhereInput | followsScalarWhereInput[]
    OR?: followsScalarWhereInput[]
    NOT?: followsScalarWhereInput | followsScalarWhereInput[]
    id?: IntFilter<"follows"> | number
    siteName?: StringNullableFilter<"follows"> | string | null
    siteUrl?: StringFilter<"follows"> | string
    siteAvatar?: StringNullableFilter<"follows"> | string | null
    description?: StringNullableFilter<"follows"> | string | null
    createdAt?: DateTimeFilter<"follows"> | Date | string
    updatedAt?: DateTimeFilter<"follows"> | Date | string
    followType?: StringFilter<"follows"> | string
    accountId?: IntFilter<"follows"> | number
  }

  export type notificationsUpsertWithWhereUniqueWithoutAccountInput = {
    where: notificationsWhereUniqueInput
    update: XOR<notificationsUpdateWithoutAccountInput, notificationsUncheckedUpdateWithoutAccountInput>
    create: XOR<notificationsCreateWithoutAccountInput, notificationsUncheckedCreateWithoutAccountInput>
  }

  export type notificationsUpdateWithWhereUniqueWithoutAccountInput = {
    where: notificationsWhereUniqueInput
    data: XOR<notificationsUpdateWithoutAccountInput, notificationsUncheckedUpdateWithoutAccountInput>
  }

  export type notificationsUpdateManyWithWhereWithoutAccountInput = {
    where: notificationsScalarWhereInput
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyWithoutAccountInput>
  }

  export type notificationsScalarWhereInput = {
    AND?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    OR?: notificationsScalarWhereInput[]
    NOT?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    id?: IntFilter<"notifications"> | number
    type?: StringFilter<"notifications"> | string
    title?: StringFilter<"notifications"> | string
    content?: StringFilter<"notifications"> | string
    metadata?: JsonNullableFilter<"notifications">
    isRead?: BoolFilter<"notifications"> | boolean
    accountId?: IntFilter<"notifications"> | number
    createdAt?: DateTimeFilter<"notifications"> | Date | string
    updatedAt?: DateTimeFilter<"notifications"> | Date | string
  }

  export type conversationUpsertWithWhereUniqueWithoutAccountInput = {
    where: conversationWhereUniqueInput
    update: XOR<conversationUpdateWithoutAccountInput, conversationUncheckedUpdateWithoutAccountInput>
    create: XOR<conversationCreateWithoutAccountInput, conversationUncheckedCreateWithoutAccountInput>
  }

  export type conversationUpdateWithWhereUniqueWithoutAccountInput = {
    where: conversationWhereUniqueInput
    data: XOR<conversationUpdateWithoutAccountInput, conversationUncheckedUpdateWithoutAccountInput>
  }

  export type conversationUpdateManyWithWhereWithoutAccountInput = {
    where: conversationScalarWhereInput
    data: XOR<conversationUpdateManyMutationInput, conversationUncheckedUpdateManyWithoutAccountInput>
  }

  export type conversationScalarWhereInput = {
    AND?: conversationScalarWhereInput | conversationScalarWhereInput[]
    OR?: conversationScalarWhereInput[]
    NOT?: conversationScalarWhereInput | conversationScalarWhereInput[]
    id?: IntFilter<"conversation"> | number
    title?: StringFilter<"conversation"> | string
    isShare?: BoolFilter<"conversation"> | boolean
    accountId?: IntFilter<"conversation"> | number
    createdAt?: DateTimeFilter<"conversation"> | Date | string
    updatedAt?: DateTimeFilter<"conversation"> | Date | string
  }

  export type noteInternalShareUpsertWithWhereUniqueWithoutAccountInput = {
    where: noteInternalShareWhereUniqueInput
    update: XOR<noteInternalShareUpdateWithoutAccountInput, noteInternalShareUncheckedUpdateWithoutAccountInput>
    create: XOR<noteInternalShareCreateWithoutAccountInput, noteInternalShareUncheckedCreateWithoutAccountInput>
  }

  export type noteInternalShareUpdateWithWhereUniqueWithoutAccountInput = {
    where: noteInternalShareWhereUniqueInput
    data: XOR<noteInternalShareUpdateWithoutAccountInput, noteInternalShareUncheckedUpdateWithoutAccountInput>
  }

  export type noteInternalShareUpdateManyWithWhereWithoutAccountInput = {
    where: noteInternalShareScalarWhereInput
    data: XOR<noteInternalShareUpdateManyMutationInput, noteInternalShareUncheckedUpdateManyWithoutAccountInput>
  }

  export type noteInternalShareScalarWhereInput = {
    AND?: noteInternalShareScalarWhereInput | noteInternalShareScalarWhereInput[]
    OR?: noteInternalShareScalarWhereInput[]
    NOT?: noteInternalShareScalarWhereInput | noteInternalShareScalarWhereInput[]
    id?: IntFilter<"noteInternalShare"> | number
    noteId?: IntFilter<"noteInternalShare"> | number
    accountId?: IntFilter<"noteInternalShare"> | number
    canEdit?: BoolFilter<"noteInternalShare"> | boolean
    createdAt?: DateTimeFilter<"noteInternalShare"> | Date | string
    updatedAt?: DateTimeFilter<"noteInternalShare"> | Date | string
  }

  export type aiScheduledTaskUpsertWithWhereUniqueWithoutAccountInput = {
    where: aiScheduledTaskWhereUniqueInput
    update: XOR<aiScheduledTaskUpdateWithoutAccountInput, aiScheduledTaskUncheckedUpdateWithoutAccountInput>
    create: XOR<aiScheduledTaskCreateWithoutAccountInput, aiScheduledTaskUncheckedCreateWithoutAccountInput>
  }

  export type aiScheduledTaskUpdateWithWhereUniqueWithoutAccountInput = {
    where: aiScheduledTaskWhereUniqueInput
    data: XOR<aiScheduledTaskUpdateWithoutAccountInput, aiScheduledTaskUncheckedUpdateWithoutAccountInput>
  }

  export type aiScheduledTaskUpdateManyWithWhereWithoutAccountInput = {
    where: aiScheduledTaskScalarWhereInput
    data: XOR<aiScheduledTaskUpdateManyMutationInput, aiScheduledTaskUncheckedUpdateManyWithoutAccountInput>
  }

  export type aiScheduledTaskScalarWhereInput = {
    AND?: aiScheduledTaskScalarWhereInput | aiScheduledTaskScalarWhereInput[]
    OR?: aiScheduledTaskScalarWhereInput[]
    NOT?: aiScheduledTaskScalarWhereInput | aiScheduledTaskScalarWhereInput[]
    id?: IntFilter<"aiScheduledTask"> | number
    name?: StringFilter<"aiScheduledTask"> | string
    prompt?: StringFilter<"aiScheduledTask"> | string
    schedule?: StringFilter<"aiScheduledTask"> | string
    isEnabled?: BoolFilter<"aiScheduledTask"> | boolean
    lastRun?: DateTimeNullableFilter<"aiScheduledTask"> | Date | string | null
    lastResult?: JsonNullableFilter<"aiScheduledTask">
    accountId?: IntFilter<"aiScheduledTask"> | number
    createdAt?: DateTimeFilter<"aiScheduledTask"> | Date | string
    updatedAt?: DateTimeFilter<"aiScheduledTask"> | Date | string
  }

  export type notesCreateWithoutAttachmentsInput = {
    type?: number
    content?: string
    isArchived?: boolean
    isRecycle?: boolean
    isShare?: boolean
    isTop?: boolean
    isReviewed?: boolean
    sharePassword?: string
    shareEncryptedUrl?: string | null
    shareExpiryDate?: Date | string | null
    shareMaxView?: number | null
    shareViewCount?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: tagsToNoteCreateNestedManyWithoutNoteInput
    account?: accountsCreateNestedOneWithoutNotesInput
    referencedBy?: noteReferenceCreateNestedManyWithoutToNoteInput
    references?: noteReferenceCreateNestedManyWithoutFromNoteInput
    comments?: commentsCreateNestedManyWithoutNoteInput
    histories?: noteHistoryCreateNestedManyWithoutNoteInput
    internalShares?: noteInternalShareCreateNestedManyWithoutNoteInput
  }

  export type notesUncheckedCreateWithoutAttachmentsInput = {
    id?: number
    type?: number
    content?: string
    isArchived?: boolean
    isRecycle?: boolean
    isShare?: boolean
    isTop?: boolean
    isReviewed?: boolean
    sharePassword?: string
    shareEncryptedUrl?: string | null
    shareExpiryDate?: Date | string | null
    shareMaxView?: number | null
    shareViewCount?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId?: number | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: tagsToNoteUncheckedCreateNestedManyWithoutNoteInput
    referencedBy?: noteReferenceUncheckedCreateNestedManyWithoutToNoteInput
    references?: noteReferenceUncheckedCreateNestedManyWithoutFromNoteInput
    comments?: commentsUncheckedCreateNestedManyWithoutNoteInput
    histories?: noteHistoryUncheckedCreateNestedManyWithoutNoteInput
    internalShares?: noteInternalShareUncheckedCreateNestedManyWithoutNoteInput
  }

  export type notesCreateOrConnectWithoutAttachmentsInput = {
    where: notesWhereUniqueInput
    create: XOR<notesCreateWithoutAttachmentsInput, notesUncheckedCreateWithoutAttachmentsInput>
  }

  export type accountsCreateWithoutAttachmentsInput = {
    name?: string
    nickname?: string
    password?: string
    image?: string
    apiToken?: string
    description?: string
    note?: number
    role?: string
    loginType?: string
    linkAccountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: notesCreateNestedManyWithoutAccountInput
    configs?: configCreateNestedManyWithoutUserInput
    tags?: tagCreateNestedManyWithoutAccountInput
    comments?: commentsCreateNestedManyWithoutAccountInput
    follows?: followsCreateNestedManyWithoutAccountInput
    notifications?: notificationsCreateNestedManyWithoutAccountInput
    conversations?: conversationCreateNestedManyWithoutAccountInput
    sharedNotes?: noteInternalShareCreateNestedManyWithoutAccountInput
    aiScheduledTasks?: aiScheduledTaskCreateNestedManyWithoutAccountInput
  }

  export type accountsUncheckedCreateWithoutAttachmentsInput = {
    id?: number
    name?: string
    nickname?: string
    password?: string
    image?: string
    apiToken?: string
    description?: string
    note?: number
    role?: string
    loginType?: string
    linkAccountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: notesUncheckedCreateNestedManyWithoutAccountInput
    configs?: configUncheckedCreateNestedManyWithoutUserInput
    tags?: tagUncheckedCreateNestedManyWithoutAccountInput
    comments?: commentsUncheckedCreateNestedManyWithoutAccountInput
    follows?: followsUncheckedCreateNestedManyWithoutAccountInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutAccountInput
    conversations?: conversationUncheckedCreateNestedManyWithoutAccountInput
    sharedNotes?: noteInternalShareUncheckedCreateNestedManyWithoutAccountInput
    aiScheduledTasks?: aiScheduledTaskUncheckedCreateNestedManyWithoutAccountInput
  }

  export type accountsCreateOrConnectWithoutAttachmentsInput = {
    where: accountsWhereUniqueInput
    create: XOR<accountsCreateWithoutAttachmentsInput, accountsUncheckedCreateWithoutAttachmentsInput>
  }

  export type notesUpsertWithoutAttachmentsInput = {
    update: XOR<notesUpdateWithoutAttachmentsInput, notesUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<notesCreateWithoutAttachmentsInput, notesUncheckedCreateWithoutAttachmentsInput>
    where?: notesWhereInput
  }

  export type notesUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: notesWhereInput
    data: XOR<notesUpdateWithoutAttachmentsInput, notesUncheckedUpdateWithoutAttachmentsInput>
  }

  export type notesUpdateWithoutAttachmentsInput = {
    type?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isRecycle?: BoolFieldUpdateOperationsInput | boolean
    isShare?: BoolFieldUpdateOperationsInput | boolean
    isTop?: BoolFieldUpdateOperationsInput | boolean
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    shareEncryptedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shareExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareMaxView?: NullableIntFieldUpdateOperationsInput | number | null
    shareViewCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: tagsToNoteUpdateManyWithoutNoteNestedInput
    account?: accountsUpdateOneWithoutNotesNestedInput
    referencedBy?: noteReferenceUpdateManyWithoutToNoteNestedInput
    references?: noteReferenceUpdateManyWithoutFromNoteNestedInput
    comments?: commentsUpdateManyWithoutNoteNestedInput
    histories?: noteHistoryUpdateManyWithoutNoteNestedInput
    internalShares?: noteInternalShareUpdateManyWithoutNoteNestedInput
  }

  export type notesUncheckedUpdateWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isRecycle?: BoolFieldUpdateOperationsInput | boolean
    isShare?: BoolFieldUpdateOperationsInput | boolean
    isTop?: BoolFieldUpdateOperationsInput | boolean
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    shareEncryptedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shareExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareMaxView?: NullableIntFieldUpdateOperationsInput | number | null
    shareViewCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: tagsToNoteUncheckedUpdateManyWithoutNoteNestedInput
    referencedBy?: noteReferenceUncheckedUpdateManyWithoutToNoteNestedInput
    references?: noteReferenceUncheckedUpdateManyWithoutFromNoteNestedInput
    comments?: commentsUncheckedUpdateManyWithoutNoteNestedInput
    histories?: noteHistoryUncheckedUpdateManyWithoutNoteNestedInput
    internalShares?: noteInternalShareUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type accountsUpsertWithoutAttachmentsInput = {
    update: XOR<accountsUpdateWithoutAttachmentsInput, accountsUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<accountsCreateWithoutAttachmentsInput, accountsUncheckedCreateWithoutAttachmentsInput>
    where?: accountsWhereInput
  }

  export type accountsUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: accountsWhereInput
    data: XOR<accountsUpdateWithoutAttachmentsInput, accountsUncheckedUpdateWithoutAttachmentsInput>
  }

  export type accountsUpdateWithoutAttachmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    apiToken?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    note?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    loginType?: StringFieldUpdateOperationsInput | string
    linkAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: notesUpdateManyWithoutAccountNestedInput
    configs?: configUpdateManyWithoutUserNestedInput
    tags?: tagUpdateManyWithoutAccountNestedInput
    comments?: commentsUpdateManyWithoutAccountNestedInput
    follows?: followsUpdateManyWithoutAccountNestedInput
    notifications?: notificationsUpdateManyWithoutAccountNestedInput
    conversations?: conversationUpdateManyWithoutAccountNestedInput
    sharedNotes?: noteInternalShareUpdateManyWithoutAccountNestedInput
    aiScheduledTasks?: aiScheduledTaskUpdateManyWithoutAccountNestedInput
  }

  export type accountsUncheckedUpdateWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    apiToken?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    note?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    loginType?: StringFieldUpdateOperationsInput | string
    linkAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: notesUncheckedUpdateManyWithoutAccountNestedInput
    configs?: configUncheckedUpdateManyWithoutUserNestedInput
    tags?: tagUncheckedUpdateManyWithoutAccountNestedInput
    comments?: commentsUncheckedUpdateManyWithoutAccountNestedInput
    follows?: followsUncheckedUpdateManyWithoutAccountNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutAccountNestedInput
    conversations?: conversationUncheckedUpdateManyWithoutAccountNestedInput
    sharedNotes?: noteInternalShareUncheckedUpdateManyWithoutAccountNestedInput
    aiScheduledTasks?: aiScheduledTaskUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type accountsCreateWithoutConfigsInput = {
    name?: string
    nickname?: string
    password?: string
    image?: string
    apiToken?: string
    description?: string
    note?: number
    role?: string
    loginType?: string
    linkAccountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: notesCreateNestedManyWithoutAccountInput
    tags?: tagCreateNestedManyWithoutAccountInput
    comments?: commentsCreateNestedManyWithoutAccountInput
    attachments?: attachmentsCreateNestedManyWithoutAccountInput
    follows?: followsCreateNestedManyWithoutAccountInput
    notifications?: notificationsCreateNestedManyWithoutAccountInput
    conversations?: conversationCreateNestedManyWithoutAccountInput
    sharedNotes?: noteInternalShareCreateNestedManyWithoutAccountInput
    aiScheduledTasks?: aiScheduledTaskCreateNestedManyWithoutAccountInput
  }

  export type accountsUncheckedCreateWithoutConfigsInput = {
    id?: number
    name?: string
    nickname?: string
    password?: string
    image?: string
    apiToken?: string
    description?: string
    note?: number
    role?: string
    loginType?: string
    linkAccountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: notesUncheckedCreateNestedManyWithoutAccountInput
    tags?: tagUncheckedCreateNestedManyWithoutAccountInput
    comments?: commentsUncheckedCreateNestedManyWithoutAccountInput
    attachments?: attachmentsUncheckedCreateNestedManyWithoutAccountInput
    follows?: followsUncheckedCreateNestedManyWithoutAccountInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutAccountInput
    conversations?: conversationUncheckedCreateNestedManyWithoutAccountInput
    sharedNotes?: noteInternalShareUncheckedCreateNestedManyWithoutAccountInput
    aiScheduledTasks?: aiScheduledTaskUncheckedCreateNestedManyWithoutAccountInput
  }

  export type accountsCreateOrConnectWithoutConfigsInput = {
    where: accountsWhereUniqueInput
    create: XOR<accountsCreateWithoutConfigsInput, accountsUncheckedCreateWithoutConfigsInput>
  }

  export type accountsUpsertWithoutConfigsInput = {
    update: XOR<accountsUpdateWithoutConfigsInput, accountsUncheckedUpdateWithoutConfigsInput>
    create: XOR<accountsCreateWithoutConfigsInput, accountsUncheckedCreateWithoutConfigsInput>
    where?: accountsWhereInput
  }

  export type accountsUpdateToOneWithWhereWithoutConfigsInput = {
    where?: accountsWhereInput
    data: XOR<accountsUpdateWithoutConfigsInput, accountsUncheckedUpdateWithoutConfigsInput>
  }

  export type accountsUpdateWithoutConfigsInput = {
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    apiToken?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    note?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    loginType?: StringFieldUpdateOperationsInput | string
    linkAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: notesUpdateManyWithoutAccountNestedInput
    tags?: tagUpdateManyWithoutAccountNestedInput
    comments?: commentsUpdateManyWithoutAccountNestedInput
    attachments?: attachmentsUpdateManyWithoutAccountNestedInput
    follows?: followsUpdateManyWithoutAccountNestedInput
    notifications?: notificationsUpdateManyWithoutAccountNestedInput
    conversations?: conversationUpdateManyWithoutAccountNestedInput
    sharedNotes?: noteInternalShareUpdateManyWithoutAccountNestedInput
    aiScheduledTasks?: aiScheduledTaskUpdateManyWithoutAccountNestedInput
  }

  export type accountsUncheckedUpdateWithoutConfigsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    apiToken?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    note?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    loginType?: StringFieldUpdateOperationsInput | string
    linkAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: notesUncheckedUpdateManyWithoutAccountNestedInput
    tags?: tagUncheckedUpdateManyWithoutAccountNestedInput
    comments?: commentsUncheckedUpdateManyWithoutAccountNestedInput
    attachments?: attachmentsUncheckedUpdateManyWithoutAccountNestedInput
    follows?: followsUncheckedUpdateManyWithoutAccountNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutAccountNestedInput
    conversations?: conversationUncheckedUpdateManyWithoutAccountNestedInput
    sharedNotes?: noteInternalShareUncheckedUpdateManyWithoutAccountNestedInput
    aiScheduledTasks?: aiScheduledTaskUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type attachmentsCreateWithoutNoteInput = {
    isShare?: boolean
    sharePassword?: string
    name?: string
    path?: string
    size?: Decimal | DecimalJsLike | number | string
    type?: string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    perfixPath?: string | null
    depth?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    account?: accountsCreateNestedOneWithoutAttachmentsInput
  }

  export type attachmentsUncheckedCreateWithoutNoteInput = {
    id?: number
    isShare?: boolean
    sharePassword?: string
    name?: string
    path?: string
    size?: Decimal | DecimalJsLike | number | string
    type?: string
    accountId?: number | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    perfixPath?: string | null
    depth?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type attachmentsCreateOrConnectWithoutNoteInput = {
    where: attachmentsWhereUniqueInput
    create: XOR<attachmentsCreateWithoutNoteInput, attachmentsUncheckedCreateWithoutNoteInput>
  }

  export type attachmentsCreateManyNoteInputEnvelope = {
    data: attachmentsCreateManyNoteInput | attachmentsCreateManyNoteInput[]
    skipDuplicates?: boolean
  }

  export type tagsToNoteCreateWithoutNoteInput = {
    id?: number
    tag?: tagCreateNestedOneWithoutTagsToNoteInput
  }

  export type tagsToNoteUncheckedCreateWithoutNoteInput = {
    id?: number
    tagId?: number
  }

  export type tagsToNoteCreateOrConnectWithoutNoteInput = {
    where: tagsToNoteWhereUniqueInput
    create: XOR<tagsToNoteCreateWithoutNoteInput, tagsToNoteUncheckedCreateWithoutNoteInput>
  }

  export type tagsToNoteCreateManyNoteInputEnvelope = {
    data: tagsToNoteCreateManyNoteInput | tagsToNoteCreateManyNoteInput[]
    skipDuplicates?: boolean
  }

  export type accountsCreateWithoutNotesInput = {
    name?: string
    nickname?: string
    password?: string
    image?: string
    apiToken?: string
    description?: string
    note?: number
    role?: string
    loginType?: string
    linkAccountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    configs?: configCreateNestedManyWithoutUserInput
    tags?: tagCreateNestedManyWithoutAccountInput
    comments?: commentsCreateNestedManyWithoutAccountInput
    attachments?: attachmentsCreateNestedManyWithoutAccountInput
    follows?: followsCreateNestedManyWithoutAccountInput
    notifications?: notificationsCreateNestedManyWithoutAccountInput
    conversations?: conversationCreateNestedManyWithoutAccountInput
    sharedNotes?: noteInternalShareCreateNestedManyWithoutAccountInput
    aiScheduledTasks?: aiScheduledTaskCreateNestedManyWithoutAccountInput
  }

  export type accountsUncheckedCreateWithoutNotesInput = {
    id?: number
    name?: string
    nickname?: string
    password?: string
    image?: string
    apiToken?: string
    description?: string
    note?: number
    role?: string
    loginType?: string
    linkAccountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    configs?: configUncheckedCreateNestedManyWithoutUserInput
    tags?: tagUncheckedCreateNestedManyWithoutAccountInput
    comments?: commentsUncheckedCreateNestedManyWithoutAccountInput
    attachments?: attachmentsUncheckedCreateNestedManyWithoutAccountInput
    follows?: followsUncheckedCreateNestedManyWithoutAccountInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutAccountInput
    conversations?: conversationUncheckedCreateNestedManyWithoutAccountInput
    sharedNotes?: noteInternalShareUncheckedCreateNestedManyWithoutAccountInput
    aiScheduledTasks?: aiScheduledTaskUncheckedCreateNestedManyWithoutAccountInput
  }

  export type accountsCreateOrConnectWithoutNotesInput = {
    where: accountsWhereUniqueInput
    create: XOR<accountsCreateWithoutNotesInput, accountsUncheckedCreateWithoutNotesInput>
  }

  export type noteReferenceCreateWithoutToNoteInput = {
    createdAt?: Date | string
    fromNote: notesCreateNestedOneWithoutReferencesInput
  }

  export type noteReferenceUncheckedCreateWithoutToNoteInput = {
    id?: number
    fromNoteId: number
    createdAt?: Date | string
  }

  export type noteReferenceCreateOrConnectWithoutToNoteInput = {
    where: noteReferenceWhereUniqueInput
    create: XOR<noteReferenceCreateWithoutToNoteInput, noteReferenceUncheckedCreateWithoutToNoteInput>
  }

  export type noteReferenceCreateManyToNoteInputEnvelope = {
    data: noteReferenceCreateManyToNoteInput | noteReferenceCreateManyToNoteInput[]
    skipDuplicates?: boolean
  }

  export type noteReferenceCreateWithoutFromNoteInput = {
    createdAt?: Date | string
    toNote: notesCreateNestedOneWithoutReferencedByInput
  }

  export type noteReferenceUncheckedCreateWithoutFromNoteInput = {
    id?: number
    toNoteId: number
    createdAt?: Date | string
  }

  export type noteReferenceCreateOrConnectWithoutFromNoteInput = {
    where: noteReferenceWhereUniqueInput
    create: XOR<noteReferenceCreateWithoutFromNoteInput, noteReferenceUncheckedCreateWithoutFromNoteInput>
  }

  export type noteReferenceCreateManyFromNoteInputEnvelope = {
    data: noteReferenceCreateManyFromNoteInput | noteReferenceCreateManyFromNoteInput[]
    skipDuplicates?: boolean
  }

  export type commentsCreateWithoutNoteInput = {
    content: string
    guestName?: string | null
    guestIP?: string | null
    guestUA?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account?: accountsCreateNestedOneWithoutCommentsInput
    parent?: commentsCreateNestedOneWithoutRepliesInput
    replies?: commentsCreateNestedManyWithoutParentInput
  }

  export type commentsUncheckedCreateWithoutNoteInput = {
    id?: number
    content: string
    accountId?: number | null
    guestName?: string | null
    guestIP?: string | null
    guestUA?: string | null
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: commentsUncheckedCreateNestedManyWithoutParentInput
  }

  export type commentsCreateOrConnectWithoutNoteInput = {
    where: commentsWhereUniqueInput
    create: XOR<commentsCreateWithoutNoteInput, commentsUncheckedCreateWithoutNoteInput>
  }

  export type commentsCreateManyNoteInputEnvelope = {
    data: commentsCreateManyNoteInput | commentsCreateManyNoteInput[]
    skipDuplicates?: boolean
  }

  export type noteHistoryCreateWithoutNoteInput = {
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version: number
    accountId?: number | null
    createdAt?: Date | string
  }

  export type noteHistoryUncheckedCreateWithoutNoteInput = {
    id?: number
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version: number
    accountId?: number | null
    createdAt?: Date | string
  }

  export type noteHistoryCreateOrConnectWithoutNoteInput = {
    where: noteHistoryWhereUniqueInput
    create: XOR<noteHistoryCreateWithoutNoteInput, noteHistoryUncheckedCreateWithoutNoteInput>
  }

  export type noteHistoryCreateManyNoteInputEnvelope = {
    data: noteHistoryCreateManyNoteInput | noteHistoryCreateManyNoteInput[]
    skipDuplicates?: boolean
  }

  export type noteInternalShareCreateWithoutNoteInput = {
    canEdit?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    account: accountsCreateNestedOneWithoutSharedNotesInput
  }

  export type noteInternalShareUncheckedCreateWithoutNoteInput = {
    id?: number
    accountId: number
    canEdit?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type noteInternalShareCreateOrConnectWithoutNoteInput = {
    where: noteInternalShareWhereUniqueInput
    create: XOR<noteInternalShareCreateWithoutNoteInput, noteInternalShareUncheckedCreateWithoutNoteInput>
  }

  export type noteInternalShareCreateManyNoteInputEnvelope = {
    data: noteInternalShareCreateManyNoteInput | noteInternalShareCreateManyNoteInput[]
    skipDuplicates?: boolean
  }

  export type attachmentsUpsertWithWhereUniqueWithoutNoteInput = {
    where: attachmentsWhereUniqueInput
    update: XOR<attachmentsUpdateWithoutNoteInput, attachmentsUncheckedUpdateWithoutNoteInput>
    create: XOR<attachmentsCreateWithoutNoteInput, attachmentsUncheckedCreateWithoutNoteInput>
  }

  export type attachmentsUpdateWithWhereUniqueWithoutNoteInput = {
    where: attachmentsWhereUniqueInput
    data: XOR<attachmentsUpdateWithoutNoteInput, attachmentsUncheckedUpdateWithoutNoteInput>
  }

  export type attachmentsUpdateManyWithWhereWithoutNoteInput = {
    where: attachmentsScalarWhereInput
    data: XOR<attachmentsUpdateManyMutationInput, attachmentsUncheckedUpdateManyWithoutNoteInput>
  }

  export type tagsToNoteUpsertWithWhereUniqueWithoutNoteInput = {
    where: tagsToNoteWhereUniqueInput
    update: XOR<tagsToNoteUpdateWithoutNoteInput, tagsToNoteUncheckedUpdateWithoutNoteInput>
    create: XOR<tagsToNoteCreateWithoutNoteInput, tagsToNoteUncheckedCreateWithoutNoteInput>
  }

  export type tagsToNoteUpdateWithWhereUniqueWithoutNoteInput = {
    where: tagsToNoteWhereUniqueInput
    data: XOR<tagsToNoteUpdateWithoutNoteInput, tagsToNoteUncheckedUpdateWithoutNoteInput>
  }

  export type tagsToNoteUpdateManyWithWhereWithoutNoteInput = {
    where: tagsToNoteScalarWhereInput
    data: XOR<tagsToNoteUpdateManyMutationInput, tagsToNoteUncheckedUpdateManyWithoutNoteInput>
  }

  export type tagsToNoteScalarWhereInput = {
    AND?: tagsToNoteScalarWhereInput | tagsToNoteScalarWhereInput[]
    OR?: tagsToNoteScalarWhereInput[]
    NOT?: tagsToNoteScalarWhereInput | tagsToNoteScalarWhereInput[]
    id?: IntFilter<"tagsToNote"> | number
    noteId?: IntFilter<"tagsToNote"> | number
    tagId?: IntFilter<"tagsToNote"> | number
  }

  export type accountsUpsertWithoutNotesInput = {
    update: XOR<accountsUpdateWithoutNotesInput, accountsUncheckedUpdateWithoutNotesInput>
    create: XOR<accountsCreateWithoutNotesInput, accountsUncheckedCreateWithoutNotesInput>
    where?: accountsWhereInput
  }

  export type accountsUpdateToOneWithWhereWithoutNotesInput = {
    where?: accountsWhereInput
    data: XOR<accountsUpdateWithoutNotesInput, accountsUncheckedUpdateWithoutNotesInput>
  }

  export type accountsUpdateWithoutNotesInput = {
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    apiToken?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    note?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    loginType?: StringFieldUpdateOperationsInput | string
    linkAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    configs?: configUpdateManyWithoutUserNestedInput
    tags?: tagUpdateManyWithoutAccountNestedInput
    comments?: commentsUpdateManyWithoutAccountNestedInput
    attachments?: attachmentsUpdateManyWithoutAccountNestedInput
    follows?: followsUpdateManyWithoutAccountNestedInput
    notifications?: notificationsUpdateManyWithoutAccountNestedInput
    conversations?: conversationUpdateManyWithoutAccountNestedInput
    sharedNotes?: noteInternalShareUpdateManyWithoutAccountNestedInput
    aiScheduledTasks?: aiScheduledTaskUpdateManyWithoutAccountNestedInput
  }

  export type accountsUncheckedUpdateWithoutNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    apiToken?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    note?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    loginType?: StringFieldUpdateOperationsInput | string
    linkAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    configs?: configUncheckedUpdateManyWithoutUserNestedInput
    tags?: tagUncheckedUpdateManyWithoutAccountNestedInput
    comments?: commentsUncheckedUpdateManyWithoutAccountNestedInput
    attachments?: attachmentsUncheckedUpdateManyWithoutAccountNestedInput
    follows?: followsUncheckedUpdateManyWithoutAccountNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutAccountNestedInput
    conversations?: conversationUncheckedUpdateManyWithoutAccountNestedInput
    sharedNotes?: noteInternalShareUncheckedUpdateManyWithoutAccountNestedInput
    aiScheduledTasks?: aiScheduledTaskUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type noteReferenceUpsertWithWhereUniqueWithoutToNoteInput = {
    where: noteReferenceWhereUniqueInput
    update: XOR<noteReferenceUpdateWithoutToNoteInput, noteReferenceUncheckedUpdateWithoutToNoteInput>
    create: XOR<noteReferenceCreateWithoutToNoteInput, noteReferenceUncheckedCreateWithoutToNoteInput>
  }

  export type noteReferenceUpdateWithWhereUniqueWithoutToNoteInput = {
    where: noteReferenceWhereUniqueInput
    data: XOR<noteReferenceUpdateWithoutToNoteInput, noteReferenceUncheckedUpdateWithoutToNoteInput>
  }

  export type noteReferenceUpdateManyWithWhereWithoutToNoteInput = {
    where: noteReferenceScalarWhereInput
    data: XOR<noteReferenceUpdateManyMutationInput, noteReferenceUncheckedUpdateManyWithoutToNoteInput>
  }

  export type noteReferenceScalarWhereInput = {
    AND?: noteReferenceScalarWhereInput | noteReferenceScalarWhereInput[]
    OR?: noteReferenceScalarWhereInput[]
    NOT?: noteReferenceScalarWhereInput | noteReferenceScalarWhereInput[]
    id?: IntFilter<"noteReference"> | number
    fromNoteId?: IntFilter<"noteReference"> | number
    toNoteId?: IntFilter<"noteReference"> | number
    createdAt?: DateTimeFilter<"noteReference"> | Date | string
  }

  export type noteReferenceUpsertWithWhereUniqueWithoutFromNoteInput = {
    where: noteReferenceWhereUniqueInput
    update: XOR<noteReferenceUpdateWithoutFromNoteInput, noteReferenceUncheckedUpdateWithoutFromNoteInput>
    create: XOR<noteReferenceCreateWithoutFromNoteInput, noteReferenceUncheckedCreateWithoutFromNoteInput>
  }

  export type noteReferenceUpdateWithWhereUniqueWithoutFromNoteInput = {
    where: noteReferenceWhereUniqueInput
    data: XOR<noteReferenceUpdateWithoutFromNoteInput, noteReferenceUncheckedUpdateWithoutFromNoteInput>
  }

  export type noteReferenceUpdateManyWithWhereWithoutFromNoteInput = {
    where: noteReferenceScalarWhereInput
    data: XOR<noteReferenceUpdateManyMutationInput, noteReferenceUncheckedUpdateManyWithoutFromNoteInput>
  }

  export type commentsUpsertWithWhereUniqueWithoutNoteInput = {
    where: commentsWhereUniqueInput
    update: XOR<commentsUpdateWithoutNoteInput, commentsUncheckedUpdateWithoutNoteInput>
    create: XOR<commentsCreateWithoutNoteInput, commentsUncheckedCreateWithoutNoteInput>
  }

  export type commentsUpdateWithWhereUniqueWithoutNoteInput = {
    where: commentsWhereUniqueInput
    data: XOR<commentsUpdateWithoutNoteInput, commentsUncheckedUpdateWithoutNoteInput>
  }

  export type commentsUpdateManyWithWhereWithoutNoteInput = {
    where: commentsScalarWhereInput
    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyWithoutNoteInput>
  }

  export type noteHistoryUpsertWithWhereUniqueWithoutNoteInput = {
    where: noteHistoryWhereUniqueInput
    update: XOR<noteHistoryUpdateWithoutNoteInput, noteHistoryUncheckedUpdateWithoutNoteInput>
    create: XOR<noteHistoryCreateWithoutNoteInput, noteHistoryUncheckedCreateWithoutNoteInput>
  }

  export type noteHistoryUpdateWithWhereUniqueWithoutNoteInput = {
    where: noteHistoryWhereUniqueInput
    data: XOR<noteHistoryUpdateWithoutNoteInput, noteHistoryUncheckedUpdateWithoutNoteInput>
  }

  export type noteHistoryUpdateManyWithWhereWithoutNoteInput = {
    where: noteHistoryScalarWhereInput
    data: XOR<noteHistoryUpdateManyMutationInput, noteHistoryUncheckedUpdateManyWithoutNoteInput>
  }

  export type noteHistoryScalarWhereInput = {
    AND?: noteHistoryScalarWhereInput | noteHistoryScalarWhereInput[]
    OR?: noteHistoryScalarWhereInput[]
    NOT?: noteHistoryScalarWhereInput | noteHistoryScalarWhereInput[]
    id?: IntFilter<"noteHistory"> | number
    noteId?: IntFilter<"noteHistory"> | number
    content?: StringFilter<"noteHistory"> | string
    metadata?: JsonNullableFilter<"noteHistory">
    version?: IntFilter<"noteHistory"> | number
    accountId?: IntNullableFilter<"noteHistory"> | number | null
    createdAt?: DateTimeFilter<"noteHistory"> | Date | string
  }

  export type noteInternalShareUpsertWithWhereUniqueWithoutNoteInput = {
    where: noteInternalShareWhereUniqueInput
    update: XOR<noteInternalShareUpdateWithoutNoteInput, noteInternalShareUncheckedUpdateWithoutNoteInput>
    create: XOR<noteInternalShareCreateWithoutNoteInput, noteInternalShareUncheckedCreateWithoutNoteInput>
  }

  export type noteInternalShareUpdateWithWhereUniqueWithoutNoteInput = {
    where: noteInternalShareWhereUniqueInput
    data: XOR<noteInternalShareUpdateWithoutNoteInput, noteInternalShareUncheckedUpdateWithoutNoteInput>
  }

  export type noteInternalShareUpdateManyWithWhereWithoutNoteInput = {
    where: noteInternalShareScalarWhereInput
    data: XOR<noteInternalShareUpdateManyMutationInput, noteInternalShareUncheckedUpdateManyWithoutNoteInput>
  }

  export type notesCreateWithoutCommentsInput = {
    type?: number
    content?: string
    isArchived?: boolean
    isRecycle?: boolean
    isShare?: boolean
    isTop?: boolean
    isReviewed?: boolean
    sharePassword?: string
    shareEncryptedUrl?: string | null
    shareExpiryDate?: Date | string | null
    shareMaxView?: number | null
    shareViewCount?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: attachmentsCreateNestedManyWithoutNoteInput
    tags?: tagsToNoteCreateNestedManyWithoutNoteInput
    account?: accountsCreateNestedOneWithoutNotesInput
    referencedBy?: noteReferenceCreateNestedManyWithoutToNoteInput
    references?: noteReferenceCreateNestedManyWithoutFromNoteInput
    histories?: noteHistoryCreateNestedManyWithoutNoteInput
    internalShares?: noteInternalShareCreateNestedManyWithoutNoteInput
  }

  export type notesUncheckedCreateWithoutCommentsInput = {
    id?: number
    type?: number
    content?: string
    isArchived?: boolean
    isRecycle?: boolean
    isShare?: boolean
    isTop?: boolean
    isReviewed?: boolean
    sharePassword?: string
    shareEncryptedUrl?: string | null
    shareExpiryDate?: Date | string | null
    shareMaxView?: number | null
    shareViewCount?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId?: number | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: attachmentsUncheckedCreateNestedManyWithoutNoteInput
    tags?: tagsToNoteUncheckedCreateNestedManyWithoutNoteInput
    referencedBy?: noteReferenceUncheckedCreateNestedManyWithoutToNoteInput
    references?: noteReferenceUncheckedCreateNestedManyWithoutFromNoteInput
    histories?: noteHistoryUncheckedCreateNestedManyWithoutNoteInput
    internalShares?: noteInternalShareUncheckedCreateNestedManyWithoutNoteInput
  }

  export type notesCreateOrConnectWithoutCommentsInput = {
    where: notesWhereUniqueInput
    create: XOR<notesCreateWithoutCommentsInput, notesUncheckedCreateWithoutCommentsInput>
  }

  export type accountsCreateWithoutCommentsInput = {
    name?: string
    nickname?: string
    password?: string
    image?: string
    apiToken?: string
    description?: string
    note?: number
    role?: string
    loginType?: string
    linkAccountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: notesCreateNestedManyWithoutAccountInput
    configs?: configCreateNestedManyWithoutUserInput
    tags?: tagCreateNestedManyWithoutAccountInput
    attachments?: attachmentsCreateNestedManyWithoutAccountInput
    follows?: followsCreateNestedManyWithoutAccountInput
    notifications?: notificationsCreateNestedManyWithoutAccountInput
    conversations?: conversationCreateNestedManyWithoutAccountInput
    sharedNotes?: noteInternalShareCreateNestedManyWithoutAccountInput
    aiScheduledTasks?: aiScheduledTaskCreateNestedManyWithoutAccountInput
  }

  export type accountsUncheckedCreateWithoutCommentsInput = {
    id?: number
    name?: string
    nickname?: string
    password?: string
    image?: string
    apiToken?: string
    description?: string
    note?: number
    role?: string
    loginType?: string
    linkAccountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: notesUncheckedCreateNestedManyWithoutAccountInput
    configs?: configUncheckedCreateNestedManyWithoutUserInput
    tags?: tagUncheckedCreateNestedManyWithoutAccountInput
    attachments?: attachmentsUncheckedCreateNestedManyWithoutAccountInput
    follows?: followsUncheckedCreateNestedManyWithoutAccountInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutAccountInput
    conversations?: conversationUncheckedCreateNestedManyWithoutAccountInput
    sharedNotes?: noteInternalShareUncheckedCreateNestedManyWithoutAccountInput
    aiScheduledTasks?: aiScheduledTaskUncheckedCreateNestedManyWithoutAccountInput
  }

  export type accountsCreateOrConnectWithoutCommentsInput = {
    where: accountsWhereUniqueInput
    create: XOR<accountsCreateWithoutCommentsInput, accountsUncheckedCreateWithoutCommentsInput>
  }

  export type commentsCreateWithoutRepliesInput = {
    content: string
    guestName?: string | null
    guestIP?: string | null
    guestUA?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    note: notesCreateNestedOneWithoutCommentsInput
    account?: accountsCreateNestedOneWithoutCommentsInput
    parent?: commentsCreateNestedOneWithoutRepliesInput
  }

  export type commentsUncheckedCreateWithoutRepliesInput = {
    id?: number
    content: string
    accountId?: number | null
    guestName?: string | null
    guestIP?: string | null
    guestUA?: string | null
    noteId: number
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type commentsCreateOrConnectWithoutRepliesInput = {
    where: commentsWhereUniqueInput
    create: XOR<commentsCreateWithoutRepliesInput, commentsUncheckedCreateWithoutRepliesInput>
  }

  export type commentsCreateWithoutParentInput = {
    content: string
    guestName?: string | null
    guestIP?: string | null
    guestUA?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    note: notesCreateNestedOneWithoutCommentsInput
    account?: accountsCreateNestedOneWithoutCommentsInput
    replies?: commentsCreateNestedManyWithoutParentInput
  }

  export type commentsUncheckedCreateWithoutParentInput = {
    id?: number
    content: string
    accountId?: number | null
    guestName?: string | null
    guestIP?: string | null
    guestUA?: string | null
    noteId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: commentsUncheckedCreateNestedManyWithoutParentInput
  }

  export type commentsCreateOrConnectWithoutParentInput = {
    where: commentsWhereUniqueInput
    create: XOR<commentsCreateWithoutParentInput, commentsUncheckedCreateWithoutParentInput>
  }

  export type commentsCreateManyParentInputEnvelope = {
    data: commentsCreateManyParentInput | commentsCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type notesUpsertWithoutCommentsInput = {
    update: XOR<notesUpdateWithoutCommentsInput, notesUncheckedUpdateWithoutCommentsInput>
    create: XOR<notesCreateWithoutCommentsInput, notesUncheckedCreateWithoutCommentsInput>
    where?: notesWhereInput
  }

  export type notesUpdateToOneWithWhereWithoutCommentsInput = {
    where?: notesWhereInput
    data: XOR<notesUpdateWithoutCommentsInput, notesUncheckedUpdateWithoutCommentsInput>
  }

  export type notesUpdateWithoutCommentsInput = {
    type?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isRecycle?: BoolFieldUpdateOperationsInput | boolean
    isShare?: BoolFieldUpdateOperationsInput | boolean
    isTop?: BoolFieldUpdateOperationsInput | boolean
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    shareEncryptedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shareExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareMaxView?: NullableIntFieldUpdateOperationsInput | number | null
    shareViewCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: attachmentsUpdateManyWithoutNoteNestedInput
    tags?: tagsToNoteUpdateManyWithoutNoteNestedInput
    account?: accountsUpdateOneWithoutNotesNestedInput
    referencedBy?: noteReferenceUpdateManyWithoutToNoteNestedInput
    references?: noteReferenceUpdateManyWithoutFromNoteNestedInput
    histories?: noteHistoryUpdateManyWithoutNoteNestedInput
    internalShares?: noteInternalShareUpdateManyWithoutNoteNestedInput
  }

  export type notesUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isRecycle?: BoolFieldUpdateOperationsInput | boolean
    isShare?: BoolFieldUpdateOperationsInput | boolean
    isTop?: BoolFieldUpdateOperationsInput | boolean
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    shareEncryptedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shareExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareMaxView?: NullableIntFieldUpdateOperationsInput | number | null
    shareViewCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: attachmentsUncheckedUpdateManyWithoutNoteNestedInput
    tags?: tagsToNoteUncheckedUpdateManyWithoutNoteNestedInput
    referencedBy?: noteReferenceUncheckedUpdateManyWithoutToNoteNestedInput
    references?: noteReferenceUncheckedUpdateManyWithoutFromNoteNestedInput
    histories?: noteHistoryUncheckedUpdateManyWithoutNoteNestedInput
    internalShares?: noteInternalShareUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type accountsUpsertWithoutCommentsInput = {
    update: XOR<accountsUpdateWithoutCommentsInput, accountsUncheckedUpdateWithoutCommentsInput>
    create: XOR<accountsCreateWithoutCommentsInput, accountsUncheckedCreateWithoutCommentsInput>
    where?: accountsWhereInput
  }

  export type accountsUpdateToOneWithWhereWithoutCommentsInput = {
    where?: accountsWhereInput
    data: XOR<accountsUpdateWithoutCommentsInput, accountsUncheckedUpdateWithoutCommentsInput>
  }

  export type accountsUpdateWithoutCommentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    apiToken?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    note?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    loginType?: StringFieldUpdateOperationsInput | string
    linkAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: notesUpdateManyWithoutAccountNestedInput
    configs?: configUpdateManyWithoutUserNestedInput
    tags?: tagUpdateManyWithoutAccountNestedInput
    attachments?: attachmentsUpdateManyWithoutAccountNestedInput
    follows?: followsUpdateManyWithoutAccountNestedInput
    notifications?: notificationsUpdateManyWithoutAccountNestedInput
    conversations?: conversationUpdateManyWithoutAccountNestedInput
    sharedNotes?: noteInternalShareUpdateManyWithoutAccountNestedInput
    aiScheduledTasks?: aiScheduledTaskUpdateManyWithoutAccountNestedInput
  }

  export type accountsUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    apiToken?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    note?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    loginType?: StringFieldUpdateOperationsInput | string
    linkAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: notesUncheckedUpdateManyWithoutAccountNestedInput
    configs?: configUncheckedUpdateManyWithoutUserNestedInput
    tags?: tagUncheckedUpdateManyWithoutAccountNestedInput
    attachments?: attachmentsUncheckedUpdateManyWithoutAccountNestedInput
    follows?: followsUncheckedUpdateManyWithoutAccountNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutAccountNestedInput
    conversations?: conversationUncheckedUpdateManyWithoutAccountNestedInput
    sharedNotes?: noteInternalShareUncheckedUpdateManyWithoutAccountNestedInput
    aiScheduledTasks?: aiScheduledTaskUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type commentsUpsertWithoutRepliesInput = {
    update: XOR<commentsUpdateWithoutRepliesInput, commentsUncheckedUpdateWithoutRepliesInput>
    create: XOR<commentsCreateWithoutRepliesInput, commentsUncheckedCreateWithoutRepliesInput>
    where?: commentsWhereInput
  }

  export type commentsUpdateToOneWithWhereWithoutRepliesInput = {
    where?: commentsWhereInput
    data: XOR<commentsUpdateWithoutRepliesInput, commentsUncheckedUpdateWithoutRepliesInput>
  }

  export type commentsUpdateWithoutRepliesInput = {
    content?: StringFieldUpdateOperationsInput | string
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestIP?: NullableStringFieldUpdateOperationsInput | string | null
    guestUA?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: notesUpdateOneRequiredWithoutCommentsNestedInput
    account?: accountsUpdateOneWithoutCommentsNestedInput
    parent?: commentsUpdateOneWithoutRepliesNestedInput
  }

  export type commentsUncheckedUpdateWithoutRepliesInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestIP?: NullableStringFieldUpdateOperationsInput | string | null
    guestUA?: NullableStringFieldUpdateOperationsInput | string | null
    noteId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type commentsUpsertWithWhereUniqueWithoutParentInput = {
    where: commentsWhereUniqueInput
    update: XOR<commentsUpdateWithoutParentInput, commentsUncheckedUpdateWithoutParentInput>
    create: XOR<commentsCreateWithoutParentInput, commentsUncheckedCreateWithoutParentInput>
  }

  export type commentsUpdateWithWhereUniqueWithoutParentInput = {
    where: commentsWhereUniqueInput
    data: XOR<commentsUpdateWithoutParentInput, commentsUncheckedUpdateWithoutParentInput>
  }

  export type commentsUpdateManyWithWhereWithoutParentInput = {
    where: commentsScalarWhereInput
    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyWithoutParentInput>
  }

  export type tagsToNoteCreateWithoutTagInput = {
    id?: number
    note?: notesCreateNestedOneWithoutTagsInput
  }

  export type tagsToNoteUncheckedCreateWithoutTagInput = {
    id?: number
    noteId?: number
  }

  export type tagsToNoteCreateOrConnectWithoutTagInput = {
    where: tagsToNoteWhereUniqueInput
    create: XOR<tagsToNoteCreateWithoutTagInput, tagsToNoteUncheckedCreateWithoutTagInput>
  }

  export type tagsToNoteCreateManyTagInputEnvelope = {
    data: tagsToNoteCreateManyTagInput | tagsToNoteCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type accountsCreateWithoutTagsInput = {
    name?: string
    nickname?: string
    password?: string
    image?: string
    apiToken?: string
    description?: string
    note?: number
    role?: string
    loginType?: string
    linkAccountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: notesCreateNestedManyWithoutAccountInput
    configs?: configCreateNestedManyWithoutUserInput
    comments?: commentsCreateNestedManyWithoutAccountInput
    attachments?: attachmentsCreateNestedManyWithoutAccountInput
    follows?: followsCreateNestedManyWithoutAccountInput
    notifications?: notificationsCreateNestedManyWithoutAccountInput
    conversations?: conversationCreateNestedManyWithoutAccountInput
    sharedNotes?: noteInternalShareCreateNestedManyWithoutAccountInput
    aiScheduledTasks?: aiScheduledTaskCreateNestedManyWithoutAccountInput
  }

  export type accountsUncheckedCreateWithoutTagsInput = {
    id?: number
    name?: string
    nickname?: string
    password?: string
    image?: string
    apiToken?: string
    description?: string
    note?: number
    role?: string
    loginType?: string
    linkAccountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: notesUncheckedCreateNestedManyWithoutAccountInput
    configs?: configUncheckedCreateNestedManyWithoutUserInput
    comments?: commentsUncheckedCreateNestedManyWithoutAccountInput
    attachments?: attachmentsUncheckedCreateNestedManyWithoutAccountInput
    follows?: followsUncheckedCreateNestedManyWithoutAccountInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutAccountInput
    conversations?: conversationUncheckedCreateNestedManyWithoutAccountInput
    sharedNotes?: noteInternalShareUncheckedCreateNestedManyWithoutAccountInput
    aiScheduledTasks?: aiScheduledTaskUncheckedCreateNestedManyWithoutAccountInput
  }

  export type accountsCreateOrConnectWithoutTagsInput = {
    where: accountsWhereUniqueInput
    create: XOR<accountsCreateWithoutTagsInput, accountsUncheckedCreateWithoutTagsInput>
  }

  export type tagsToNoteUpsertWithWhereUniqueWithoutTagInput = {
    where: tagsToNoteWhereUniqueInput
    update: XOR<tagsToNoteUpdateWithoutTagInput, tagsToNoteUncheckedUpdateWithoutTagInput>
    create: XOR<tagsToNoteCreateWithoutTagInput, tagsToNoteUncheckedCreateWithoutTagInput>
  }

  export type tagsToNoteUpdateWithWhereUniqueWithoutTagInput = {
    where: tagsToNoteWhereUniqueInput
    data: XOR<tagsToNoteUpdateWithoutTagInput, tagsToNoteUncheckedUpdateWithoutTagInput>
  }

  export type tagsToNoteUpdateManyWithWhereWithoutTagInput = {
    where: tagsToNoteScalarWhereInput
    data: XOR<tagsToNoteUpdateManyMutationInput, tagsToNoteUncheckedUpdateManyWithoutTagInput>
  }

  export type accountsUpsertWithoutTagsInput = {
    update: XOR<accountsUpdateWithoutTagsInput, accountsUncheckedUpdateWithoutTagsInput>
    create: XOR<accountsCreateWithoutTagsInput, accountsUncheckedCreateWithoutTagsInput>
    where?: accountsWhereInput
  }

  export type accountsUpdateToOneWithWhereWithoutTagsInput = {
    where?: accountsWhereInput
    data: XOR<accountsUpdateWithoutTagsInput, accountsUncheckedUpdateWithoutTagsInput>
  }

  export type accountsUpdateWithoutTagsInput = {
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    apiToken?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    note?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    loginType?: StringFieldUpdateOperationsInput | string
    linkAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: notesUpdateManyWithoutAccountNestedInput
    configs?: configUpdateManyWithoutUserNestedInput
    comments?: commentsUpdateManyWithoutAccountNestedInput
    attachments?: attachmentsUpdateManyWithoutAccountNestedInput
    follows?: followsUpdateManyWithoutAccountNestedInput
    notifications?: notificationsUpdateManyWithoutAccountNestedInput
    conversations?: conversationUpdateManyWithoutAccountNestedInput
    sharedNotes?: noteInternalShareUpdateManyWithoutAccountNestedInput
    aiScheduledTasks?: aiScheduledTaskUpdateManyWithoutAccountNestedInput
  }

  export type accountsUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    apiToken?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    note?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    loginType?: StringFieldUpdateOperationsInput | string
    linkAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: notesUncheckedUpdateManyWithoutAccountNestedInput
    configs?: configUncheckedUpdateManyWithoutUserNestedInput
    comments?: commentsUncheckedUpdateManyWithoutAccountNestedInput
    attachments?: attachmentsUncheckedUpdateManyWithoutAccountNestedInput
    follows?: followsUncheckedUpdateManyWithoutAccountNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutAccountNestedInput
    conversations?: conversationUncheckedUpdateManyWithoutAccountNestedInput
    sharedNotes?: noteInternalShareUncheckedUpdateManyWithoutAccountNestedInput
    aiScheduledTasks?: aiScheduledTaskUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type notesCreateWithoutTagsInput = {
    type?: number
    content?: string
    isArchived?: boolean
    isRecycle?: boolean
    isShare?: boolean
    isTop?: boolean
    isReviewed?: boolean
    sharePassword?: string
    shareEncryptedUrl?: string | null
    shareExpiryDate?: Date | string | null
    shareMaxView?: number | null
    shareViewCount?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: attachmentsCreateNestedManyWithoutNoteInput
    account?: accountsCreateNestedOneWithoutNotesInput
    referencedBy?: noteReferenceCreateNestedManyWithoutToNoteInput
    references?: noteReferenceCreateNestedManyWithoutFromNoteInput
    comments?: commentsCreateNestedManyWithoutNoteInput
    histories?: noteHistoryCreateNestedManyWithoutNoteInput
    internalShares?: noteInternalShareCreateNestedManyWithoutNoteInput
  }

  export type notesUncheckedCreateWithoutTagsInput = {
    id?: number
    type?: number
    content?: string
    isArchived?: boolean
    isRecycle?: boolean
    isShare?: boolean
    isTop?: boolean
    isReviewed?: boolean
    sharePassword?: string
    shareEncryptedUrl?: string | null
    shareExpiryDate?: Date | string | null
    shareMaxView?: number | null
    shareViewCount?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId?: number | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: attachmentsUncheckedCreateNestedManyWithoutNoteInput
    referencedBy?: noteReferenceUncheckedCreateNestedManyWithoutToNoteInput
    references?: noteReferenceUncheckedCreateNestedManyWithoutFromNoteInput
    comments?: commentsUncheckedCreateNestedManyWithoutNoteInput
    histories?: noteHistoryUncheckedCreateNestedManyWithoutNoteInput
    internalShares?: noteInternalShareUncheckedCreateNestedManyWithoutNoteInput
  }

  export type notesCreateOrConnectWithoutTagsInput = {
    where: notesWhereUniqueInput
    create: XOR<notesCreateWithoutTagsInput, notesUncheckedCreateWithoutTagsInput>
  }

  export type tagCreateWithoutTagsToNoteInput = {
    name?: string
    icon?: string
    parent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sortOrder?: number
    account?: accountsCreateNestedOneWithoutTagsInput
  }

  export type tagUncheckedCreateWithoutTagsToNoteInput = {
    id?: number
    name?: string
    icon?: string
    parent?: number
    accountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sortOrder?: number
  }

  export type tagCreateOrConnectWithoutTagsToNoteInput = {
    where: tagWhereUniqueInput
    create: XOR<tagCreateWithoutTagsToNoteInput, tagUncheckedCreateWithoutTagsToNoteInput>
  }

  export type notesUpsertWithoutTagsInput = {
    update: XOR<notesUpdateWithoutTagsInput, notesUncheckedUpdateWithoutTagsInput>
    create: XOR<notesCreateWithoutTagsInput, notesUncheckedCreateWithoutTagsInput>
    where?: notesWhereInput
  }

  export type notesUpdateToOneWithWhereWithoutTagsInput = {
    where?: notesWhereInput
    data: XOR<notesUpdateWithoutTagsInput, notesUncheckedUpdateWithoutTagsInput>
  }

  export type notesUpdateWithoutTagsInput = {
    type?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isRecycle?: BoolFieldUpdateOperationsInput | boolean
    isShare?: BoolFieldUpdateOperationsInput | boolean
    isTop?: BoolFieldUpdateOperationsInput | boolean
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    shareEncryptedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shareExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareMaxView?: NullableIntFieldUpdateOperationsInput | number | null
    shareViewCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: attachmentsUpdateManyWithoutNoteNestedInput
    account?: accountsUpdateOneWithoutNotesNestedInput
    referencedBy?: noteReferenceUpdateManyWithoutToNoteNestedInput
    references?: noteReferenceUpdateManyWithoutFromNoteNestedInput
    comments?: commentsUpdateManyWithoutNoteNestedInput
    histories?: noteHistoryUpdateManyWithoutNoteNestedInput
    internalShares?: noteInternalShareUpdateManyWithoutNoteNestedInput
  }

  export type notesUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isRecycle?: BoolFieldUpdateOperationsInput | boolean
    isShare?: BoolFieldUpdateOperationsInput | boolean
    isTop?: BoolFieldUpdateOperationsInput | boolean
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    shareEncryptedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shareExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareMaxView?: NullableIntFieldUpdateOperationsInput | number | null
    shareViewCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: attachmentsUncheckedUpdateManyWithoutNoteNestedInput
    referencedBy?: noteReferenceUncheckedUpdateManyWithoutToNoteNestedInput
    references?: noteReferenceUncheckedUpdateManyWithoutFromNoteNestedInput
    comments?: commentsUncheckedUpdateManyWithoutNoteNestedInput
    histories?: noteHistoryUncheckedUpdateManyWithoutNoteNestedInput
    internalShares?: noteInternalShareUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type tagUpsertWithoutTagsToNoteInput = {
    update: XOR<tagUpdateWithoutTagsToNoteInput, tagUncheckedUpdateWithoutTagsToNoteInput>
    create: XOR<tagCreateWithoutTagsToNoteInput, tagUncheckedCreateWithoutTagsToNoteInput>
    where?: tagWhereInput
  }

  export type tagUpdateToOneWithWhereWithoutTagsToNoteInput = {
    where?: tagWhereInput
    data: XOR<tagUpdateWithoutTagsToNoteInput, tagUncheckedUpdateWithoutTagsToNoteInput>
  }

  export type tagUpdateWithoutTagsToNoteInput = {
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    parent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    account?: accountsUpdateOneWithoutTagsNestedInput
  }

  export type tagUncheckedUpdateWithoutTagsToNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    parent?: IntFieldUpdateOperationsInput | number
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type notesCreateWithoutReferencesInput = {
    type?: number
    content?: string
    isArchived?: boolean
    isRecycle?: boolean
    isShare?: boolean
    isTop?: boolean
    isReviewed?: boolean
    sharePassword?: string
    shareEncryptedUrl?: string | null
    shareExpiryDate?: Date | string | null
    shareMaxView?: number | null
    shareViewCount?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: attachmentsCreateNestedManyWithoutNoteInput
    tags?: tagsToNoteCreateNestedManyWithoutNoteInput
    account?: accountsCreateNestedOneWithoutNotesInput
    referencedBy?: noteReferenceCreateNestedManyWithoutToNoteInput
    comments?: commentsCreateNestedManyWithoutNoteInput
    histories?: noteHistoryCreateNestedManyWithoutNoteInput
    internalShares?: noteInternalShareCreateNestedManyWithoutNoteInput
  }

  export type notesUncheckedCreateWithoutReferencesInput = {
    id?: number
    type?: number
    content?: string
    isArchived?: boolean
    isRecycle?: boolean
    isShare?: boolean
    isTop?: boolean
    isReviewed?: boolean
    sharePassword?: string
    shareEncryptedUrl?: string | null
    shareExpiryDate?: Date | string | null
    shareMaxView?: number | null
    shareViewCount?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId?: number | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: attachmentsUncheckedCreateNestedManyWithoutNoteInput
    tags?: tagsToNoteUncheckedCreateNestedManyWithoutNoteInput
    referencedBy?: noteReferenceUncheckedCreateNestedManyWithoutToNoteInput
    comments?: commentsUncheckedCreateNestedManyWithoutNoteInput
    histories?: noteHistoryUncheckedCreateNestedManyWithoutNoteInput
    internalShares?: noteInternalShareUncheckedCreateNestedManyWithoutNoteInput
  }

  export type notesCreateOrConnectWithoutReferencesInput = {
    where: notesWhereUniqueInput
    create: XOR<notesCreateWithoutReferencesInput, notesUncheckedCreateWithoutReferencesInput>
  }

  export type notesCreateWithoutReferencedByInput = {
    type?: number
    content?: string
    isArchived?: boolean
    isRecycle?: boolean
    isShare?: boolean
    isTop?: boolean
    isReviewed?: boolean
    sharePassword?: string
    shareEncryptedUrl?: string | null
    shareExpiryDate?: Date | string | null
    shareMaxView?: number | null
    shareViewCount?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: attachmentsCreateNestedManyWithoutNoteInput
    tags?: tagsToNoteCreateNestedManyWithoutNoteInput
    account?: accountsCreateNestedOneWithoutNotesInput
    references?: noteReferenceCreateNestedManyWithoutFromNoteInput
    comments?: commentsCreateNestedManyWithoutNoteInput
    histories?: noteHistoryCreateNestedManyWithoutNoteInput
    internalShares?: noteInternalShareCreateNestedManyWithoutNoteInput
  }

  export type notesUncheckedCreateWithoutReferencedByInput = {
    id?: number
    type?: number
    content?: string
    isArchived?: boolean
    isRecycle?: boolean
    isShare?: boolean
    isTop?: boolean
    isReviewed?: boolean
    sharePassword?: string
    shareEncryptedUrl?: string | null
    shareExpiryDate?: Date | string | null
    shareMaxView?: number | null
    shareViewCount?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId?: number | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: attachmentsUncheckedCreateNestedManyWithoutNoteInput
    tags?: tagsToNoteUncheckedCreateNestedManyWithoutNoteInput
    references?: noteReferenceUncheckedCreateNestedManyWithoutFromNoteInput
    comments?: commentsUncheckedCreateNestedManyWithoutNoteInput
    histories?: noteHistoryUncheckedCreateNestedManyWithoutNoteInput
    internalShares?: noteInternalShareUncheckedCreateNestedManyWithoutNoteInput
  }

  export type notesCreateOrConnectWithoutReferencedByInput = {
    where: notesWhereUniqueInput
    create: XOR<notesCreateWithoutReferencedByInput, notesUncheckedCreateWithoutReferencedByInput>
  }

  export type notesUpsertWithoutReferencesInput = {
    update: XOR<notesUpdateWithoutReferencesInput, notesUncheckedUpdateWithoutReferencesInput>
    create: XOR<notesCreateWithoutReferencesInput, notesUncheckedCreateWithoutReferencesInput>
    where?: notesWhereInput
  }

  export type notesUpdateToOneWithWhereWithoutReferencesInput = {
    where?: notesWhereInput
    data: XOR<notesUpdateWithoutReferencesInput, notesUncheckedUpdateWithoutReferencesInput>
  }

  export type notesUpdateWithoutReferencesInput = {
    type?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isRecycle?: BoolFieldUpdateOperationsInput | boolean
    isShare?: BoolFieldUpdateOperationsInput | boolean
    isTop?: BoolFieldUpdateOperationsInput | boolean
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    shareEncryptedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shareExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareMaxView?: NullableIntFieldUpdateOperationsInput | number | null
    shareViewCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: attachmentsUpdateManyWithoutNoteNestedInput
    tags?: tagsToNoteUpdateManyWithoutNoteNestedInput
    account?: accountsUpdateOneWithoutNotesNestedInput
    referencedBy?: noteReferenceUpdateManyWithoutToNoteNestedInput
    comments?: commentsUpdateManyWithoutNoteNestedInput
    histories?: noteHistoryUpdateManyWithoutNoteNestedInput
    internalShares?: noteInternalShareUpdateManyWithoutNoteNestedInput
  }

  export type notesUncheckedUpdateWithoutReferencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isRecycle?: BoolFieldUpdateOperationsInput | boolean
    isShare?: BoolFieldUpdateOperationsInput | boolean
    isTop?: BoolFieldUpdateOperationsInput | boolean
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    shareEncryptedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shareExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareMaxView?: NullableIntFieldUpdateOperationsInput | number | null
    shareViewCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: attachmentsUncheckedUpdateManyWithoutNoteNestedInput
    tags?: tagsToNoteUncheckedUpdateManyWithoutNoteNestedInput
    referencedBy?: noteReferenceUncheckedUpdateManyWithoutToNoteNestedInput
    comments?: commentsUncheckedUpdateManyWithoutNoteNestedInput
    histories?: noteHistoryUncheckedUpdateManyWithoutNoteNestedInput
    internalShares?: noteInternalShareUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type notesUpsertWithoutReferencedByInput = {
    update: XOR<notesUpdateWithoutReferencedByInput, notesUncheckedUpdateWithoutReferencedByInput>
    create: XOR<notesCreateWithoutReferencedByInput, notesUncheckedCreateWithoutReferencedByInput>
    where?: notesWhereInput
  }

  export type notesUpdateToOneWithWhereWithoutReferencedByInput = {
    where?: notesWhereInput
    data: XOR<notesUpdateWithoutReferencedByInput, notesUncheckedUpdateWithoutReferencedByInput>
  }

  export type notesUpdateWithoutReferencedByInput = {
    type?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isRecycle?: BoolFieldUpdateOperationsInput | boolean
    isShare?: BoolFieldUpdateOperationsInput | boolean
    isTop?: BoolFieldUpdateOperationsInput | boolean
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    shareEncryptedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shareExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareMaxView?: NullableIntFieldUpdateOperationsInput | number | null
    shareViewCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: attachmentsUpdateManyWithoutNoteNestedInput
    tags?: tagsToNoteUpdateManyWithoutNoteNestedInput
    account?: accountsUpdateOneWithoutNotesNestedInput
    references?: noteReferenceUpdateManyWithoutFromNoteNestedInput
    comments?: commentsUpdateManyWithoutNoteNestedInput
    histories?: noteHistoryUpdateManyWithoutNoteNestedInput
    internalShares?: noteInternalShareUpdateManyWithoutNoteNestedInput
  }

  export type notesUncheckedUpdateWithoutReferencedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isRecycle?: BoolFieldUpdateOperationsInput | boolean
    isShare?: BoolFieldUpdateOperationsInput | boolean
    isTop?: BoolFieldUpdateOperationsInput | boolean
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    shareEncryptedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shareExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareMaxView?: NullableIntFieldUpdateOperationsInput | number | null
    shareViewCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: attachmentsUncheckedUpdateManyWithoutNoteNestedInput
    tags?: tagsToNoteUncheckedUpdateManyWithoutNoteNestedInput
    references?: noteReferenceUncheckedUpdateManyWithoutFromNoteNestedInput
    comments?: commentsUncheckedUpdateManyWithoutNoteNestedInput
    histories?: noteHistoryUncheckedUpdateManyWithoutNoteNestedInput
    internalShares?: noteInternalShareUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type accountsCreateWithoutFollowsInput = {
    name?: string
    nickname?: string
    password?: string
    image?: string
    apiToken?: string
    description?: string
    note?: number
    role?: string
    loginType?: string
    linkAccountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: notesCreateNestedManyWithoutAccountInput
    configs?: configCreateNestedManyWithoutUserInput
    tags?: tagCreateNestedManyWithoutAccountInput
    comments?: commentsCreateNestedManyWithoutAccountInput
    attachments?: attachmentsCreateNestedManyWithoutAccountInput
    notifications?: notificationsCreateNestedManyWithoutAccountInput
    conversations?: conversationCreateNestedManyWithoutAccountInput
    sharedNotes?: noteInternalShareCreateNestedManyWithoutAccountInput
    aiScheduledTasks?: aiScheduledTaskCreateNestedManyWithoutAccountInput
  }

  export type accountsUncheckedCreateWithoutFollowsInput = {
    id?: number
    name?: string
    nickname?: string
    password?: string
    image?: string
    apiToken?: string
    description?: string
    note?: number
    role?: string
    loginType?: string
    linkAccountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: notesUncheckedCreateNestedManyWithoutAccountInput
    configs?: configUncheckedCreateNestedManyWithoutUserInput
    tags?: tagUncheckedCreateNestedManyWithoutAccountInput
    comments?: commentsUncheckedCreateNestedManyWithoutAccountInput
    attachments?: attachmentsUncheckedCreateNestedManyWithoutAccountInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutAccountInput
    conversations?: conversationUncheckedCreateNestedManyWithoutAccountInput
    sharedNotes?: noteInternalShareUncheckedCreateNestedManyWithoutAccountInput
    aiScheduledTasks?: aiScheduledTaskUncheckedCreateNestedManyWithoutAccountInput
  }

  export type accountsCreateOrConnectWithoutFollowsInput = {
    where: accountsWhereUniqueInput
    create: XOR<accountsCreateWithoutFollowsInput, accountsUncheckedCreateWithoutFollowsInput>
  }

  export type accountsUpsertWithoutFollowsInput = {
    update: XOR<accountsUpdateWithoutFollowsInput, accountsUncheckedUpdateWithoutFollowsInput>
    create: XOR<accountsCreateWithoutFollowsInput, accountsUncheckedCreateWithoutFollowsInput>
    where?: accountsWhereInput
  }

  export type accountsUpdateToOneWithWhereWithoutFollowsInput = {
    where?: accountsWhereInput
    data: XOR<accountsUpdateWithoutFollowsInput, accountsUncheckedUpdateWithoutFollowsInput>
  }

  export type accountsUpdateWithoutFollowsInput = {
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    apiToken?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    note?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    loginType?: StringFieldUpdateOperationsInput | string
    linkAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: notesUpdateManyWithoutAccountNestedInput
    configs?: configUpdateManyWithoutUserNestedInput
    tags?: tagUpdateManyWithoutAccountNestedInput
    comments?: commentsUpdateManyWithoutAccountNestedInput
    attachments?: attachmentsUpdateManyWithoutAccountNestedInput
    notifications?: notificationsUpdateManyWithoutAccountNestedInput
    conversations?: conversationUpdateManyWithoutAccountNestedInput
    sharedNotes?: noteInternalShareUpdateManyWithoutAccountNestedInput
    aiScheduledTasks?: aiScheduledTaskUpdateManyWithoutAccountNestedInput
  }

  export type accountsUncheckedUpdateWithoutFollowsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    apiToken?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    note?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    loginType?: StringFieldUpdateOperationsInput | string
    linkAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: notesUncheckedUpdateManyWithoutAccountNestedInput
    configs?: configUncheckedUpdateManyWithoutUserNestedInput
    tags?: tagUncheckedUpdateManyWithoutAccountNestedInput
    comments?: commentsUncheckedUpdateManyWithoutAccountNestedInput
    attachments?: attachmentsUncheckedUpdateManyWithoutAccountNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutAccountNestedInput
    conversations?: conversationUncheckedUpdateManyWithoutAccountNestedInput
    sharedNotes?: noteInternalShareUncheckedUpdateManyWithoutAccountNestedInput
    aiScheduledTasks?: aiScheduledTaskUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type accountsCreateWithoutNotificationsInput = {
    name?: string
    nickname?: string
    password?: string
    image?: string
    apiToken?: string
    description?: string
    note?: number
    role?: string
    loginType?: string
    linkAccountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: notesCreateNestedManyWithoutAccountInput
    configs?: configCreateNestedManyWithoutUserInput
    tags?: tagCreateNestedManyWithoutAccountInput
    comments?: commentsCreateNestedManyWithoutAccountInput
    attachments?: attachmentsCreateNestedManyWithoutAccountInput
    follows?: followsCreateNestedManyWithoutAccountInput
    conversations?: conversationCreateNestedManyWithoutAccountInput
    sharedNotes?: noteInternalShareCreateNestedManyWithoutAccountInput
    aiScheduledTasks?: aiScheduledTaskCreateNestedManyWithoutAccountInput
  }

  export type accountsUncheckedCreateWithoutNotificationsInput = {
    id?: number
    name?: string
    nickname?: string
    password?: string
    image?: string
    apiToken?: string
    description?: string
    note?: number
    role?: string
    loginType?: string
    linkAccountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: notesUncheckedCreateNestedManyWithoutAccountInput
    configs?: configUncheckedCreateNestedManyWithoutUserInput
    tags?: tagUncheckedCreateNestedManyWithoutAccountInput
    comments?: commentsUncheckedCreateNestedManyWithoutAccountInput
    attachments?: attachmentsUncheckedCreateNestedManyWithoutAccountInput
    follows?: followsUncheckedCreateNestedManyWithoutAccountInput
    conversations?: conversationUncheckedCreateNestedManyWithoutAccountInput
    sharedNotes?: noteInternalShareUncheckedCreateNestedManyWithoutAccountInput
    aiScheduledTasks?: aiScheduledTaskUncheckedCreateNestedManyWithoutAccountInput
  }

  export type accountsCreateOrConnectWithoutNotificationsInput = {
    where: accountsWhereUniqueInput
    create: XOR<accountsCreateWithoutNotificationsInput, accountsUncheckedCreateWithoutNotificationsInput>
  }

  export type accountsUpsertWithoutNotificationsInput = {
    update: XOR<accountsUpdateWithoutNotificationsInput, accountsUncheckedUpdateWithoutNotificationsInput>
    create: XOR<accountsCreateWithoutNotificationsInput, accountsUncheckedCreateWithoutNotificationsInput>
    where?: accountsWhereInput
  }

  export type accountsUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: accountsWhereInput
    data: XOR<accountsUpdateWithoutNotificationsInput, accountsUncheckedUpdateWithoutNotificationsInput>
  }

  export type accountsUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    apiToken?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    note?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    loginType?: StringFieldUpdateOperationsInput | string
    linkAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: notesUpdateManyWithoutAccountNestedInput
    configs?: configUpdateManyWithoutUserNestedInput
    tags?: tagUpdateManyWithoutAccountNestedInput
    comments?: commentsUpdateManyWithoutAccountNestedInput
    attachments?: attachmentsUpdateManyWithoutAccountNestedInput
    follows?: followsUpdateManyWithoutAccountNestedInput
    conversations?: conversationUpdateManyWithoutAccountNestedInput
    sharedNotes?: noteInternalShareUpdateManyWithoutAccountNestedInput
    aiScheduledTasks?: aiScheduledTaskUpdateManyWithoutAccountNestedInput
  }

  export type accountsUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    apiToken?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    note?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    loginType?: StringFieldUpdateOperationsInput | string
    linkAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: notesUncheckedUpdateManyWithoutAccountNestedInput
    configs?: configUncheckedUpdateManyWithoutUserNestedInput
    tags?: tagUncheckedUpdateManyWithoutAccountNestedInput
    comments?: commentsUncheckedUpdateManyWithoutAccountNestedInput
    attachments?: attachmentsUncheckedUpdateManyWithoutAccountNestedInput
    follows?: followsUncheckedUpdateManyWithoutAccountNestedInput
    conversations?: conversationUncheckedUpdateManyWithoutAccountNestedInput
    sharedNotes?: noteInternalShareUncheckedUpdateManyWithoutAccountNestedInput
    aiScheduledTasks?: aiScheduledTaskUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type messageCreateWithoutConversationInput = {
    content: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type messageUncheckedCreateWithoutConversationInput = {
    id?: number
    content: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type messageCreateOrConnectWithoutConversationInput = {
    where: messageWhereUniqueInput
    create: XOR<messageCreateWithoutConversationInput, messageUncheckedCreateWithoutConversationInput>
  }

  export type messageCreateManyConversationInputEnvelope = {
    data: messageCreateManyConversationInput | messageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type accountsCreateWithoutConversationsInput = {
    name?: string
    nickname?: string
    password?: string
    image?: string
    apiToken?: string
    description?: string
    note?: number
    role?: string
    loginType?: string
    linkAccountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: notesCreateNestedManyWithoutAccountInput
    configs?: configCreateNestedManyWithoutUserInput
    tags?: tagCreateNestedManyWithoutAccountInput
    comments?: commentsCreateNestedManyWithoutAccountInput
    attachments?: attachmentsCreateNestedManyWithoutAccountInput
    follows?: followsCreateNestedManyWithoutAccountInput
    notifications?: notificationsCreateNestedManyWithoutAccountInput
    sharedNotes?: noteInternalShareCreateNestedManyWithoutAccountInput
    aiScheduledTasks?: aiScheduledTaskCreateNestedManyWithoutAccountInput
  }

  export type accountsUncheckedCreateWithoutConversationsInput = {
    id?: number
    name?: string
    nickname?: string
    password?: string
    image?: string
    apiToken?: string
    description?: string
    note?: number
    role?: string
    loginType?: string
    linkAccountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: notesUncheckedCreateNestedManyWithoutAccountInput
    configs?: configUncheckedCreateNestedManyWithoutUserInput
    tags?: tagUncheckedCreateNestedManyWithoutAccountInput
    comments?: commentsUncheckedCreateNestedManyWithoutAccountInput
    attachments?: attachmentsUncheckedCreateNestedManyWithoutAccountInput
    follows?: followsUncheckedCreateNestedManyWithoutAccountInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutAccountInput
    sharedNotes?: noteInternalShareUncheckedCreateNestedManyWithoutAccountInput
    aiScheduledTasks?: aiScheduledTaskUncheckedCreateNestedManyWithoutAccountInput
  }

  export type accountsCreateOrConnectWithoutConversationsInput = {
    where: accountsWhereUniqueInput
    create: XOR<accountsCreateWithoutConversationsInput, accountsUncheckedCreateWithoutConversationsInput>
  }

  export type messageUpsertWithWhereUniqueWithoutConversationInput = {
    where: messageWhereUniqueInput
    update: XOR<messageUpdateWithoutConversationInput, messageUncheckedUpdateWithoutConversationInput>
    create: XOR<messageCreateWithoutConversationInput, messageUncheckedCreateWithoutConversationInput>
  }

  export type messageUpdateWithWhereUniqueWithoutConversationInput = {
    where: messageWhereUniqueInput
    data: XOR<messageUpdateWithoutConversationInput, messageUncheckedUpdateWithoutConversationInput>
  }

  export type messageUpdateManyWithWhereWithoutConversationInput = {
    where: messageScalarWhereInput
    data: XOR<messageUpdateManyMutationInput, messageUncheckedUpdateManyWithoutConversationInput>
  }

  export type messageScalarWhereInput = {
    AND?: messageScalarWhereInput | messageScalarWhereInput[]
    OR?: messageScalarWhereInput[]
    NOT?: messageScalarWhereInput | messageScalarWhereInput[]
    id?: IntFilter<"message"> | number
    content?: StringFilter<"message"> | string
    role?: StringFilter<"message"> | string
    conversationId?: IntFilter<"message"> | number
    createdAt?: DateTimeFilter<"message"> | Date | string
    updatedAt?: DateTimeFilter<"message"> | Date | string
    metadata?: JsonNullableFilter<"message">
  }

  export type accountsUpsertWithoutConversationsInput = {
    update: XOR<accountsUpdateWithoutConversationsInput, accountsUncheckedUpdateWithoutConversationsInput>
    create: XOR<accountsCreateWithoutConversationsInput, accountsUncheckedCreateWithoutConversationsInput>
    where?: accountsWhereInput
  }

  export type accountsUpdateToOneWithWhereWithoutConversationsInput = {
    where?: accountsWhereInput
    data: XOR<accountsUpdateWithoutConversationsInput, accountsUncheckedUpdateWithoutConversationsInput>
  }

  export type accountsUpdateWithoutConversationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    apiToken?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    note?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    loginType?: StringFieldUpdateOperationsInput | string
    linkAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: notesUpdateManyWithoutAccountNestedInput
    configs?: configUpdateManyWithoutUserNestedInput
    tags?: tagUpdateManyWithoutAccountNestedInput
    comments?: commentsUpdateManyWithoutAccountNestedInput
    attachments?: attachmentsUpdateManyWithoutAccountNestedInput
    follows?: followsUpdateManyWithoutAccountNestedInput
    notifications?: notificationsUpdateManyWithoutAccountNestedInput
    sharedNotes?: noteInternalShareUpdateManyWithoutAccountNestedInput
    aiScheduledTasks?: aiScheduledTaskUpdateManyWithoutAccountNestedInput
  }

  export type accountsUncheckedUpdateWithoutConversationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    apiToken?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    note?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    loginType?: StringFieldUpdateOperationsInput | string
    linkAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: notesUncheckedUpdateManyWithoutAccountNestedInput
    configs?: configUncheckedUpdateManyWithoutUserNestedInput
    tags?: tagUncheckedUpdateManyWithoutAccountNestedInput
    comments?: commentsUncheckedUpdateManyWithoutAccountNestedInput
    attachments?: attachmentsUncheckedUpdateManyWithoutAccountNestedInput
    follows?: followsUncheckedUpdateManyWithoutAccountNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutAccountNestedInput
    sharedNotes?: noteInternalShareUncheckedUpdateManyWithoutAccountNestedInput
    aiScheduledTasks?: aiScheduledTaskUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type conversationCreateWithoutMessagesInput = {
    title?: string
    isShare?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    account: accountsCreateNestedOneWithoutConversationsInput
  }

  export type conversationUncheckedCreateWithoutMessagesInput = {
    id?: number
    title?: string
    isShare?: boolean
    accountId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type conversationCreateOrConnectWithoutMessagesInput = {
    where: conversationWhereUniqueInput
    create: XOR<conversationCreateWithoutMessagesInput, conversationUncheckedCreateWithoutMessagesInput>
  }

  export type conversationUpsertWithoutMessagesInput = {
    update: XOR<conversationUpdateWithoutMessagesInput, conversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<conversationCreateWithoutMessagesInput, conversationUncheckedCreateWithoutMessagesInput>
    where?: conversationWhereInput
  }

  export type conversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: conversationWhereInput
    data: XOR<conversationUpdateWithoutMessagesInput, conversationUncheckedUpdateWithoutMessagesInput>
  }

  export type conversationUpdateWithoutMessagesInput = {
    title?: StringFieldUpdateOperationsInput | string
    isShare?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: accountsUpdateOneRequiredWithoutConversationsNestedInput
  }

  export type conversationUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    isShare?: BoolFieldUpdateOperationsInput | boolean
    accountId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notesCreateWithoutHistoriesInput = {
    type?: number
    content?: string
    isArchived?: boolean
    isRecycle?: boolean
    isShare?: boolean
    isTop?: boolean
    isReviewed?: boolean
    sharePassword?: string
    shareEncryptedUrl?: string | null
    shareExpiryDate?: Date | string | null
    shareMaxView?: number | null
    shareViewCount?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: attachmentsCreateNestedManyWithoutNoteInput
    tags?: tagsToNoteCreateNestedManyWithoutNoteInput
    account?: accountsCreateNestedOneWithoutNotesInput
    referencedBy?: noteReferenceCreateNestedManyWithoutToNoteInput
    references?: noteReferenceCreateNestedManyWithoutFromNoteInput
    comments?: commentsCreateNestedManyWithoutNoteInput
    internalShares?: noteInternalShareCreateNestedManyWithoutNoteInput
  }

  export type notesUncheckedCreateWithoutHistoriesInput = {
    id?: number
    type?: number
    content?: string
    isArchived?: boolean
    isRecycle?: boolean
    isShare?: boolean
    isTop?: boolean
    isReviewed?: boolean
    sharePassword?: string
    shareEncryptedUrl?: string | null
    shareExpiryDate?: Date | string | null
    shareMaxView?: number | null
    shareViewCount?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId?: number | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: attachmentsUncheckedCreateNestedManyWithoutNoteInput
    tags?: tagsToNoteUncheckedCreateNestedManyWithoutNoteInput
    referencedBy?: noteReferenceUncheckedCreateNestedManyWithoutToNoteInput
    references?: noteReferenceUncheckedCreateNestedManyWithoutFromNoteInput
    comments?: commentsUncheckedCreateNestedManyWithoutNoteInput
    internalShares?: noteInternalShareUncheckedCreateNestedManyWithoutNoteInput
  }

  export type notesCreateOrConnectWithoutHistoriesInput = {
    where: notesWhereUniqueInput
    create: XOR<notesCreateWithoutHistoriesInput, notesUncheckedCreateWithoutHistoriesInput>
  }

  export type notesUpsertWithoutHistoriesInput = {
    update: XOR<notesUpdateWithoutHistoriesInput, notesUncheckedUpdateWithoutHistoriesInput>
    create: XOR<notesCreateWithoutHistoriesInput, notesUncheckedCreateWithoutHistoriesInput>
    where?: notesWhereInput
  }

  export type notesUpdateToOneWithWhereWithoutHistoriesInput = {
    where?: notesWhereInput
    data: XOR<notesUpdateWithoutHistoriesInput, notesUncheckedUpdateWithoutHistoriesInput>
  }

  export type notesUpdateWithoutHistoriesInput = {
    type?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isRecycle?: BoolFieldUpdateOperationsInput | boolean
    isShare?: BoolFieldUpdateOperationsInput | boolean
    isTop?: BoolFieldUpdateOperationsInput | boolean
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    shareEncryptedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shareExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareMaxView?: NullableIntFieldUpdateOperationsInput | number | null
    shareViewCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: attachmentsUpdateManyWithoutNoteNestedInput
    tags?: tagsToNoteUpdateManyWithoutNoteNestedInput
    account?: accountsUpdateOneWithoutNotesNestedInput
    referencedBy?: noteReferenceUpdateManyWithoutToNoteNestedInput
    references?: noteReferenceUpdateManyWithoutFromNoteNestedInput
    comments?: commentsUpdateManyWithoutNoteNestedInput
    internalShares?: noteInternalShareUpdateManyWithoutNoteNestedInput
  }

  export type notesUncheckedUpdateWithoutHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isRecycle?: BoolFieldUpdateOperationsInput | boolean
    isShare?: BoolFieldUpdateOperationsInput | boolean
    isTop?: BoolFieldUpdateOperationsInput | boolean
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    shareEncryptedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shareExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareMaxView?: NullableIntFieldUpdateOperationsInput | number | null
    shareViewCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: attachmentsUncheckedUpdateManyWithoutNoteNestedInput
    tags?: tagsToNoteUncheckedUpdateManyWithoutNoteNestedInput
    referencedBy?: noteReferenceUncheckedUpdateManyWithoutToNoteNestedInput
    references?: noteReferenceUncheckedUpdateManyWithoutFromNoteNestedInput
    comments?: commentsUncheckedUpdateManyWithoutNoteNestedInput
    internalShares?: noteInternalShareUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type notesCreateWithoutInternalSharesInput = {
    type?: number
    content?: string
    isArchived?: boolean
    isRecycle?: boolean
    isShare?: boolean
    isTop?: boolean
    isReviewed?: boolean
    sharePassword?: string
    shareEncryptedUrl?: string | null
    shareExpiryDate?: Date | string | null
    shareMaxView?: number | null
    shareViewCount?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: attachmentsCreateNestedManyWithoutNoteInput
    tags?: tagsToNoteCreateNestedManyWithoutNoteInput
    account?: accountsCreateNestedOneWithoutNotesInput
    referencedBy?: noteReferenceCreateNestedManyWithoutToNoteInput
    references?: noteReferenceCreateNestedManyWithoutFromNoteInput
    comments?: commentsCreateNestedManyWithoutNoteInput
    histories?: noteHistoryCreateNestedManyWithoutNoteInput
  }

  export type notesUncheckedCreateWithoutInternalSharesInput = {
    id?: number
    type?: number
    content?: string
    isArchived?: boolean
    isRecycle?: boolean
    isShare?: boolean
    isTop?: boolean
    isReviewed?: boolean
    sharePassword?: string
    shareEncryptedUrl?: string | null
    shareExpiryDate?: Date | string | null
    shareMaxView?: number | null
    shareViewCount?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId?: number | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: attachmentsUncheckedCreateNestedManyWithoutNoteInput
    tags?: tagsToNoteUncheckedCreateNestedManyWithoutNoteInput
    referencedBy?: noteReferenceUncheckedCreateNestedManyWithoutToNoteInput
    references?: noteReferenceUncheckedCreateNestedManyWithoutFromNoteInput
    comments?: commentsUncheckedCreateNestedManyWithoutNoteInput
    histories?: noteHistoryUncheckedCreateNestedManyWithoutNoteInput
  }

  export type notesCreateOrConnectWithoutInternalSharesInput = {
    where: notesWhereUniqueInput
    create: XOR<notesCreateWithoutInternalSharesInput, notesUncheckedCreateWithoutInternalSharesInput>
  }

  export type accountsCreateWithoutSharedNotesInput = {
    name?: string
    nickname?: string
    password?: string
    image?: string
    apiToken?: string
    description?: string
    note?: number
    role?: string
    loginType?: string
    linkAccountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: notesCreateNestedManyWithoutAccountInput
    configs?: configCreateNestedManyWithoutUserInput
    tags?: tagCreateNestedManyWithoutAccountInput
    comments?: commentsCreateNestedManyWithoutAccountInput
    attachments?: attachmentsCreateNestedManyWithoutAccountInput
    follows?: followsCreateNestedManyWithoutAccountInput
    notifications?: notificationsCreateNestedManyWithoutAccountInput
    conversations?: conversationCreateNestedManyWithoutAccountInput
    aiScheduledTasks?: aiScheduledTaskCreateNestedManyWithoutAccountInput
  }

  export type accountsUncheckedCreateWithoutSharedNotesInput = {
    id?: number
    name?: string
    nickname?: string
    password?: string
    image?: string
    apiToken?: string
    description?: string
    note?: number
    role?: string
    loginType?: string
    linkAccountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: notesUncheckedCreateNestedManyWithoutAccountInput
    configs?: configUncheckedCreateNestedManyWithoutUserInput
    tags?: tagUncheckedCreateNestedManyWithoutAccountInput
    comments?: commentsUncheckedCreateNestedManyWithoutAccountInput
    attachments?: attachmentsUncheckedCreateNestedManyWithoutAccountInput
    follows?: followsUncheckedCreateNestedManyWithoutAccountInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutAccountInput
    conversations?: conversationUncheckedCreateNestedManyWithoutAccountInput
    aiScheduledTasks?: aiScheduledTaskUncheckedCreateNestedManyWithoutAccountInput
  }

  export type accountsCreateOrConnectWithoutSharedNotesInput = {
    where: accountsWhereUniqueInput
    create: XOR<accountsCreateWithoutSharedNotesInput, accountsUncheckedCreateWithoutSharedNotesInput>
  }

  export type notesUpsertWithoutInternalSharesInput = {
    update: XOR<notesUpdateWithoutInternalSharesInput, notesUncheckedUpdateWithoutInternalSharesInput>
    create: XOR<notesCreateWithoutInternalSharesInput, notesUncheckedCreateWithoutInternalSharesInput>
    where?: notesWhereInput
  }

  export type notesUpdateToOneWithWhereWithoutInternalSharesInput = {
    where?: notesWhereInput
    data: XOR<notesUpdateWithoutInternalSharesInput, notesUncheckedUpdateWithoutInternalSharesInput>
  }

  export type notesUpdateWithoutInternalSharesInput = {
    type?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isRecycle?: BoolFieldUpdateOperationsInput | boolean
    isShare?: BoolFieldUpdateOperationsInput | boolean
    isTop?: BoolFieldUpdateOperationsInput | boolean
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    shareEncryptedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shareExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareMaxView?: NullableIntFieldUpdateOperationsInput | number | null
    shareViewCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: attachmentsUpdateManyWithoutNoteNestedInput
    tags?: tagsToNoteUpdateManyWithoutNoteNestedInput
    account?: accountsUpdateOneWithoutNotesNestedInput
    referencedBy?: noteReferenceUpdateManyWithoutToNoteNestedInput
    references?: noteReferenceUpdateManyWithoutFromNoteNestedInput
    comments?: commentsUpdateManyWithoutNoteNestedInput
    histories?: noteHistoryUpdateManyWithoutNoteNestedInput
  }

  export type notesUncheckedUpdateWithoutInternalSharesInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isRecycle?: BoolFieldUpdateOperationsInput | boolean
    isShare?: BoolFieldUpdateOperationsInput | boolean
    isTop?: BoolFieldUpdateOperationsInput | boolean
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    shareEncryptedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shareExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareMaxView?: NullableIntFieldUpdateOperationsInput | number | null
    shareViewCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: attachmentsUncheckedUpdateManyWithoutNoteNestedInput
    tags?: tagsToNoteUncheckedUpdateManyWithoutNoteNestedInput
    referencedBy?: noteReferenceUncheckedUpdateManyWithoutToNoteNestedInput
    references?: noteReferenceUncheckedUpdateManyWithoutFromNoteNestedInput
    comments?: commentsUncheckedUpdateManyWithoutNoteNestedInput
    histories?: noteHistoryUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type accountsUpsertWithoutSharedNotesInput = {
    update: XOR<accountsUpdateWithoutSharedNotesInput, accountsUncheckedUpdateWithoutSharedNotesInput>
    create: XOR<accountsCreateWithoutSharedNotesInput, accountsUncheckedCreateWithoutSharedNotesInput>
    where?: accountsWhereInput
  }

  export type accountsUpdateToOneWithWhereWithoutSharedNotesInput = {
    where?: accountsWhereInput
    data: XOR<accountsUpdateWithoutSharedNotesInput, accountsUncheckedUpdateWithoutSharedNotesInput>
  }

  export type accountsUpdateWithoutSharedNotesInput = {
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    apiToken?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    note?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    loginType?: StringFieldUpdateOperationsInput | string
    linkAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: notesUpdateManyWithoutAccountNestedInput
    configs?: configUpdateManyWithoutUserNestedInput
    tags?: tagUpdateManyWithoutAccountNestedInput
    comments?: commentsUpdateManyWithoutAccountNestedInput
    attachments?: attachmentsUpdateManyWithoutAccountNestedInput
    follows?: followsUpdateManyWithoutAccountNestedInput
    notifications?: notificationsUpdateManyWithoutAccountNestedInput
    conversations?: conversationUpdateManyWithoutAccountNestedInput
    aiScheduledTasks?: aiScheduledTaskUpdateManyWithoutAccountNestedInput
  }

  export type accountsUncheckedUpdateWithoutSharedNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    apiToken?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    note?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    loginType?: StringFieldUpdateOperationsInput | string
    linkAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: notesUncheckedUpdateManyWithoutAccountNestedInput
    configs?: configUncheckedUpdateManyWithoutUserNestedInput
    tags?: tagUncheckedUpdateManyWithoutAccountNestedInput
    comments?: commentsUncheckedUpdateManyWithoutAccountNestedInput
    attachments?: attachmentsUncheckedUpdateManyWithoutAccountNestedInput
    follows?: followsUncheckedUpdateManyWithoutAccountNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutAccountNestedInput
    conversations?: conversationUncheckedUpdateManyWithoutAccountNestedInput
    aiScheduledTasks?: aiScheduledTaskUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type aiModelsCreateWithoutProviderInput = {
    title: string
    modelKey: string
    capabilities: JsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type aiModelsUncheckedCreateWithoutProviderInput = {
    id?: number
    title: string
    modelKey: string
    capabilities: JsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type aiModelsCreateOrConnectWithoutProviderInput = {
    where: aiModelsWhereUniqueInput
    create: XOR<aiModelsCreateWithoutProviderInput, aiModelsUncheckedCreateWithoutProviderInput>
  }

  export type aiModelsCreateManyProviderInputEnvelope = {
    data: aiModelsCreateManyProviderInput | aiModelsCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type aiModelsUpsertWithWhereUniqueWithoutProviderInput = {
    where: aiModelsWhereUniqueInput
    update: XOR<aiModelsUpdateWithoutProviderInput, aiModelsUncheckedUpdateWithoutProviderInput>
    create: XOR<aiModelsCreateWithoutProviderInput, aiModelsUncheckedCreateWithoutProviderInput>
  }

  export type aiModelsUpdateWithWhereUniqueWithoutProviderInput = {
    where: aiModelsWhereUniqueInput
    data: XOR<aiModelsUpdateWithoutProviderInput, aiModelsUncheckedUpdateWithoutProviderInput>
  }

  export type aiModelsUpdateManyWithWhereWithoutProviderInput = {
    where: aiModelsScalarWhereInput
    data: XOR<aiModelsUpdateManyMutationInput, aiModelsUncheckedUpdateManyWithoutProviderInput>
  }

  export type aiModelsScalarWhereInput = {
    AND?: aiModelsScalarWhereInput | aiModelsScalarWhereInput[]
    OR?: aiModelsScalarWhereInput[]
    NOT?: aiModelsScalarWhereInput | aiModelsScalarWhereInput[]
    id?: IntFilter<"aiModels"> | number
    providerId?: IntFilter<"aiModels"> | number
    title?: StringFilter<"aiModels"> | string
    modelKey?: StringFilter<"aiModels"> | string
    capabilities?: JsonFilter<"aiModels">
    config?: JsonNullableFilter<"aiModels">
    sortOrder?: IntFilter<"aiModels"> | number
    createdAt?: DateTimeFilter<"aiModels"> | Date | string
    updatedAt?: DateTimeFilter<"aiModels"> | Date | string
  }

  export type aiProvidersCreateWithoutModelsInput = {
    title: string
    provider: string
    baseURL?: string | null
    apiKey?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type aiProvidersUncheckedCreateWithoutModelsInput = {
    id?: number
    title: string
    provider: string
    baseURL?: string | null
    apiKey?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type aiProvidersCreateOrConnectWithoutModelsInput = {
    where: aiProvidersWhereUniqueInput
    create: XOR<aiProvidersCreateWithoutModelsInput, aiProvidersUncheckedCreateWithoutModelsInput>
  }

  export type aiProvidersUpsertWithoutModelsInput = {
    update: XOR<aiProvidersUpdateWithoutModelsInput, aiProvidersUncheckedUpdateWithoutModelsInput>
    create: XOR<aiProvidersCreateWithoutModelsInput, aiProvidersUncheckedCreateWithoutModelsInput>
    where?: aiProvidersWhereInput
  }

  export type aiProvidersUpdateToOneWithWhereWithoutModelsInput = {
    where?: aiProvidersWhereInput
    data: XOR<aiProvidersUpdateWithoutModelsInput, aiProvidersUncheckedUpdateWithoutModelsInput>
  }

  export type aiProvidersUpdateWithoutModelsInput = {
    title?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    baseURL?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type aiProvidersUncheckedUpdateWithoutModelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    baseURL?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type accountsCreateWithoutAiScheduledTasksInput = {
    name?: string
    nickname?: string
    password?: string
    image?: string
    apiToken?: string
    description?: string
    note?: number
    role?: string
    loginType?: string
    linkAccountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: notesCreateNestedManyWithoutAccountInput
    configs?: configCreateNestedManyWithoutUserInput
    tags?: tagCreateNestedManyWithoutAccountInput
    comments?: commentsCreateNestedManyWithoutAccountInput
    attachments?: attachmentsCreateNestedManyWithoutAccountInput
    follows?: followsCreateNestedManyWithoutAccountInput
    notifications?: notificationsCreateNestedManyWithoutAccountInput
    conversations?: conversationCreateNestedManyWithoutAccountInput
    sharedNotes?: noteInternalShareCreateNestedManyWithoutAccountInput
  }

  export type accountsUncheckedCreateWithoutAiScheduledTasksInput = {
    id?: number
    name?: string
    nickname?: string
    password?: string
    image?: string
    apiToken?: string
    description?: string
    note?: number
    role?: string
    loginType?: string
    linkAccountId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: notesUncheckedCreateNestedManyWithoutAccountInput
    configs?: configUncheckedCreateNestedManyWithoutUserInput
    tags?: tagUncheckedCreateNestedManyWithoutAccountInput
    comments?: commentsUncheckedCreateNestedManyWithoutAccountInput
    attachments?: attachmentsUncheckedCreateNestedManyWithoutAccountInput
    follows?: followsUncheckedCreateNestedManyWithoutAccountInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutAccountInput
    conversations?: conversationUncheckedCreateNestedManyWithoutAccountInput
    sharedNotes?: noteInternalShareUncheckedCreateNestedManyWithoutAccountInput
  }

  export type accountsCreateOrConnectWithoutAiScheduledTasksInput = {
    where: accountsWhereUniqueInput
    create: XOR<accountsCreateWithoutAiScheduledTasksInput, accountsUncheckedCreateWithoutAiScheduledTasksInput>
  }

  export type accountsUpsertWithoutAiScheduledTasksInput = {
    update: XOR<accountsUpdateWithoutAiScheduledTasksInput, accountsUncheckedUpdateWithoutAiScheduledTasksInput>
    create: XOR<accountsCreateWithoutAiScheduledTasksInput, accountsUncheckedCreateWithoutAiScheduledTasksInput>
    where?: accountsWhereInput
  }

  export type accountsUpdateToOneWithWhereWithoutAiScheduledTasksInput = {
    where?: accountsWhereInput
    data: XOR<accountsUpdateWithoutAiScheduledTasksInput, accountsUncheckedUpdateWithoutAiScheduledTasksInput>
  }

  export type accountsUpdateWithoutAiScheduledTasksInput = {
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    apiToken?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    note?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    loginType?: StringFieldUpdateOperationsInput | string
    linkAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: notesUpdateManyWithoutAccountNestedInput
    configs?: configUpdateManyWithoutUserNestedInput
    tags?: tagUpdateManyWithoutAccountNestedInput
    comments?: commentsUpdateManyWithoutAccountNestedInput
    attachments?: attachmentsUpdateManyWithoutAccountNestedInput
    follows?: followsUpdateManyWithoutAccountNestedInput
    notifications?: notificationsUpdateManyWithoutAccountNestedInput
    conversations?: conversationUpdateManyWithoutAccountNestedInput
    sharedNotes?: noteInternalShareUpdateManyWithoutAccountNestedInput
  }

  export type accountsUncheckedUpdateWithoutAiScheduledTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    apiToken?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    note?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    loginType?: StringFieldUpdateOperationsInput | string
    linkAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: notesUncheckedUpdateManyWithoutAccountNestedInput
    configs?: configUncheckedUpdateManyWithoutUserNestedInput
    tags?: tagUncheckedUpdateManyWithoutAccountNestedInput
    comments?: commentsUncheckedUpdateManyWithoutAccountNestedInput
    attachments?: attachmentsUncheckedUpdateManyWithoutAccountNestedInput
    follows?: followsUncheckedUpdateManyWithoutAccountNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutAccountNestedInput
    conversations?: conversationUncheckedUpdateManyWithoutAccountNestedInput
    sharedNotes?: noteInternalShareUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type notesCreateManyAccountInput = {
    id?: number
    type?: number
    content?: string
    isArchived?: boolean
    isRecycle?: boolean
    isShare?: boolean
    isTop?: boolean
    isReviewed?: boolean
    sharePassword?: string
    shareEncryptedUrl?: string | null
    shareExpiryDate?: Date | string | null
    shareMaxView?: number | null
    shareViewCount?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type configCreateManyUserInput = {
    id?: number
    key?: string
    config?: NullableJsonNullValueInput | InputJsonValue
  }

  export type tagCreateManyAccountInput = {
    id?: number
    name?: string
    icon?: string
    parent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sortOrder?: number
  }

  export type commentsCreateManyAccountInput = {
    id?: number
    content: string
    guestName?: string | null
    guestIP?: string | null
    guestUA?: string | null
    noteId: number
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type attachmentsCreateManyAccountInput = {
    id?: number
    isShare?: boolean
    sharePassword?: string
    name?: string
    path?: string
    size?: Decimal | DecimalJsLike | number | string
    type?: string
    noteId?: number | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    perfixPath?: string | null
    depth?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type followsCreateManyAccountInput = {
    id?: number
    siteName?: string | null
    siteUrl: string
    siteAvatar?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    followType?: string
  }

  export type notificationsCreateManyAccountInput = {
    id?: number
    type: string
    title: string
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type conversationCreateManyAccountInput = {
    id?: number
    title?: string
    isShare?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type noteInternalShareCreateManyAccountInput = {
    id?: number
    noteId: number
    canEdit?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type aiScheduledTaskCreateManyAccountInput = {
    id?: number
    name: string
    prompt: string
    schedule: string
    isEnabled?: boolean
    lastRun?: Date | string | null
    lastResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type notesUpdateWithoutAccountInput = {
    type?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isRecycle?: BoolFieldUpdateOperationsInput | boolean
    isShare?: BoolFieldUpdateOperationsInput | boolean
    isTop?: BoolFieldUpdateOperationsInput | boolean
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    shareEncryptedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shareExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareMaxView?: NullableIntFieldUpdateOperationsInput | number | null
    shareViewCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: attachmentsUpdateManyWithoutNoteNestedInput
    tags?: tagsToNoteUpdateManyWithoutNoteNestedInput
    referencedBy?: noteReferenceUpdateManyWithoutToNoteNestedInput
    references?: noteReferenceUpdateManyWithoutFromNoteNestedInput
    comments?: commentsUpdateManyWithoutNoteNestedInput
    histories?: noteHistoryUpdateManyWithoutNoteNestedInput
    internalShares?: noteInternalShareUpdateManyWithoutNoteNestedInput
  }

  export type notesUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isRecycle?: BoolFieldUpdateOperationsInput | boolean
    isShare?: BoolFieldUpdateOperationsInput | boolean
    isTop?: BoolFieldUpdateOperationsInput | boolean
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    shareEncryptedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shareExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareMaxView?: NullableIntFieldUpdateOperationsInput | number | null
    shareViewCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: attachmentsUncheckedUpdateManyWithoutNoteNestedInput
    tags?: tagsToNoteUncheckedUpdateManyWithoutNoteNestedInput
    referencedBy?: noteReferenceUncheckedUpdateManyWithoutToNoteNestedInput
    references?: noteReferenceUncheckedUpdateManyWithoutFromNoteNestedInput
    comments?: commentsUncheckedUpdateManyWithoutNoteNestedInput
    histories?: noteHistoryUncheckedUpdateManyWithoutNoteNestedInput
    internalShares?: noteInternalShareUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type notesUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isRecycle?: BoolFieldUpdateOperationsInput | boolean
    isShare?: BoolFieldUpdateOperationsInput | boolean
    isTop?: BoolFieldUpdateOperationsInput | boolean
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    shareEncryptedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    shareExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareMaxView?: NullableIntFieldUpdateOperationsInput | number | null
    shareViewCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type configUpdateWithoutUserInput = {
    key?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
  }

  export type configUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
  }

  export type configUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
  }

  export type tagUpdateWithoutAccountInput = {
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    parent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    tagsToNote?: tagsToNoteUpdateManyWithoutTagNestedInput
  }

  export type tagUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    parent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    tagsToNote?: tagsToNoteUncheckedUpdateManyWithoutTagNestedInput
  }

  export type tagUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    parent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type commentsUpdateWithoutAccountInput = {
    content?: StringFieldUpdateOperationsInput | string
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestIP?: NullableStringFieldUpdateOperationsInput | string | null
    guestUA?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: notesUpdateOneRequiredWithoutCommentsNestedInput
    parent?: commentsUpdateOneWithoutRepliesNestedInput
    replies?: commentsUpdateManyWithoutParentNestedInput
  }

  export type commentsUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestIP?: NullableStringFieldUpdateOperationsInput | string | null
    guestUA?: NullableStringFieldUpdateOperationsInput | string | null
    noteId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: commentsUncheckedUpdateManyWithoutParentNestedInput
  }

  export type commentsUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestIP?: NullableStringFieldUpdateOperationsInput | string | null
    guestUA?: NullableStringFieldUpdateOperationsInput | string | null
    noteId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type attachmentsUpdateWithoutAccountInput = {
    isShare?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perfixPath?: NullableStringFieldUpdateOperationsInput | string | null
    depth?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    note?: notesUpdateOneWithoutAttachmentsNestedInput
  }

  export type attachmentsUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    isShare?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    noteId?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perfixPath?: NullableStringFieldUpdateOperationsInput | string | null
    depth?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type attachmentsUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    isShare?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    noteId?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perfixPath?: NullableStringFieldUpdateOperationsInput | string | null
    depth?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type followsUpdateWithoutAccountInput = {
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    siteUrl?: StringFieldUpdateOperationsInput | string
    siteAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followType?: StringFieldUpdateOperationsInput | string
  }

  export type followsUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    siteUrl?: StringFieldUpdateOperationsInput | string
    siteAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followType?: StringFieldUpdateOperationsInput | string
  }

  export type followsUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    siteUrl?: StringFieldUpdateOperationsInput | string
    siteAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followType?: StringFieldUpdateOperationsInput | string
  }

  export type notificationsUpdateWithoutAccountInput = {
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type conversationUpdateWithoutAccountInput = {
    title?: StringFieldUpdateOperationsInput | string
    isShare?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: messageUpdateManyWithoutConversationNestedInput
  }

  export type conversationUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    isShare?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: messageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type conversationUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    isShare?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type noteInternalShareUpdateWithoutAccountInput = {
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: notesUpdateOneRequiredWithoutInternalSharesNestedInput
  }

  export type noteInternalShareUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    noteId?: IntFieldUpdateOperationsInput | number
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type noteInternalShareUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    noteId?: IntFieldUpdateOperationsInput | number
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type aiScheduledTaskUpdateWithoutAccountInput = {
    name?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type aiScheduledTaskUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type aiScheduledTaskUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type attachmentsCreateManyNoteInput = {
    id?: number
    isShare?: boolean
    sharePassword?: string
    name?: string
    path?: string
    size?: Decimal | DecimalJsLike | number | string
    type?: string
    accountId?: number | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    perfixPath?: string | null
    depth?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type tagsToNoteCreateManyNoteInput = {
    id?: number
    tagId?: number
  }

  export type noteReferenceCreateManyToNoteInput = {
    id?: number
    fromNoteId: number
    createdAt?: Date | string
  }

  export type noteReferenceCreateManyFromNoteInput = {
    id?: number
    toNoteId: number
    createdAt?: Date | string
  }

  export type commentsCreateManyNoteInput = {
    id?: number
    content: string
    accountId?: number | null
    guestName?: string | null
    guestIP?: string | null
    guestUA?: string | null
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type noteHistoryCreateManyNoteInput = {
    id?: number
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version: number
    accountId?: number | null
    createdAt?: Date | string
  }

  export type noteInternalShareCreateManyNoteInput = {
    id?: number
    accountId: number
    canEdit?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type attachmentsUpdateWithoutNoteInput = {
    isShare?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perfixPath?: NullableStringFieldUpdateOperationsInput | string | null
    depth?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    account?: accountsUpdateOneWithoutAttachmentsNestedInput
  }

  export type attachmentsUncheckedUpdateWithoutNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    isShare?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perfixPath?: NullableStringFieldUpdateOperationsInput | string | null
    depth?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type attachmentsUncheckedUpdateManyWithoutNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    isShare?: BoolFieldUpdateOperationsInput | boolean
    sharePassword?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perfixPath?: NullableStringFieldUpdateOperationsInput | string | null
    depth?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type tagsToNoteUpdateWithoutNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    tag?: tagUpdateOneRequiredWithoutTagsToNoteNestedInput
  }

  export type tagsToNoteUncheckedUpdateWithoutNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type tagsToNoteUncheckedUpdateManyWithoutNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type noteReferenceUpdateWithoutToNoteInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromNote?: notesUpdateOneRequiredWithoutReferencesNestedInput
  }

  export type noteReferenceUncheckedUpdateWithoutToNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromNoteId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type noteReferenceUncheckedUpdateManyWithoutToNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromNoteId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type noteReferenceUpdateWithoutFromNoteInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toNote?: notesUpdateOneRequiredWithoutReferencedByNestedInput
  }

  export type noteReferenceUncheckedUpdateWithoutFromNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    toNoteId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type noteReferenceUncheckedUpdateManyWithoutFromNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    toNoteId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type commentsUpdateWithoutNoteInput = {
    content?: StringFieldUpdateOperationsInput | string
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestIP?: NullableStringFieldUpdateOperationsInput | string | null
    guestUA?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: accountsUpdateOneWithoutCommentsNestedInput
    parent?: commentsUpdateOneWithoutRepliesNestedInput
    replies?: commentsUpdateManyWithoutParentNestedInput
  }

  export type commentsUncheckedUpdateWithoutNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestIP?: NullableStringFieldUpdateOperationsInput | string | null
    guestUA?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: commentsUncheckedUpdateManyWithoutParentNestedInput
  }

  export type commentsUncheckedUpdateManyWithoutNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestIP?: NullableStringFieldUpdateOperationsInput | string | null
    guestUA?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type noteHistoryUpdateWithoutNoteInput = {
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type noteHistoryUncheckedUpdateWithoutNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type noteHistoryUncheckedUpdateManyWithoutNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type noteInternalShareUpdateWithoutNoteInput = {
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: accountsUpdateOneRequiredWithoutSharedNotesNestedInput
  }

  export type noteInternalShareUncheckedUpdateWithoutNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type noteInternalShareUncheckedUpdateManyWithoutNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    canEdit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type commentsCreateManyParentInput = {
    id?: number
    content: string
    accountId?: number | null
    guestName?: string | null
    guestIP?: string | null
    guestUA?: string | null
    noteId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type commentsUpdateWithoutParentInput = {
    content?: StringFieldUpdateOperationsInput | string
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestIP?: NullableStringFieldUpdateOperationsInput | string | null
    guestUA?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: notesUpdateOneRequiredWithoutCommentsNestedInput
    account?: accountsUpdateOneWithoutCommentsNestedInput
    replies?: commentsUpdateManyWithoutParentNestedInput
  }

  export type commentsUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestIP?: NullableStringFieldUpdateOperationsInput | string | null
    guestUA?: NullableStringFieldUpdateOperationsInput | string | null
    noteId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: commentsUncheckedUpdateManyWithoutParentNestedInput
  }

  export type commentsUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestIP?: NullableStringFieldUpdateOperationsInput | string | null
    guestUA?: NullableStringFieldUpdateOperationsInput | string | null
    noteId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tagsToNoteCreateManyTagInput = {
    id?: number
    noteId?: number
  }

  export type tagsToNoteUpdateWithoutTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    note?: notesUpdateOneRequiredWithoutTagsNestedInput
  }

  export type tagsToNoteUncheckedUpdateWithoutTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    noteId?: IntFieldUpdateOperationsInput | number
  }

  export type tagsToNoteUncheckedUpdateManyWithoutTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    noteId?: IntFieldUpdateOperationsInput | number
  }

  export type messageCreateManyConversationInput = {
    id?: number
    content: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type messageUpdateWithoutConversationInput = {
    content?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type messageUncheckedUpdateWithoutConversationInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type messageUncheckedUpdateManyWithoutConversationInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type aiModelsCreateManyProviderInput = {
    id?: number
    title: string
    modelKey: string
    capabilities: JsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type aiModelsUpdateWithoutProviderInput = {
    title?: StringFieldUpdateOperationsInput | string
    modelKey?: StringFieldUpdateOperationsInput | string
    capabilities?: JsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type aiModelsUncheckedUpdateWithoutProviderInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    modelKey?: StringFieldUpdateOperationsInput | string
    capabilities?: JsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type aiModelsUncheckedUpdateManyWithoutProviderInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    modelKey?: StringFieldUpdateOperationsInput | string
    capabilities?: JsonNullValueInput | InputJsonValue
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}